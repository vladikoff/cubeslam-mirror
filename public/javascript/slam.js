

/**
 * hasOwnProperty.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module.exports) {
    module.exports = {};
    module.client = module.component = true;
    module.call(this, module.exports, require.relative(resolved), module);
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  var index = path + '/index.js';

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (has.call(require.modules, path)) return path;
  }

  if (has.call(require.aliases, index)) {
    return require.aliases[index];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!has.call(require.modules, from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    if ('.' != path.charAt(0)) {
      var segs = parent.split('/');
      var i = lastIndexOf(segs, 'deps') + 1;
      if (!i) i = 0;
      path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
      return path;
    }
    return require.normalize(p, path);
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return has.call(require.modules, localRequire.resolve(path));
  };

  return localRequire;
};
require.register("component-indexof/index.js", Function("exports, require, module",
"\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};//@ sourceURL=component-indexof/index.js"
));
require.register("component-emitter/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar index = require('indexof');\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  fn._off = on;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var i = index(callbacks, fn._off || fn);\n  if (~i) callbacks.splice(i, 1);\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//@ sourceURL=component-emitter/index.js"
));
require.register("component-mousetrap/index.js", Function("exports, require, module",
"/**\n * Copyright 2012 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.1.2\n * @url craig.is/killing/mice\n */\n\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n  var _MAP = {\n          8: 'backspace',\n          9: 'tab',\n          13: 'enter',\n          16: 'shift',\n          17: 'ctrl',\n          18: 'alt',\n          20: 'capslock',\n          27: 'esc',\n          32: 'space',\n          33: 'pageup',\n          34: 'pagedown',\n          35: 'end',\n          36: 'home',\n          37: 'left',\n          38: 'up',\n          39: 'right',\n          40: 'down',\n          45: 'ins',\n          46: 'del',\n          91: 'meta',\n          93: 'meta',\n          224: 'meta'\n      },\n\n      /**\n       * mapping for special characters so they can support\n       *\n       * this dictionary is only used incase you want to bind a\n       * keyup or keydown event to one of these keys\n       *\n       * @type {Object}\n       */\n      _KEYCODE_MAP = {\n          106: '*',\n          107: '+',\n          109: '-',\n          110: '.',\n          111 : '/',\n          186: ';',\n          187: '=',\n          188: ',',\n          189: '-',\n          190: '.',\n          191: '/',\n          192: '`',\n          219: '[',\n          220: '\\\\',\n          221: ']',\n          222: '\\''\n      },\n\n      /**\n       * this is a mapping of keys that require shift on a US keypad\n       * back to the non shift equivelents\n       *\n       * this is so you can use keyup events with these keys\n       *\n       * note that this will only work reliably on US keyboards\n       *\n       * @type {Object}\n       */\n      _SHIFT_MAP = {\n          '~': '`',\n          '!': '1',\n          '@': '2',\n          '#': '3',\n          '$': '4',\n          '%': '5',\n          '^': '6',\n          '&': '7',\n          '*': '8',\n          '(': '9',\n          ')': '0',\n          '_': '-',\n          '+': '=',\n          ':': ';',\n          '\\\"': '\\'',\n          '<': ',',\n          '>': '.',\n          '?': '/',\n          '|': '\\\\'\n      },\n\n      /**\n       * this is a list of special strings you can use to map\n       * to modifier keys when you specify your keyboard shortcuts\n       *\n       * @type {Object}\n       */\n      _SPECIAL_ALIASES = {\n          'option': 'alt',\n          'command': 'meta',\n          'return': 'enter',\n          'escape': 'esc'\n      },\n\n      /**\n       * variable to store the flipped version of _MAP from above\n       * needed to check if we should use keypress or not when no action\n       * is specified\n       *\n       * @type {Object|undefined}\n       */\n      _REVERSE_MAP,\n\n      /**\n       * a list of all the callbacks setup via Mousetrap.bind()\n       *\n       * @type {Object}\n       */\n      _callbacks = {},\n\n      /**\n       * direct map of string combinations to callbacks used for trigger()\n       *\n       * @type {Object}\n       */\n      _direct_map = {},\n\n      /**\n       * keeps track of what level each sequence is at since multiple\n       * sequences can start out with the same sequence\n       *\n       * @type {Object}\n       */\n      _sequence_levels = {},\n\n      /**\n       * variable to store the setTimeout call\n       *\n       * @type {null|number}\n       */\n      _reset_timer,\n\n      /**\n       * temporary state where we will ignore the next keyup\n       *\n       * @type {boolean|string}\n       */\n      _ignore_next_keyup = false,\n\n      /**\n       * are we currently inside of a sequence?\n       * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n       *\n       * @type {boolean|string}\n       */\n      _inside_sequence = false;\n\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n  for (var i = 1; i < 20; ++i) {\n      _MAP[111 + i] = 'f' + i;\n  }\n\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n  for (i = 0; i <= 9; ++i) {\n      _MAP[i + 96] = i;\n  }\n\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n  function _addEvent(object, type, callback) {\n      if (object.addEventListener) {\n          return object.addEventListener(type, callback, false);\n      }\n\n      object.attachEvent('on' + type, callback);\n  }\n\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n  function _characterFromEvent(e) {\n\n      // for keypress events we should return the character as is\n      if (e.type == 'keypress') {\n          return String.fromCharCode(e.which);\n      }\n\n      // for non keypress events the special maps are needed\n      if (_MAP[e.which]) {\n          return _MAP[e.which];\n      }\n\n      if (_KEYCODE_MAP[e.which]) {\n          return _KEYCODE_MAP[e.which];\n      }\n\n      // if it is not in the special map\n      return String.fromCharCode(e.which).toLowerCase();\n  }\n\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @return {boolean}\n   */\n  function _stop(e) {\n      var element = e.target || e.srcElement,\n          tag_name = element.tagName;\n\n      // if the element has the class \"mousetrap\" then no need to stop\n      if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n          return false;\n      }\n\n      // stop for input, select, and textarea\n      return tag_name == 'INPUT' || tag_name == 'SELECT' || tag_name == 'TEXTAREA' || (element.contentEditable && element.contentEditable == 'true');\n  }\n\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n  function _modifiersMatch(modifiers1, modifiers2) {\n      return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n\n  /**\n   * resets all sequence counters except for the ones passed in\n   *\n   * @param {Object} do_not_reset\n   * @returns void\n   */\n  function _resetSequences(do_not_reset) {\n      do_not_reset = do_not_reset || {};\n\n      var active_sequences = false,\n          key;\n\n      for (key in _sequence_levels) {\n          if (do_not_reset[key]) {\n              active_sequences = true;\n              continue;\n          }\n          _sequence_levels[key] = 0;\n      }\n\n      if (!active_sequences) {\n          _inside_sequence = false;\n      }\n  }\n\n  /**\n   * finds all callbacks that match based on the keycode, modifiers,\n   * and action\n   *\n   * @param {string} character\n   * @param {Array} modifiers\n   * @param {string} action\n   * @param {boolean=} remove - should we remove any matches\n   * @param {string=} combination\n   * @returns {Array}\n   */\n  function _getMatches(character, modifiers, action, remove, combination) {\n      var i,\n          callback,\n          matches = [];\n\n      // if there are no events related to this keycode\n      if (!_callbacks[character]) {\n          return [];\n      }\n\n      // if a modifier key is coming up on its own we should allow it\n      if (action == 'keyup' && _isModifier(character)) {\n          modifiers = [character];\n      }\n\n      // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n      for (i = 0; i < _callbacks[character].length; ++i) {\n          callback = _callbacks[character][i];\n\n          // if this is a sequence but it is not at the right level\n          // then move onto the next match\n          if (callback.seq && _sequence_levels[callback.seq] != callback.level) {\n              continue;\n          }\n\n          // if the action we are looking for doesn't match the action we got\n          // then we should keep going\n          if (action != callback.action) {\n              continue;\n          }\n\n          // if this is a keypress event that means that we need to only\n          // look at the character, otherwise check the modifiers as\n          // well\n          if (action == 'keypress' || _modifiersMatch(modifiers, callback.modifiers)) {\n\n              // remove is used so if you change your mind and call bind a\n              // second time with a new function the first one is overwritten\n              if (remove && callback.combo == combination) {\n                  _callbacks[character].splice(i, 1);\n              }\n\n              matches.push(callback);\n          }\n      }\n\n      return matches;\n  }\n\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n  function _eventModifiers(e) {\n      var modifiers = [];\n\n      if (e.shiftKey) {\n          modifiers.push('shift');\n      }\n\n      if (e.altKey) {\n          modifiers.push('alt');\n      }\n\n      if (e.ctrlKey) {\n          modifiers.push('ctrl');\n      }\n\n      if (e.metaKey) {\n          modifiers.push('meta');\n      }\n\n      return modifiers;\n  }\n\n  /**\n   * actually calls the callback function\n   *\n   * if your callback function returns false this will use the jquery\n   * convention - prevent default and stop propogation on the event\n   *\n   * @param {Function} callback\n   * @param {Event} e\n   * @returns void\n   */\n  function _fireCallback(callback, e) {\n      if (callback(e) === false) {\n          if (e.preventDefault) {\n              e.preventDefault();\n          }\n\n          if (e.stopPropagation) {\n              e.stopPropagation();\n          }\n\n          e.returnValue = false;\n          e.cancelBubble = true;\n      }\n  }\n\n  /**\n   * handles a character key event\n   *\n   * @param {string} character\n   * @param {Event} e\n   * @returns void\n   */\n  function _handleCharacter(character, e) {\n\n      // if this event should not happen stop here\n      if (_stop(e)) {\n          return;\n      }\n\n      var callbacks = _getMatches(character, _eventModifiers(e), e.type),\n          i,\n          do_not_reset = {},\n          processed_sequence_callback = false;\n\n      // loop through matching callbacks for this key event\n      for (i = 0; i < callbacks.length; ++i) {\n\n          // fire for all sequence callbacks\n          // this is because if for example you have multiple sequences\n          // bound such as \"g i\" and \"g t\" they both need to fire the\n          // callback for matching g cause otherwise you can only ever\n          // match the first one\n          if (callbacks[i].seq) {\n              processed_sequence_callback = true;\n\n              // keep a list of which sequences were matches for later\n              do_not_reset[callbacks[i].seq] = 1;\n              _fireCallback(callbacks[i].callback, e);\n              continue;\n          }\n\n          // if there were no sequence matches but we are still here\n          // that means this is a regular match so we should fire that\n          if (!processed_sequence_callback && !_inside_sequence) {\n              _fireCallback(callbacks[i].callback, e);\n          }\n      }\n\n      // if you are inside of a sequence and the key you are pressing\n      // is not a modifier key then we should reset all sequences\n      // that were not matched by this key event\n      if (e.type == _inside_sequence && !_isModifier(character)) {\n          _resetSequences(do_not_reset);\n      }\n  }\n\n  /**\n   * handles a keydown event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n  function _handleKey(e) {\n\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      e.which = typeof e.which == \"number\" ? e.which : e.keyCode;\n\n      var character = _characterFromEvent(e);\n\n      // no character found then stop\n      if (!character) {\n          return;\n      }\n\n      if (e.type == 'keyup' && _ignore_next_keyup == character) {\n          _ignore_next_keyup = false;\n          return;\n      }\n\n      _handleCharacter(character, e);\n  }\n\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n  function _isModifier(key) {\n      return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n\n  /**\n   * called to set a 1 second timeout on the specified sequence\n   *\n   * this is so after each key press in the sequence you have 1 second\n   * to press the next key before you have to start over\n   *\n   * @returns void\n   */\n  function _resetSequenceTimer() {\n      clearTimeout(_reset_timer);\n      _reset_timer = setTimeout(_resetSequences, 1000);\n  }\n\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n  function _getReverseMap() {\n      if (!_REVERSE_MAP) {\n          _REVERSE_MAP = {};\n          for (var key in _MAP) {\n\n              // pull out the numeric keypad from here cause keypress should\n              // be able to detect the keys from the character\n              if (key > 95 && key < 112) {\n                  continue;\n              }\n\n              if (_MAP.hasOwnProperty(key)) {\n                  _REVERSE_MAP[_MAP[key]] = key;\n              }\n          }\n      }\n      return _REVERSE_MAP;\n  }\n\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n  function _pickBestAction(key, modifiers, action) {\n\n      // if no action was picked in we should try to pick the one\n      // that we think would work best for this key\n      if (!action) {\n          action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n      }\n\n      // modifier keys don't work as expected with keypress,\n      // switch to keydown\n      if (action == 'keypress' && modifiers.length) {\n          action = 'keydown';\n      }\n\n      return action;\n  }\n\n  /**\n   * binds a key sequence to an event\n   *\n   * @param {string} combo - combo specified in bind call\n   * @param {Array} keys\n   * @param {Function} callback\n   * @param {string=} action\n   * @returns void\n   */\n  function _bindSequence(combo, keys, callback, action) {\n\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequence_levels[combo] = 0;\n\n      // if there is no action pick the best one for the first key\n      // in the sequence\n      if (!action) {\n          action = _pickBestAction(keys[0], []);\n      }\n\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {Event} e\n       * @returns void\n       */\n      var _increaseSequence = function(e) {\n              _inside_sequence = action;\n              ++_sequence_levels[combo];\n              _resetSequenceTimer();\n          },\n\n          /**\n           * wraps the specified callback inside of another function in order\n           * to reset all sequence counters as soon as this sequence is done\n           *\n           * @param {Event} e\n           * @returns void\n           */\n          _callbackAndReset = function(e) {\n              _fireCallback(callback, e);\n\n              // we should ignore the next key up if the action is key down\n              // or keypress.  this is so if you finish a sequence and\n              // release the key the final key will not trigger a keyup\n              if (action !== 'keyup') {\n                  _ignore_next_keyup = _characterFromEvent(e);\n              }\n\n              // weird race condition if a sequence ends with the key\n              // another sequence begins with\n              setTimeout(_resetSequences, 10);\n          },\n          i;\n\n      // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      for (i = 0; i < keys.length; ++i) {\n          _bindSingle(keys[i], i < keys.length - 1 ? _increaseSequence : _callbackAndReset, action, combo, i);\n      }\n  }\n\n  /**\n   * binds a single keyboard combination\n   *\n   * @param {string} combination\n   * @param {Function} callback\n   * @param {string=} action\n   * @param {string=} sequence_name - name of sequence if part of sequence\n   * @param {number=} level - what part of the sequence the command is\n   * @returns void\n   */\n  function _bindSingle(combination, callback, action, sequence_name, level) {\n\n      // make sure multiple spaces in a row become a single space\n      combination = combination.replace(/\\s+/g, ' ');\n\n      var sequence = combination.split(' '),\n          i,\n          key,\n          keys,\n          modifiers = [];\n\n      // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n      if (sequence.length > 1) {\n          return _bindSequence(combination, sequence, callback, action);\n      }\n\n      // take the keys from this pattern and figure out what the actual\n      // pattern is all about\n      keys = combination === '+' ? ['+'] : combination.split('+');\n\n      for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n\n          // normalize key names\n          if (_SPECIAL_ALIASES[key]) {\n              key = _SPECIAL_ALIASES[key];\n          }\n\n          // if this is not a keypress event then we should\n          // be smart about using shift keys\n          // this will only work for US keyboards however\n          if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n              key = _SHIFT_MAP[key];\n              modifiers.push('shift');\n          }\n\n          // if this key is a modifier then add it to the list of modifiers\n          if (_isModifier(key)) {\n              modifiers.push(key);\n          }\n      }\n\n      // depending on what the key combination is\n      // we will try to pick the best event for it\n      action = _pickBestAction(key, modifiers, action);\n\n      // make sure to initialize array if this is the first time\n      // a callback is added for this key\n      if (!_callbacks[key]) {\n          _callbacks[key] = [];\n      }\n\n      // remove an existing match if there is one\n      _getMatches(key, modifiers, action, !sequence_name, combination);\n\n      // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n      _callbacks[key][sequence_name ? 'unshift' : 'push']({\n          callback: callback,\n          modifiers: modifiers,\n          action: action,\n          seq: sequence_name,\n          level: level,\n          combo: combination\n      });\n  }\n\n  /**\n   * binds multiple combinations to the same callback\n   *\n   * @param {Array} combinations\n   * @param {Function} callback\n   * @param {string|undefined} action\n   * @returns void\n   */\n  function _bindMultiple(combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n          _bindSingle(combinations[i], callback, action);\n      }\n  }\n\n  // start!\n  _addEvent(document, 'keypress', _handleKey);\n  _addEvent(document, 'keydown', _handleKey);\n  _addEvent(document, 'keyup', _handleKey);\n\n  var mousetrap = {\n\n      /**\n       * binds an event to mousetrap\n       *\n       * can be a single key, a combination of keys separated with +,\n       * a comma separated list of keys, an array of keys, or\n       * a sequence of keys separated by spaces\n       *\n       * be sure to list the modifier keys first to make sure that the\n       * correct key ends up getting bound (the last key in the pattern)\n       *\n       * @param {string|Array} keys\n       * @param {Function} callback\n       * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n       * @returns void\n       */\n      bind: function(keys, callback, action) {\n          _bindMultiple(keys instanceof Array ? keys : [keys], callback, action);\n          _direct_map[keys + ':' + action] = callback;\n          return this;\n      },\n\n      /**\n       * unbinds an event to mousetrap\n       *\n       * the unbinding sets the callback function of the specified key combo\n       * to an empty function and deletes the corresponding key in the\n       * _direct_map dict.\n       *\n       * the keycombo+action has to be exactly the same as\n       * it was defined in the bind method\n       *\n       * TODO: actually remove this from the _callbacks dictionary instead\n       * of binding an empty function\n       *\n       * @param {string|Array} keys\n       * @param {string} action\n       * @returns void\n       */\n      unbind: function(keys, action) {\n          if (_direct_map[keys + ':' + action]) {\n              delete _direct_map[keys + ':' + action];\n              this.bind(keys, function() {}, action);\n          }\n          return this;\n      },\n\n      /**\n       * triggers an event that has already been bound\n       *\n       * @param {string} keys\n       * @param {string=} action\n       * @returns void\n       */\n      trigger: function(keys, action) {\n          _direct_map[keys + ':' + action]();\n          return this;\n      },\n\n      /**\n       * resets the library back to its initial state.  this is useful\n       * if you want to clear out the current keyboard shortcuts and bind\n       * new ones - for example if you switch to another page\n       *\n       * @returns void\n       */\n      reset: function() {\n          _callbacks = {};\n          _direct_map = {};\n          return this;\n      }\n  };\n\nmodule.exports = mousetrap;\n\n//@ sourceURL=component-mousetrap/index.js"
));
require.register("component-cookie/index.js", Function("exports, require, module",
"/**\n * Encode.\n */\n\nvar encode = encodeURIComponent;\n\n/**\n * Decode.\n */\n\nvar decode = decodeURIComponent;\n\n/**\n * Set or get cookie `name` with `value` and `options` object.\n *\n * @param {String} name\n * @param {String} value\n * @param {Object} options\n * @return {Mixed}\n * @api public\n */\n\nmodule.exports = function(name, value, options){\n  switch (arguments.length) {\n    case 3:\n    case 2:\n      return set(name, value, options);\n    case 1:\n      return get(name);\n    default:\n      return all();\n  }\n};\n\n/**\n * Set cookie `name` to `value`.\n *\n * @param {String} name\n * @param {String} value\n * @param {Object} options\n * @api private\n */\n\nfunction set(name, value, options) {\n  options = options || {};\n  var str = encode(name) + '=' + encode(value);\n\n  if (null == value) options.maxage = -1;\n\n  if (options.maxage) {\n    options.expires = new Date(+new Date + options.maxage);\n  }\n\n  if (options.path) str += '; path=' + options.path;\n  if (options.domain) str += '; domain=' + options.domain;\n  if (options.expires) str += '; expires=' + options.expires.toUTCString();\n  if (options.secure) str += '; secure';\n\n  document.cookie = str;\n}\n\n/**\n * Return all cookies.\n *\n * @return {Object}\n * @api private\n */\n\nfunction all() {\n  return parse(document.cookie);\n}\n\n/**\n * Get cookie `name`.\n *\n * @param {String} name\n * @return {String}\n * @api private\n */\n\nfunction get(name) {\n  return all()[name];\n}\n\n/**\n * Parse cookie `str`.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parse(str) {\n  var obj = {};\n  var pairs = str.split(/ *; */);\n  var pair;\n  if ('' == pairs[0]) return obj;\n  for (var i = 0; i < pairs.length; ++i) {\n    pair = pairs[i].split('=');\n    obj[decode(pair[0])] = decode(pair[1]);\n  }\n  return obj;\n}\n//@ sourceURL=component-cookie/index.js"
));
require.register("component-jquery/index.js", Function("exports, require, module",
"/*!\n * jQuery JavaScript Library v1.9.1\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-2-4\n */\n(function( window, undefined ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\"use strict\";\nvar\n\t// The deferred used on DOM ready\n\treadyList,\n\n\t// A central reference to the root jQuery(document)\n\trootjQuery,\n\n\t// Support: IE<9\n\t// For `typeof node.method` instead of `node.method !== undefined`\n\tcore_strundefined = typeof undefined,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\tlocation = window.location,\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\t// [[Class]] -> type pairs\n\tclass2type = {},\n\n\t// List of deleted data cache ids, so we can reuse them\n\tcore_deletedIds = [],\n\n\tcore_version = \"1.9.1\",\n\n\t// Save a reference to some core methods\n\tcore_concat = core_deletedIds.concat,\n\tcore_push = core_deletedIds.push,\n\tcore_slice = core_deletedIds.slice,\n\tcore_indexOf = core_deletedIds.indexOf,\n\tcore_toString = class2type.toString,\n\tcore_hasOwn = class2type.hasOwnProperty,\n\tcore_trim = core_version.trim,\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\t},\n\n\t// Used for matching numbers\n\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\n\t// Used for splitting on whitespace\n\tcore_rnotwhite = /\\S+/g,\n\n\t// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\t// Match a standalone tag\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n\t// JSON RegExp\n\trvalidchars = /^[\\],:{}\\s]*$/,\n\trvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n\trvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n\trvalidtokens = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t},\n\n\t// The ready event handler\n\tcompleted = function( event ) {\n\n\t\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\t\tif ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n\t\t\tdetach();\n\t\t\tjQuery.ready();\n\t\t}\n\t},\n\t// Clean-up method for dom ready events\n\tdetach = function() {\n\t\tif ( document.addEventListener ) {\n\t\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\t\twindow.removeEventListener( \"load\", completed, false );\n\n\t\t} else {\n\t\t\tdocument.detachEvent( \"onreadystatechange\", completed );\n\t\t\twindow.detachEvent( \"onload\", completed );\n\t\t}\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: core_version,\n\n\tconstructor: jQuery,\n\tinit: function( selector, context, rootjQuery ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\ttoArray: function() {\n\t\treturn core_slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tready: function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: core_push,\n\tsort: [].sort,\n\tsplice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar src, copyIsArray, copy, name, options, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\tnoConflict: function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t},\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\tif ( !document.body ) {\n\t\t\treturn setTimeout( jQuery.ready );\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray || function( obj ) {\n\t\treturn jQuery.type(obj) === \"array\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj == obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn String( obj );\n\t\t}\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// Not own constructor property must be Object\n\t\t\tif ( obj.constructor &&\n\t\t\t\t!core_hasOwn.call(obj, \"constructor\") &&\n\t\t\t\t!core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\treturn false;\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\n\t\tvar key;\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || core_hasOwn.call( obj, key );\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tparseHTML: function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\t\tif ( scripts ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t},\n\n\tparseJSON: function( data ) {\n\t\t// Attempt to parse using the native JSON parser first\n\t\tif ( window.JSON && window.JSON.parse ) {\n\t\t\treturn window.JSON.parse( data );\n\t\t}\n\n\t\tif ( data === null ) {\n\t\t\treturn data;\n\t\t}\n\n\t\tif ( typeof data === \"string\" ) {\n\n\t\t\t// Make sure leading/trailing whitespace is removed (IE can't handle it)\n\t\t\tdata = jQuery.trim( data );\n\n\t\t\tif ( data ) {\n\t\t\t\t// Make sure the incoming data is actual JSON\n\t\t\t\t// Logic borrowed from http://json.org/json2.js\n\t\t\t\tif ( rvalidchars.test( data.replace( rvalidescape, \"@\" )\n\t\t\t\t\t.replace( rvalidtokens, \"]\" )\n\t\t\t\t\t.replace( rvalidbraces, \"\")) ) {\n\n\t\t\t\t\treturn ( new Function( \"return \" + data ) )();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tjQuery.error( \"Invalid JSON: \" + data );\n\t},\n\n\t// Cross-browser xml parsing\n\tparseXML: function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tif ( window.DOMParser ) { // Standard\n\t\t\t\ttmp = new DOMParser();\n\t\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\t\t\t} else { // IE\n\t\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\t\txml.async = \"false\";\n\t\t\t\txml.loadXML( data );\n\t\t\t}\n\t\t} catch( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t},\n\n\tnoop: function() {},\n\n\t// Evaluates a script in a global context\n\t// Workarounds based on findings by Jim Driscoll\n\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\tglobalEval: function( data ) {\n\t\tif ( data && jQuery.trim( data ) ) {\n\t\t\t// We use execScript on Internet Explorer\n\t\t\t// We use an anonymous function so that context is window\n\t\t\t// rather than jQuery in Firefox\n\t\t\t( window.execScript || function( data ) {\n\t\t\t\twindow[ \"eval\" ].call( window, data );\n\t\t\t} )( data );\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Use native String.trim function wherever possible\n\ttrim: core_trim && !core_trim.call(\"\\uFEFF\\xA0\") ?\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\tcore_trim.call( text );\n\t\t} :\n\n\t\t// Otherwise use our own trimming functionality\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcore_push.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\tvar len;\n\n\t\tif ( arr ) {\n\t\t\tif ( core_indexOf ) {\n\t\t\t\treturn core_indexOf.call( arr, elem, i );\n\t\t\t}\n\n\t\t\tlen = arr.length;\n\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar l = second.length,\n\t\t\ti = first.length,\n\t\t\tj = 0;\n\n\t\tif ( typeof l === \"number\" ) {\n\t\t\tfor ( ; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar retVal,\n\t\t\tret = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length;\n\t\tinv = !!inv;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tretVal = !!callback( elems[ i ], i );\n\t\t\tif ( inv !== retVal ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn core_concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar args, proxy, tmp;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = core_slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlength = elems.length,\n\t\t\tbulk = key == null;\n\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\t},\n\n\tnow: function() {\n\t\treturn ( new Date() ).getTime();\n\t}\n});\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t// Standards-based browsers support DOMContentLoaded\n\t\t} else if ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\n\t\t// If IE event model is used\n\t\t} else {\n\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\tdocument.attachEvent( \"onreadystatechange\", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", completed );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar top = false;\n\n\t\t\ttry {\n\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t} catch(e) {}\n\n\t\t\tif ( top && top.doScroll ) {\n\t\t\t\t(function doScrollCheck() {\n\t\t\t\t\tif ( !jQuery.isReady ) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\treturn setTimeout( doScrollCheck, 50 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// detach all dom ready events\n\t\t\t\t\t\tdetach();\n\n\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || type !== \"function\" &&\n\t\t( length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\t\t// Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\targs = args || [];\n\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\njQuery.support = (function() {\n\n\tvar support, all, a,\n\t\tinput, select, fragment,\n\t\topt, eventName, isSupported, i,\n\t\tdiv = document.createElement(\"div\");\n\n\t// Setup\n\tdiv.setAttribute( \"className\", \"t\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\t// Support tests won't run in some limited or non-browser environments\n\tall = div.getElementsByTagName(\"*\");\n\ta = div.getElementsByTagName(\"a\")[ 0 ];\n\tif ( !all || !a || !all.length ) {\n\t\treturn {};\n\t}\n\n\t// First batch of tests\n\tselect = document.createElement(\"select\");\n\topt = select.appendChild( document.createElement(\"option\") );\n\tinput = div.getElementsByTagName(\"input\")[ 0 ];\n\n\ta.style.cssText = \"top:1px;float:left;opacity:.5\";\n\tsupport = {\n\t\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\t\tgetSetAttribute: div.className !== \"t\",\n\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tleadingWhitespace: div.firstChild.nodeType === 3,\n\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText instead)\n\t\tstyle: /top/.test( a.getAttribute(\"style\") ),\n\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\threfNormalized: a.getAttribute(\"href\") === \"/a\",\n\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\t// Use a regex to work around a WebKit issue. See #5145\n\t\topacity: /^0.5/.test( a.style.opacity ),\n\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tcssFloat: !!a.style.cssFloat,\n\n\t\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\t\tcheckOn: !!input.value,\n\n\t\t// Make sure that a selected-by-default option has a working selected property.\n\t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\t\toptSelected: opt.selected,\n\n\t\t// Tests for enctype support on a form (#6743)\n\t\tenctype: !!document.createElement(\"form\").enctype,\n\n\t\t// Makes sure cloning an html5 element does not cause problems\n\t\t// Where outerHTML is undefined, this still works\n\t\thtml5Clone: document.createElement(\"nav\").cloneNode( true ).outerHTML !== \"<:nav></:nav>\",\n\n\t\t// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode\n\t\tboxModel: document.compatMode === \"CSS1Compat\",\n\n\t\t// Will be defined later\n\t\tdeleteExpando: true,\n\t\tnoCloneEvent: true,\n\t\tinlineBlockNeedsLayout: false,\n\t\tshrinkWrapBlocks: false,\n\t\treliableMarginRight: true,\n\t\tboxSizingReliable: true,\n\t\tpixelPosition: false\n\t};\n\n\t// Make sure checked status is properly cloned\n\tinput.checked = true;\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<9\n\ttry {\n\t\tdelete div.test;\n\t} catch( e ) {\n\t\tsupport.deleteExpando = false;\n\t}\n\n\t// Check if we can trust getAttribute(\"value\")\n\tinput = document.createElement(\"input\");\n\tinput.setAttribute( \"value\", \"\" );\n\tsupport.input = input.getAttribute( \"value\" ) === \"\";\n\n\t// Check if an input maintains its value after becoming a radio\n\tinput.value = \"t\";\n\tinput.setAttribute( \"type\", \"radio\" );\n\tsupport.radioValue = input.value === \"t\";\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tinput.setAttribute( \"checked\", \"t\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tfragment = document.createDocumentFragment();\n\tfragment.appendChild( input );\n\n\t// Check if a disconnected checkbox will retain its checked\n\t// value of true after appended to the DOM (IE6/7)\n\tsupport.appendChecked = input.checked;\n\n\t// WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<9\n\t// Opera does not clone events (and typeof div.attachEvent === undefined).\n\t// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\tif ( div.attachEvent ) {\n\t\tdiv.attachEvent( \"onclick\", function() {\n\t\t\tsupport.noCloneEvent = false;\n\t\t});\n\n\t\tdiv.cloneNode( true ).click();\n\t}\n\n\t// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)\n\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php\n\tfor ( i in { submit: true, change: true, focusin: true }) {\n\t\tdiv.setAttribute( eventName = \"on\" + i, \"t\" );\n\n\t\tsupport[ i + \"Bubbles\" ] = eventName in window || div.attributes[ eventName ].expando === false;\n\t}\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t// Run tests that need a body at doc ready\n\tjQuery(function() {\n\t\tvar container, marginDiv, tds,\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",\n\t\t\tbody = document.getElementsByTagName(\"body\")[0];\n\n\t\tif ( !body ) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer = document.createElement(\"div\");\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\t// Support: IE8\n\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t// to display:none and there are still other visible table cells in a\n\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t// determining if an element has been hidden directly using\n\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\ttds = div.getElementsByTagName(\"td\");\n\t\ttds[ 0 ].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n\t\tisSupported = ( tds[ 0 ].offsetHeight === 0 );\n\n\t\ttds[ 0 ].style.display = \"\";\n\t\ttds[ 1 ].style.display = \"none\";\n\n\t\t// Support: IE8\n\t\t// Check if empty table cells still have offsetWidth/Height\n\t\tsupport.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n\n\t\t// Check box-sizing and margin behavior\n\t\tdiv.innerHTML = \"\";\n\t\tdiv.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\";\n\t\tsupport.boxSizing = ( div.offsetWidth === 4 );\n\t\tsupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );\n\n\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t// Fails in WebKit before Feb 2011 nightlies\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\tsupport.reliableMarginRight =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n\t\t}\n\n\t\tif ( typeof div.style.zoom !== core_strundefined ) {\n\t\t\t// Support: IE<8\n\t\t\t// Check if natively block-level elements act like inline-block\n\t\t\t// elements when setting their display to 'inline' and giving\n\t\t\t// them layout\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdiv.style.cssText = divReset + \"width:1px;padding:1px;display:inline;zoom:1\";\n\t\t\tsupport.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );\n\n\t\t\t// Support: IE6\n\t\t\t// Check if elements with layout shrink-wrap their children\n\t\t\tdiv.style.display = \"block\";\n\t\t\tdiv.innerHTML = \"<div></div>\";\n\t\t\tdiv.firstChild.style.width = \"5px\";\n\t\t\tsupport.shrinkWrapBlocks = ( div.offsetWidth !== 3 );\n\n\t\t\tif ( support.inlineBlockNeedsLayout ) {\n\t\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\t\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\t\t\t\t// Support: IE<8\n\t\t\t\tbody.style.zoom = 1;\n\t\t\t}\n\t\t}\n\n\t\tbody.removeChild( container );\n\n\t\t// Null elements to avoid leaks in IE\n\t\tcontainer = div = tds = marginDiv = null;\n\t});\n\n\t// Null elements to avoid leaks in IE\n\tall = select = fragment = opt = a = input = null;\n\n\treturn support;\n})();\n\nvar rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ){\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar thisCache, ret,\n\t\tinternalKey = jQuery.expando,\n\t\tgetByName = typeof name === \"string\",\n\n\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t// can't GC object references properly across the DOM-JS boundary\n\t\tisNode = elem.nodeType,\n\n\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t// attached directly to the object so GC can occur automatically\n\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n\t// Avoid doing any more work than we need to when trying to get data on an\n\t// object that has no data at all\n\tif ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {\n\t\treturn;\n\t}\n\n\tif ( !id ) {\n\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t// ends up in the global cache\n\t\tif ( isNode ) {\n\t\t\telem[ internalKey ] = id = core_deletedIds.pop() || jQuery.guid++;\n\t\t} else {\n\t\t\tid = internalKey;\n\t\t}\n\t}\n\n\tif ( !cache[ id ] ) {\n\t\tcache[ id ] = {};\n\n\t\t// Avoids exposing jQuery metadata on plain JS objects when the object\n\t\t// is serialized using JSON.stringify\n\t\tif ( !isNode ) {\n\t\t\tcache[ id ].toJSON = jQuery.noop;\n\t\t}\n\t}\n\n\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t// shallow copied over onto the existing cache\n\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\tif ( pvt ) {\n\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\t\t} else {\n\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\t\t}\n\t}\n\n\tthisCache = cache[ id ];\n\n\t// jQuery data() is stored in a separate object inside the object's internal data\n\t// cache in order to avoid key collisions between internal data and user-defined\n\t// data.\n\tif ( !pvt ) {\n\t\tif ( !thisCache.data ) {\n\t\t\tthisCache.data = {};\n\t\t}\n\n\t\tthisCache = thisCache.data;\n\t}\n\n\tif ( data !== undefined ) {\n\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\t}\n\n\t// Check for both converted-to-camel and non-converted data property names\n\t// If a data property was specified\n\tif ( getByName ) {\n\n\t\t// First Try to find as-is property data\n\t\tret = thisCache[ name ];\n\n\t\t// Test for null|undefined property data\n\t\tif ( ret == null ) {\n\n\t\t\t// Try to find the camelCased property\n\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\t\t}\n\t} else {\n\t\tret = thisCache;\n\t}\n\n\treturn ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar i, l, thisCache,\n\t\tisNode = elem.nodeType,\n\n\t\t// See jQuery.data for more information\n\t\tcache = isNode ? jQuery.cache : elem,\n\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t// If there is already no cache entry for this object, there is no\n\t// purpose in continuing\n\tif ( !cache[ id ] ) {\n\t\treturn;\n\t}\n\n\tif ( name ) {\n\n\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n\t\tif ( thisCache ) {\n\n\t\t\t// Support array or space separated string names for data keys\n\t\t\tif ( !jQuery.isArray( name ) ) {\n\n\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\tname = [ name ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\tname = jQuery.camelCase( name );\n\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = name.split(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = name.concat( jQuery.map( name, jQuery.camelCase ) );\n\t\t\t}\n\n\t\t\tfor ( i = 0, l = name.length; i < l; i++ ) {\n\t\t\t\tdelete thisCache[ name[i] ];\n\t\t\t}\n\n\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t// and let the cache object itself get destroyed\n\t\t\tif ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// See jQuery.data for more information\n\tif ( !pvt ) {\n\t\tdelete cache[ id ].data;\n\n\t\t// Don't destroy the parent cache unless the internal data object\n\t\t// had been the only thing left in it\n\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Destroy the cache\n\tif ( isNode ) {\n\t\tjQuery.cleanData( [ elem ], true );\n\n\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t} else if ( jQuery.support.deleteExpando || cache != cache.window ) {\n\t\tdelete cache[ id ];\n\n\t// When all else fails, null\n\t} else {\n\t\tcache[ id ] = null;\n\t}\n}\n\njQuery.extend({\n\tcache: {},\n\n\t// Unique for each copy of jQuery on the page\n\t// Non-digits removed to match rinlinejQuery\n\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// The following elements throw uncatchable exceptions if you\n\t// attempt to add expando properties to them.\n\tnoData: {\n\t\t\"embed\": true,\n\t\t// Ban all objects except for Flash (which handle expandos)\n\t\t\"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n\t\t\"applet\": true\n\t},\n\n\thasData: function( elem ) {\n\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\t\treturn !!elem && !isEmptyDataObject( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name );\n\t},\n\n\t// For internal use only.\n\t_data: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data, true );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name, true );\n\t},\n\n\t// A method for determining if a DOM node can handle the data expando\n\tacceptData: function( elem ) {\n\t\t// Do not set data on non-element because it will not be cleared (#8335).\n\t\tif ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];\n\n\t\t// nodes accept data unless otherwise specified; rejection can be conditional\n\t\treturn !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar attrs, name,\n\t\t\telem = this[0],\n\t\t\ti = 0,\n\t\t\tdata = null;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = jQuery.data( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\t\t\t\t\tattrs = elem.attributes;\n\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\n\t\t\t\t\t\tname = attrs[i].name;\n\n\t\t\t\t\t\tif ( !name.indexOf( \"data-\" ) ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn jQuery.access( this, function( value ) {\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\t// Try to fetch any internally stored data first\n\t\t\t\treturn elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;\n\t\t\t}\n\n\t\t\tthis.each(function() {\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeData( this, key );\n\t\t});\n\t}\n});\n\nfunction dataAttr( elem, key, data ) {\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\n\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tjQuery.data( elem, key, data );\n\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n\tvar name;\n\tfor ( name in obj ) {\n\n\t\t// if the public data object is empty, the private is still empty\n\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( name !== \"toJSON\" ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = jQuery._data( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray(data) ) {\n\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\thooks.cur = fn;\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tjQuery._removeData( elem, type + \"queue\" );\n\t\t\t\tjQuery._removeData( elem, key );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tdelay: function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile( i-- ) {\n\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar nodeHook, boolHook,\n\trclass = /[\\t\\r\\n]/g,\n\trreturn = /\\r/g,\n\trfocusable = /^(?:input|select|textarea|button|object)$/i,\n\trclickable = /^(?:a|area)$/i,\n\trboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,\n\truseDefault = /^(?:checked|selected)$/i,\n\tgetSetAttribute = jQuery.support.getSetAttribute,\n\tgetSetInput = jQuery.support.input;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t},\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\tname = jQuery.propFix[ name ] || name;\n\t\treturn this.each(function() {\n\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\ttry {\n\t\t\t\tthis[ name ] = undefined;\n\t\t\t\tdelete this[ name ];\n\t\t\t} catch( e ) {}\n\t\t});\n\t},\n\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = jQuery.trim( cur );\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisBool = typeof stateVal === \"boolean\";\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tstate = stateVal,\n\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tstate = isBool ? state : !self.hasClass( className );\n\t\t\t\t\tself[ state ? \"addClass\" : \"removeClass\" ]( className );\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tval: function( value ) {\n\t\tvar ret, hooks, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val,\n\t\t\t\tself = jQuery(this);\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, self.val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map(val, function ( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\t\t\t\t// uses .value. See #6932\n\t\t\t\tvar val = elem.attributes.value;\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar values = jQuery.makeArray( value );\n\n\t\t\t\tjQuery(elem).find(\"option\").each(function() {\n\t\t\t\t\tthis.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;\n\t\t\t\t});\n\n\t\t\t\tif ( !values.length ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t},\n\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, notxml, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === core_strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( notxml ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && notxml && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && notxml && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\n\t\t\t// In IE9+, Flash objects don't have .getAttribute (#12945)\n\t\t\t// Support: IE9+\n\t\t\tif ( typeof elem.getAttribute !== core_strundefined ) {\n\t\t\t\tret =  elem.getAttribute( name );\n\t\t\t}\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( core_rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( rboolean.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false for boolean attributes\n\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8\n\t\t\t\t\tif ( !getSetAttribute && ruseDefault.test( name ) ) {\n\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] =\n\t\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\n\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\ttabindex: \"tabIndex\",\n\t\treadonly: \"readOnly\",\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\",\n\t\tmaxlength: \"maxLength\",\n\t\tcellspacing: \"cellSpacing\",\n\t\tcellpadding: \"cellPadding\",\n\t\trowspan: \"rowSpan\",\n\t\tcolspan: \"colSpan\",\n\t\tusemap: \"useMap\",\n\t\tframeborder: \"frameBorder\",\n\t\tcontenteditable: \"contentEditable\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\treturn ( elem[ name ] = value );\n\t\t\t}\n\n\t\t} else {\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\treturn elem[ name ];\n\t\t\t}\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\tvar attributeNode = elem.getAttributeNode(\"tabindex\");\n\n\t\t\t\treturn attributeNode && attributeNode.specified ?\n\t\t\t\t\tparseInt( attributeNode.value, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t0 :\n\t\t\t\t\t\tundefined;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hook for boolean attributes\nboolHook = {\n\tget: function( elem, name ) {\n\t\tvar\n\t\t\t// Use .prop to determine if this attribute is understood as boolean\n\t\t\tprop = jQuery.prop( elem, name ),\n\n\t\t\t// Fetch it accordingly\n\t\t\tattr = typeof prop === \"boolean\" && elem.getAttribute( name ),\n\t\t\tdetail = typeof prop === \"boolean\" ?\n\n\t\t\t\tgetSetInput && getSetAttribute ?\n\t\t\t\t\tattr != null :\n\t\t\t\t\t// oldIE fabricates an empty string for missing boolean attributes\n\t\t\t\t\t// and conflates checked/selected into attroperties\n\t\t\t\t\truseDefault.test( name ) ?\n\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] :\n\t\t\t\t\t\t!!attr :\n\n\t\t\t\t// fetch an attribute node for properties not recognized as boolean\n\t\t\t\telem.getAttributeNode( name );\n\n\t\treturn detail && detail.value !== false ?\n\t\t\tname.toLowerCase() :\n\t\t\tundefined;\n\t},\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t// IE<8 needs the *property* name\n\t\t\telem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n\t\t// Use defaultChecked and defaultSelected for oldIE\n\t\t} else {\n\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n\t\t}\n\n\t\treturn name;\n\t}\n};\n\n// fix oldIE value attroperty\nif ( !getSetInput || !getSetAttribute ) {\n\tjQuery.attrHooks.value = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\treturn jQuery.nodeName( elem, \"input\" ) ?\n\n\t\t\t\t// Ignore the value *property* by using defaultValue\n\t\t\t\telem.defaultValue :\n\n\t\t\t\tret && ret.specified ? ret.value : undefined;\n\t\t},\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\telem.defaultValue = value;\n\t\t\t} else {\n\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\t\t\t\treturn nodeHook && nodeHook.set( elem, value, name );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n\t// Use this for any attribute in IE6/7\n\t// This fixes almost every IE6/7 issue\n\tnodeHook = jQuery.valHooks.button = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\treturn ret && ( name === \"id\" || name === \"name\" || name === \"coords\" ? ret.value !== \"\" : ret.specified ) ?\n\t\t\t\tret.value :\n\t\t\t\tundefined;\n\t\t},\n\t\tset: function( elem, value, name ) {\n\t\t\t// Set the existing or create a new attribute node\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( !ret ) {\n\t\t\t\telem.setAttributeNode(\n\t\t\t\t\t(ret = elem.ownerDocument.createAttribute( name ))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tret.value = value += \"\";\n\n\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\t\t\treturn name === \"value\" || value === elem.getAttribute( name ) ?\n\t\t\t\tvalue :\n\t\t\t\tundefined;\n\t\t}\n\t};\n\n\t// Set contenteditable to false on removals(#10429)\n\t// Setting to empty string throws an error as an invalid value\n\tjQuery.attrHooks.contenteditable = {\n\t\tget: nodeHook.get,\n\t\tset: function( elem, value, name ) {\n\t\t\tnodeHook.set( elem, value === \"\" ? false : value, name );\n\t\t}\n\t};\n\n\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t// This is for removals\n\tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !jQuery.support.hrefNormalized ) {\n\tjQuery.each([ \"href\", \"src\", \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar ret = elem.getAttribute( name, 2 );\n\t\t\t\treturn ret == null ? undefined : ret;\n\t\t\t}\n\t\t});\n\t});\n\n\t// href/src property should get the full normalized URL (#10299/#12915)\n\tjQuery.each([ \"href\", \"src\" ], function( i, name ) {\n\t\tjQuery.propHooks[ name ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.getAttribute( name, 4 );\n\t\t\t}\n\t\t};\n\t});\n}\n\nif ( !jQuery.support.style ) {\n\tjQuery.attrHooks.style = {\n\t\tget: function( elem ) {\n\t\t\t// Return undefined in the case of empty string\n\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\t\t\t// .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n\t\t\treturn elem.style.cssText || undefined;\n\t\t},\n\t\tset: function( elem, value ) {\n\t\t\treturn ( elem.style.cssText = value + \"\" );\n\t\t}\n\t};\n}\n\n// Safari mis-reports the default selected property of an option\n// Accessing the parent's selectedIndex property fixes it\nif ( !jQuery.support.optSelected ) {\n\tjQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t});\n}\n\n// IE6/7 call enctype encoding\nif ( !jQuery.support.enctype ) {\n\tjQuery.propFix.enctype = \"encoding\";\n}\n\n// Radios and checkboxes getter/setter\nif ( !jQuery.support.checkOn ) {\n\tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\t// Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t}\n\t\t};\n\t});\n}\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t});\n});\nvar rformElems = /^(?:input|select|textarea)$/i,\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\t\tvar tmp, events, t, handleObjIn,\n\t\t\tspecial, eventHandle, handleObj,\n\t\t\thandlers, type, namespaces, origType,\n\t\t\telemData = jQuery._data( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\tvar j, handleObj, tmp,\n\t\t\torigCount, t, events,\n\t\t\tspecial, handlers, type,\n\t\t\tnamespaces, origType,\n\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\n\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t// so use it instead of delete\n\t\t\tjQuery._removeData( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\tvar handle, ontype, cur,\n\t\t\tbubbleType, special, tmp, i,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\tevent.isTrigger = true;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&\n\t\t\t\t!(type === \"click\" && jQuery.nodeName( elem, \"a\" )) && jQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\ttry {\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\t\t\t\t\t}\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, ret, handleObj, matched, j,\n\t\t\thandlerQueue = [],\n\t\t\targs = core_slice.call( arguments ),\n\t\t\thandlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar sel, handleObj, matches, i,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur != this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Fix target property (#1925)\n\t\tif ( !event.target ) {\n\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t}\n\n\t\t// Support: Chrome 23+, Safari?\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\t\tevent.metaKey = !!event.metaKey;\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar body, eventDoc, doc,\n\t\t\t\tbutton = original.button,\n\t\t\t\tfromElement = original.fromElement;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add relatedTarget, if necessary\n\t\t\tif ( !event.relatedTarget && fromElement ) {\n\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== document.activeElement && this.focus ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\t\t\t\t\t\t// let .trigger() run the handlers\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === document.activeElement && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Even when returnValue equals to undefined Firefox will still show alert\n\t\t\t\tif ( event.result !== undefined ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{ type: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = document.removeEventListener ?\n\tfunction( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t} :\n\tfunction( elem, type, handle ) {\n\t\tvar name = \"on\" + type;\n\n\t\tif ( elem.detachEvent ) {\n\n\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\t\t\tif ( typeof elem[ name ] === core_strundefined ) {\n\t\t\t\telem[ name ] = null;\n\t\t\t}\n\n\t\t\telem.detachEvent( name, handle );\n\t\t}\n\t};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If preventDefault exists, run it on the original event\n\t\tif ( e.preventDefault ) {\n\t\t\te.preventDefault();\n\n\t\t// Support: IE\n\t\t// Otherwise set the returnValue property of the original event to false\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\t\t// If stopPropagation exists, run it on the original event\n\t\tif ( e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\n\t\t// Support: IE\n\t\t// Set the cancelBubble property of the original event to true\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// IE submit delegation\nif ( !jQuery.support.submitBubbles ) {\n\n\tjQuery.event.special.submit = {\n\t\tsetup: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\tvar elem = e.target,\n\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n\t\t\t\tif ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\t\t\t\t\t\tevent._submit_bubble = true;\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( form, \"submitBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t\t// return undefined since we don't need an event listener\n\t\t},\n\n\t\tpostDispatch: function( event ) {\n\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\tif ( event._submit_bubble ) {\n\t\t\t\tdelete event._submit_bubble;\n\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\tjQuery.event.remove( this, \"._submit\" );\n\t\t}\n\t};\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !jQuery.support.changeBubbles ) {\n\n\tjQuery.event.special.change = {\n\n\t\tsetup: function() {\n\n\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\t\t\t\t\t\t\tthis._just_changed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n\t\t\t\t\t\t\tthis._just_changed = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\t\t\t\tvar elem = e.target;\n\n\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( elem, \"changeBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thandle: function( event ) {\n\t\t\tvar elem = event.target;\n\n\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tjQuery.event.remove( this, \"._change\" );\n\n\t\t\treturn !rformElems.test( this.nodeName );\n\t\t}\n\t};\n}\n\n// Create \"bubbling\" focus and blur events\nif ( !jQuery.support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\n\t\tvar attaches = 0,\n\t\t\thandler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tif ( attaches++ === 0 ) {\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tif ( --attaches === 0 ) {\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar type, origFn;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n/*!\n * Sizzle CSS Selector Engine\n * Copyright 2012 jQuery Foundation and other contributors\n * Released under the MIT license\n * http://sizzlejs.com/\n */\n(function( window, undefined ) {\n\nvar i,\n\tcachedruns,\n\tExpr,\n\tgetText,\n\tisXML,\n\tcompile,\n\thasDuplicate,\n\toutermostContext,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsXML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\tsortOrder,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tsupport = {},\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Array methods\n\tarr = [],\n\tpop = arr.pop,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\toperators = \"([*^$|!~]?=)\",\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\t\t\"*(?:\" + operators + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\t// Prefer arguments quoted,\n\t//   then not containing pseudos/brackets,\n\t//   then attribute selectors/non-parenthetical expressions,\n\t//   then anything else\n\t// These preferences are here to reduce the number of selectors\n\t//   needing tokenize in the PSEUDO preFilter\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([\\\\x20\\\\t\\\\r\\\\n\\\\f>+~])\" + whitespace + \"*\" ),\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"NAME\": new RegExp( \"^\\\\[name=['\\\"]?(\" + characterEncoding + \")['\\\"]?\\\\]\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trsibling = /[\\x20\\t\\r\\n\\f]*[+~]/,\n\n\trnative = /^[^{]+\\{\\s*\\[native code/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trescape = /'|\\\\/g,\n\trattributeQuotes = /\\=[\\x20\\t\\r\\n\\f]*([^'\"\\]]*)[\\x20\\t\\r\\n\\f]*\\]/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n\tfunescape = function( _, escaped ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\treturn high !== high ?\n\t\t\tescaped :\n\t\t\t// BMP codepoint\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Use a stripped-down slice if we can't use a native one\ntry {\n\tslice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;\n} catch ( e ) {\n\tslice = function( i ) {\n\t\tvar elem,\n\t\t\tresults = [];\n\t\twhile ( (elem = this[i++]) ) {\n\t\t\tresults.push( elem );\n\t\t}\n\t\treturn results;\n\t};\n}\n\n/**\n * For feature detection\n * @param {Function} fn The function to test for native support\n */\nfunction isNative( fn ) {\n\treturn rnative.test( fn + \"\" );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar cache,\n\t\tkeys = [];\n\n\treturn (cache = function( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key ] = value);\n\t});\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( !documentIsXML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, slice.call(context.getElementsByClassName( m ), 0) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && !rbuggyQSA.test(selector) ) {\n\t\t\told = true;\n\t\t\tnid = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results, slice.call( newContext.querySelectorAll(\n\t\t\t\t\t\tnewSelector\n\t\t\t\t\t), 0 ) );\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Detect xml\n * @param {Element|Object} elem An element or a document\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar doc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsXML = isXML( doc );\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.tagNameNoComments = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if attributes should be retrieved by attribute nodes\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.innerHTML = \"<select></select>\";\n\t\tvar type = typeof div.lastChild.getAttribute(\"multiple\");\n\t\t// IE8 returns a string for some attributes even when not present\n\t\treturn type !== \"boolean\" && type !== \"string\";\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getByClassName = assert(function( div ) {\n\t\t// Opera can't find a second classname (in 9.6)\n\t\tdiv.innerHTML = \"<div class='hidden e'></div><div class='hidden'></div>\";\n\t\tif ( !div.getElementsByClassName || !div.getElementsByClassName(\"e\").length ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Safari 3.2 caches class attributes and doesn't catch changes\n\t\tdiv.lastChild.className = \"e\";\n\t\treturn div.getElementsByClassName(\"e\").length === 2;\n\t});\n\n\t// Check if getElementById returns elements by name\n\t// Check if getElementsByName privileges form controls or returns elements by ID\n\tsupport.getByName = assert(function( div ) {\n\t\t// Inject content\n\t\tdiv.id = expando + 0;\n\t\tdiv.innerHTML = \"<a name='\" + expando + \"'></a><div name='\" + expando + \"'></div>\";\n\t\tdocElem.insertBefore( div, docElem.firstChild );\n\n\t\t// Test\n\t\tvar pass = doc.getElementsByName &&\n\t\t\t// buggy browsers will return fewer than the correct 2\n\t\t\tdoc.getElementsByName( expando ).length === 2 +\n\t\t\t// buggy browsers will return more than the correct 0\n\t\t\tdoc.getElementsByName( expando + 0 ).length;\n\t\tsupport.getIdNotName = !doc.getElementById( expando );\n\n\t\t// Cleanup\n\t\tdocElem.removeChild( div );\n\n\t\treturn pass;\n\t});\n\n\t// IE6/7 return modified attributes\n\tExpr.attrHandle = assert(function( div ) {\n\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\treturn div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&\n\t\t\tdiv.firstChild.getAttribute(\"href\") === \"#\";\n\t}) ?\n\t\t{} :\n\t\t{\n\t\t\t\"href\": function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"href\", 2 );\n\t\t\t},\n\t\t\t\"type\": function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"type\");\n\t\t\t}\n\t\t};\n\n\t// ID find and filter\n\tif ( support.getIdNotName ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && !documentIsXML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && !documentIsXML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\n\t\t\t\treturn m ?\n\t\t\t\t\tm.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode(\"id\").value === id ?\n\t\t\t\t\t\t[m] :\n\t\t\t\t\t\tundefined :\n\t\t\t\t\t[];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.tagNameNoComments ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Name\n\tExpr.find[\"NAME\"] = support.getByName && function( tag, context ) {\n\t\tif ( typeof context.getElementsByName !== strundefined ) {\n\t\t\treturn context.getElementsByName( name );\n\t\t}\n\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && !documentIsXML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21),\n\t// no need to also add to buggyMatches since matches checks buggyQSA\n\t// A support test would require too much code (would include document ready)\n\trbuggyQSA = [ \":focus\" ];\n\n\tif ( (support.qsa = isNative(doc.querySelectorAll)) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explictly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\n\n\t\t\t// IE8 - Some boolean attributes are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:checked|disabled|ismap|multiple|readonly|selected|value)\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\n\t\t\t// Opera 10-12/IE8 - ^= $= *= and empty values\n\t\t\t// Should not select anything\n\t\t\tdiv.innerHTML = \"<input type='hidden' i=''/>\";\n\t\t\tif ( div.querySelectorAll(\"[i^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:\\\"\\\"|'')\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = new RegExp( rbuggyMatches.join(\"|\") );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = isNative(docElem.contains) || docElem.compareDocumentPosition ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t// Document order sorting\n\tsortOrder = docElem.compareDocumentPosition ?\n\tfunction( a, b ) {\n\t\tvar compare;\n\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ( (compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b )) ) {\n\t\t\tif ( compare & 1 || a.parentNode && a.parentNode.nodeType === 11 ) {\n\t\t\t\tif ( a === doc || contains( preferredDoc, a ) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || contains( preferredDoc, b ) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t}\n\n\t\treturn a.compareDocumentPosition ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\t} else if ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\t// Always assume the presence of duplicates if sort doesn't\n\t// pass them to our comparison function (as in Google Chrome).\n\thasDuplicate = false;\n\t[0, 0].sort( sortOrder );\n\tsupport.detectDuplicates = hasDuplicate;\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\t// rbuggyQSA always contains :focus, so no need for an existence check\n\tif ( support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr) ) {\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\tvar val;\n\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tif ( !documentIsXML ) {\n\t\tname = name.toLowerCase();\n\t}\n\tif ( (val = Expr.attrHandle[ name ]) ) {\n\t\treturn val( elem );\n\t}\n\tif ( documentIsXML || support.attributes ) {\n\t\treturn elem.getAttribute( name );\n\t}\n\treturn ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) && elem[ name ] === true ?\n\t\tname :\n\t\tval && val.specified ? val.value : null;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n// Document sorting and removing duplicates\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\ti = 1,\n\t\tj = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\tfor ( ; (elem = results[i]); i++ ) {\n\t\t\tif ( elem === results[ i - 1 ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\treturn results;\n};\n\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n// Returns a function to use in pseudos for input types\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n// Returns a function to use in pseudos for buttons\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n// Returns a function to use in pseudos for positionals\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\tfor ( ; (node = elem[i]); i++ ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (see #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[5] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[4] ) {\n\t\t\t\tmatch[2] = match[4];\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeName ) {\n\t\t\tif ( nodeName === \"*\" ) {\n\t\t\t\treturn function() { return true; };\n\t\t\t}\n\n\t\t\tnodeName = nodeName.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\")) || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifider\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsXML ?\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\") :\n\t\t\t\t\t\telem.lang) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n\t\t\t//   not comment, processing instructions, or others\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n\t\t\t// use getAttribute instead to test this case\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( tokens = [] );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar data, cache, outerCache,\n\t\t\t\tdirkey = dirruns + \" \" + doneName;\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\n\t\t\t\t\t\t\t\treturn data === true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\n\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\n\t\t\t\t\t\t\tif ( cache[1] === true ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t// A counter to specify which element is currently being matched\n\tvar matcherCachedRuns = 0,\n\t\tbySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tsetMatched = [],\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\toutermost = expandContext != null,\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\tcachedruns = matcherCachedRuns;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !group ) {\n\t\t\tgroup = tokenize( selector );\n\t\t}\n\t\ti = group.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( group[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t}\n\treturn cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tmatch = tokenize( selector );\n\n\tif ( !seed ) {\n\t\t// Try to minimize operations if there is only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tcontext.nodeType === 9 && !documentIsXML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = Expr.find[\"ID\"]( token.matches[0].replace( runescape, funescape ), context )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, slice.call( seed, 0 ) );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\tcompile( selector, match )(\n\t\tseed,\n\t\tcontext,\n\t\tdocumentIsXML,\n\t\tresults,\n\t\trsibling.test( selector )\n\t);\n\treturn results;\n}\n\n// Deprecated\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nExpr.filters = setFilters.prototype = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\n// Initialize with the default document\nsetDocument();\n\n// Override sizzle attribute retrieval\nSizzle.attr = jQuery.attr;\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n})( window );\nvar runtil = /Until$/,\n\trparentsprev = /^(?:parents|prev(?:Until|All))/,\n\tisSimple = /^.[^:#\\[\\.,]*$/,\n\trneedsContext = jQuery.expr.match.needsContext,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i, ret, self,\n\t\t\tlen = this.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\tself = this;\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tret = [];\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, this[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = ( this.selector ? this.selector + \" \" : \"\" ) + selector;\n\t\treturn ret;\n\t},\n\n\thas: function( target ) {\n\t\tvar i,\n\t\t\ttargets = jQuery( target, this ),\n\t\t\tlen = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, false) );\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, true) );\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!selector && (\n\t\t\ttypeof selector === \"string\" ?\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\trneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector, this.context ).index( this[0] ) >= 0 :\n\t\t\t\t\tjQuery.filter( selector, this ).length > 0 :\n\t\t\t\tthis.filter( selector ).length > 0 );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tret = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tcur = this[i];\n\n\t\t\twhile ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {\n\t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {\n\t\t\t\t\tret.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this );\n\t},\n\n\tadd: function( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context ) :\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( jQuery.unique(all) );\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\nfunction sibling( cur, dir ) {\n\tdo {\n\t\tcur = cur[ dir ];\n\t} while ( cur && cur.nodeType !== 1 );\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\tjQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;\n\n\t\tif ( this.length > 1 && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\njQuery.extend({\n\tfilter: function( expr, elems, not ) {\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 ?\n\t\t\tjQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :\n\t\t\tjQuery.find.matches(expr, elems);\n\t},\n\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\tcur = elem[ dir ];\n\n\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\tmatched.push( cur );\n\t\t\t}\n\t\t\tcur = cur[dir];\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar r = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tr.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, keep ) {\n\n\t// Can't pass null or undefined to indexOf in Firefox 4\n\t// Set to 0 to skip string check\n\tqualifier = qualifier || 0;\n\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep(elements, function( elem, i ) {\n\t\t\tvar retVal = !!qualifier.call( elem, i, elem );\n\t\t\treturn retVal === keep;\n\t\t});\n\n\t} else if ( qualifier.nodeType ) {\n\t\treturn jQuery.grep(elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) === keep;\n\t\t});\n\n\t} else if ( typeof qualifier === \"string\" ) {\n\t\tvar filtered = jQuery.grep(elements, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t});\n\n\t\tif ( isSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter(qualifier, filtered, !keep);\n\t\t} else {\n\t\t\tqualifier = jQuery.filter( qualifier, filtered );\n\t\t}\n\t}\n\n\treturn jQuery.grep(elements, function( elem ) {\n\t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;\n\t});\n}\nfunction createSafeFragment( document ) {\n\tvar list = nodeNames.split( \"|\" ),\n\t\tsafeFrag = document.createDocumentFragment();\n\n\tif ( safeFrag.createElement ) {\n\t\twhile ( list.length ) {\n\t\t\tsafeFrag.createElement(\n\t\t\t\tlist.pop()\n\t\t\t);\n\t\t}\n\t}\n\treturn safeFrag;\n}\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n\t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\trinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\trleadingWhitespace = /^\\s+/,\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trtbody = /<tbody/i,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\t\tparam: [ 1, \"<object>\", \"</object>\" ],\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\t\t_default: jQuery.support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n\t},\n\tsafeFragment = createSafeFragment( document ),\n\tfragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\twrapAll: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\tif ( this[0].parentNode ) {\n\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function(i) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tthis.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tthis.insertBefore( elem, this.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, false, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, false, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\t// keepData is for internal use only--do not document\n\tremove: function( selector, keepData ) {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( !selector || jQuery.filter( selector, [ elem ] ).length > 0 ) {\n\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t\t}\n\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\n\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t// Support: IE<9\n\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\telem.options.length = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function () {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar elem = this[0] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [\"\", \"\"] )[1].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (; i < l; i++ ) {\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\telem = this[i] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function( value ) {\n\t\tvar isFunc = jQuery.isFunction( value );\n\n\t\t// Make sure that the elements are removed from the DOM before they are inserted\n\t\t// this can help fix replacing a parent with child elements\n\t\tif ( !isFunc && typeof value !== \"string\" ) {\n\t\t\tvalue = jQuery( value ).not( this ).detach();\n\t\t}\n\n\t\treturn this.domManip( [ value ], true, function( elem ) {\n\t\t\tvar next = this.nextSibling,\n\t\t\t\tparent = this.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tjQuery( this ).remove();\n\t\t\t\tparent.insertBefore( elem, next );\n\t\t\t}\n\t\t});\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, table, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = core_concat.apply( [], args );\n\n\t\tvar first, node, hasScripts,\n\t\t\tscripts, doc, fragment,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[0],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[0] = value.call( this, index, table ? self.html() : undefined );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, table, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\ttable = table && jQuery.nodeName( first, \"tr\" );\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call(\n\t\t\t\t\t\ttable && jQuery.nodeName( this[i], \"table\" ) ?\n\t\t\t\t\t\t\tfindOrAppend( this[i], \"tbody\" ) :\n\t\t\t\t\t\t\tthis[i],\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\ti\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Hope ajax is available...\n\t\t\t\t\t\t\t\tjQuery.ajax({\n\t\t\t\t\t\t\t\t\turl: node.src,\n\t\t\t\t\t\t\t\t\ttype: \"GET\",\n\t\t\t\t\t\t\t\t\tdataType: \"script\",\n\t\t\t\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\t\t\t\tglobal: false,\n\t\t\t\t\t\t\t\t\t\"throws\": true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\t\tfragment = first = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\nfunction findOrAppend( elem, tag ) {\n\treturn elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\tvar attr = elem.getAttributeNode(\"type\");\n\telem.type = ( attr && attr.specified ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\tif ( match ) {\n\t\telem.type = match[1];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar elem,\n\t\ti = 0;\n\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\tjQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\treturn;\n\t}\n\n\tvar type, i, l,\n\t\toldData = jQuery._data( src ),\n\t\tcurData = jQuery._data( dest, oldData ),\n\t\tevents = oldData.events;\n\n\tif ( events ) {\n\t\tdelete curData.handle;\n\t\tcurData.events = {};\n\n\t\tfor ( type in events ) {\n\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// make the cloned public data object a copy from the original\n\tif ( curData.data ) {\n\t\tcurData.data = jQuery.extend( {}, curData.data );\n\t}\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n\tvar nodeName, e, data;\n\n\t// We do not need to do anything for non-Elements\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\tnodeName = dest.nodeName.toLowerCase();\n\n\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\tif ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {\n\t\tdata = jQuery._data( dest );\n\n\t\tfor ( e in data.events ) {\n\t\t\tjQuery.removeEvent( dest, e, data.handle );\n\t\t}\n\n\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\t\tdest.removeAttribute( jQuery.expando );\n\t}\n\n\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\tif ( nodeName === \"script\" && dest.text !== src.text ) {\n\t\tdisableScript( dest ).text = src.text;\n\t\trestoreScript( dest );\n\n\t// IE6-10 improperly clones children of object elements using classid.\n\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t} else if ( nodeName === \"object\" ) {\n\t\tif ( dest.parentNode ) {\n\t\t\tdest.outerHTML = src.outerHTML;\n\t\t}\n\n\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t// If the src has innerHTML and the destination does not,\n\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\tif ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n\t\t\tdest.innerHTML = src.innerHTML;\n\t\t}\n\n\t} else if ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\n\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\tif ( dest.value !== src.value ) {\n\t\t\tdest.value = src.value;\n\t\t}\n\n\t// IE6-8 fails to return the selected option to the default selected\n\t// state when cloning options\n\t} else if ( nodeName === \"option\" ) {\n\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\n\t// IE6-8 fails to set the defaultValue to the correct value when\n\t// cloning other types of input fields\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\ti = 0,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone(true);\n\t\t\tjQuery( insert[i] )[ original ]( elems );\n\n\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\t\t\tcore_push.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\nfunction getAll( context, tag ) {\n\tvar elems, elem,\n\t\ti = 0,\n\t\tfound = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\ttypeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\tundefined;\n\n\tif ( !found ) {\n\t\tfor ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !tag || jQuery.nodeName( elem, tag ) ) {\n\t\t\t\tfound.push( elem );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( found, getAll( elem, tag ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], found ) :\n\t\tfound;\n}\n\n// Used in buildFragment, fixes the defaultChecked property\nfunction fixDefaultChecked( elem ) {\n\tif ( manipulation_rcheckableType.test( elem.type ) ) {\n\t\telem.defaultChecked = elem.checked;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar destElements, node, clone, i, srcElements,\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\tif ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\t\t\tclone = elem.cloneNode( true );\n\n\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t} else {\n\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\t\t}\n\n\t\tif ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\t// Fix all IE cloning issues\n\t\t\tfor ( i = 0; (node = srcElements[i]) != null; ++i ) {\n\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\tif ( destElements[i] ) {\n\t\t\t\t\tfixCloneNodeIssues( node, destElements[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0; (node = srcElements[i]) != null; i++ ) {\n\t\t\t\t\tcloneCopyEvent( node, destElements[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\tdestElements = srcElements = node = null;\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar j, elem, contains,\n\t\t\ttmp, tag, tbody, wrap,\n\t\t\tl = elems.length,\n\n\t\t\t// Ensure a safe fragment\n\t\t\tsafe = createSafeFragment( context ),\n\n\t\t\tnodes = [],\n\t\t\ti = 0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[1].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\n\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[0];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Manually add leading whitespace removed by IE\n\t\t\t\t\tif ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\t\tnodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\t\tif ( !jQuery.support.tbody ) {\n\n\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\t\telem = tag === \"table\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\ttmp.firstChild :\n\n\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\twrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\t\ttmp :\n\t\t\t\t\t\t\t\t0;\n\n\t\t\t\t\t\tj = elem && elem.childNodes.length;\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\tif ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n\t\t\t\t\t\t\t\telem.removeChild( tbody );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\t\t\t\t\ttmp.textContent = \"\";\n\n\t\t\t\t\t// Fix #12392 for oldIE\n\t\t\t\t\twhile ( tmp.firstChild ) {\n\t\t\t\t\t\ttmp.removeChild( tmp.firstChild );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remember the top-level container for proper cleanup\n\t\t\t\t\ttmp = safe.lastChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fix #11356: Clear elements from fragment\n\t\tif ( tmp ) {\n\t\t\tsafe.removeChild( tmp );\n\t\t}\n\n\t\t// Reset defaultChecked for any radios and checkboxes\n\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\t\tif ( !jQuery.support.appendChecked ) {\n\t\t\tjQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n\t\t}\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( safe.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttmp = null;\n\n\t\treturn safe;\n\t},\n\n\tcleanData: function( elems, /* internal */ acceptData ) {\n\t\tvar elem, type, id, data,\n\t\t\ti = 0,\n\t\t\tinternalKey = jQuery.expando,\n\t\t\tcache = jQuery.cache,\n\t\t\tdeleteExpando = jQuery.support.deleteExpando,\n\t\t\tspecial = jQuery.event.special;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\n\t\t\tif ( acceptData || jQuery.acceptData( elem ) ) {\n\n\t\t\t\tid = elem[ internalKey ];\n\t\t\t\tdata = id && cache[ id ];\n\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\tif ( cache[ id ] ) {\n\n\t\t\t\t\t\tdelete cache[ id ];\n\n\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t\t\t\t// we must handle all of these cases\n\t\t\t\t\t\tif ( deleteExpando ) {\n\t\t\t\t\t\t\tdelete elem[ internalKey ];\n\n\t\t\t\t\t\t} else if ( typeof elem.removeAttribute !== core_strundefined ) {\n\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[ internalKey ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcore_deletedIds.push( id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\nvar iframe, getStyles, curCSS,\n\tralpha = /alpha\\([^)]*\\)/i,\n\tropacity = /opacity\\s*=\\s*([^)]*)/,\n\trposition = /^(top|right|bottom|left)$/,\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trmargin = /^margin/,\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\n\telemdisplay = { BODY: \"block\" },\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction isHidden( elem, el ) {\n\t// isHidden might be called from jQuery#filter function;\n\t// in that case, element will be second argument\n\telem = el || elem;\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( !values[ index ] ) {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tjQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn jQuery.access( this, function( elem, name, value ) {\n\t\t\tvar len, styles,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tvar bool = typeof state === \"boolean\";\n\n\t\treturn this.each(function() {\n\t\t\tif ( bool ? state : isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Exclude the following css properties to add px\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n\t\t\t\t// Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n\t\t\t\t// Fixes bug #5509\n\t\t\t\ttry {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar num, val, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t},\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\tswap: function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.apply( elem, args || [] );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\n// NOTE: we've included the \"window\" in window.getComputedStyle\n// because jsdom on node.js will break without it.\nif ( window.getComputedStyle ) {\n\tgetStyles = function( elem ) {\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\tcurCSS = function( elem, name, _computed ) {\n\t\tvar width, minWidth, maxWidth,\n\t\t\tcomputed = _computed || getStyles( elem ),\n\n\t\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n\t\t\tstyle = elem.style;\n\n\t\tif ( computed ) {\n\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n} else if ( document.documentElement.currentStyle ) {\n\tgetStyles = function( elem ) {\n\t\treturn elem.currentStyle;\n\t};\n\n\tcurCSS = function( elem, name, _computed ) {\n\t\tvar left, rs, rsLeft,\n\t\t\tcomputed = _computed || getStyles( elem ),\n\t\t\tret = computed ? computed[ name ] : undefined,\n\t\t\tstyle = elem.style;\n\n\t\t// Avoid setting ret to empty string here\n\t\t// so we don't default to auto\n\t\tif ( ret == null && style && style[ name ] ) {\n\t\t\tret = style[ name ];\n\t\t}\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t// but not position css attributes, as those are proportional to the parent element instead\n\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\tleft = style.left;\n\t\t\trs = elem.runtimeStyle;\n\t\t\trsLeft = rs && rs.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = elem.currentStyle.left;\n\t\t\t}\n\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\treturn ret === \"\" ? \"auto\" : ret;\n\t};\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\n// Try to determine the default display value of an element\nfunction css_defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe ||\n\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\n\t\t\t\t.css( \"cssText\", \"display:block !important\" )\n\t\t\t).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n\t\t\tdoc.write(\"<!doctype html><html><body>\");\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\n\n// Called ONLY from within css_defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\t\tdisplay = jQuery.css( elem[0], \"display\" );\n\telem.remove();\n\treturn display;\n}\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\nif ( !jQuery.support.opacity ) {\n\tjQuery.cssHooks.opacity = {\n\t\tget: function( elem, computed ) {\n\t\t\t// IE uses filters for opacity\n\t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tvar style = elem.style,\n\t\t\t\tcurrentStyle = elem.currentStyle,\n\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t// Force it by setting the zoom level\n\t\t\tstyle.zoom = 1;\n\n\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\t\t\t// if value === \"\", then remove inline opacity #12685\n\t\t\tif ( ( value >= 1 || value === \"\" ) &&\n\t\t\t\t\tjQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\t\t\t\t\tstyle.removeAttribute ) {\n\n\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\tstyle.removeAttribute( \"filter\" );\n\n\t\t\t\t// if there is no filter style applied in a css rule or unset inline opacity, we are done\n\t\t\t\tif ( value === \"\" || currentStyle && !currentStyle.filter ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise, set new filter values\n\t\t\tstyle.filter = ralpha.test( filter ) ?\n\t\t\t\tfilter.replace( ralpha, opacity ) :\n\t\t\t\tfilter + \" \" + opacity;\n\t\t}\n\t};\n}\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\njQuery(function() {\n\tif ( !jQuery.support.reliableMarginRight ) {\n\t\tjQuery.cssHooks.marginRight = {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\t\tjQuery.cssHooks[ prop ] = {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\t\tcomputed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n\t\t\t(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n}\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\tvar type = this.type;\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ){\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ){\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.hover = function( fnOver, fnOut ) {\n\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n};\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\tajax_nonce = jQuery.now(),\n\n\tajax_rquery = /\\?/,\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t// Keep a copy of the old load method\n\t_load = jQuery.fn.load,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar deep, key,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, response, type,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off, url.length );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\n\tjQuery.fn[ type ] = function( fn ){\n\t\treturn this.on( type, fn );\n\t};\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": window.String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar // Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers as string\n\t\t\tresponseHeadersString,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\ttransport,\n\t\t\t// Response headers\n\t\t\tresponseHeaders,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? 80 : 443 ) ) !=\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? 80 : 443 ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( status >= 200 && status < 300 || status === 304 ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 ) {\n\t\t\t\t\tisSuccess = true;\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tisSuccess = true;\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tisSuccess = ajaxConvert( s, response );\n\t\t\t\t\tstatusText = isSuccess.state;\n\t\t\t\t\tsuccess = isSuccess.data;\n\t\t\t\t\terror = isSuccess.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t}\n});\n\n/* Handles responses to an ajax request:\n * - sets all responseXXX fields accordingly\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\tvar firstDataType, ct, finalDataType, type,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes,\n\t\tresponseFields = s.responseFields;\n\n\t// Fill responseXXX fields\n\tfor ( type in responseFields ) {\n\t\tif ( type in responses ) {\n\t\t\tjqXHR[ responseFields[type] ] = responses[ type ];\n\t\t}\n\t}\n\n\t// Remove auto dataType and get content-type in the process\n\twhile( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n// Chain conversions given the request and the original response\nfunction ajaxConvert( s, response ) {\n\tvar conv2, current, conv, tmp,\n\t\tconverters = {},\n\t\ti = 0,\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice(),\n\t\tprev = dataTypes[ 0 ];\n\n\t// Apply the dataFilter if provided\n\tif ( s.dataFilter ) {\n\t\tresponse = s.dataFilter( response, s.dataType );\n\t}\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\t// Convert to each sequential dataType, tolerating list modification\n\tfor ( ; (current = dataTypes[++i]); ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\tif ( current !== \"*\" ) {\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\tif ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split(\" \");\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.splice( i--, 0, current );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[\"throws\"] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update prev for next iteration\n\t\t\tprev = current;\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t\ts.global = false;\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\n\t\tvar script,\n\t\t\thead = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n\t\treturn {\n\n\t\t\tsend: function( _, callback ) {\n\n\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\t\tscript.async = true;\n\n\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t}\n\n\t\t\t\tscript.src = s.url;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\tif ( script.parentNode ) {\n\t\t\t\t\t\t\tscript.parentNode.removeChild( script );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\tscript = null;\n\n\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( script ) {\n\t\t\t\t\tscript.onload( undefined, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\nvar xhrCallbacks, xhrSupported,\n\txhrId = 0,\n\t// #5280: Internet Explorer will keep connections alive if we don't abort on unload\n\txhrOnUnloadAbort = window.ActiveXObject && function() {\n\t\t// Abort all pending requests\n\t\tvar key;\n\t\tfor ( key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]( undefined, true );\n\t\t}\n\t};\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch( e ) {}\n}\n\nfunction createActiveXHR() {\n\ttry {\n\t\treturn new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n\t} catch( e ) {}\n}\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject ?\n\t/* Microsoft failed to properly\n\t * implement the XMLHttpRequest in IE7 (can't request local files),\n\t * so we use the ActiveXObject when it is available\n\t * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n\t * we need a fallback.\n\t */\n\tfunction() {\n\t\treturn !this.isLocal && createStandardXHR() || createActiveXHR();\n\t} :\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\n// Determine support properties\nxhrSupported = jQuery.ajaxSettings.xhr();\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nxhrSupported = jQuery.support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n\tjQuery.ajaxTransport(function( s ) {\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( !s.crossDomain || jQuery.support.cors ) {\n\n\t\t\tvar callback;\n\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\n\t\t\t\t\t// Get a new xhr\n\t\t\t\t\tvar handle, i,\n\t\t\t\t\t\txhr = s.xhr();\n\n\t\t\t\t\t// Open the socket\n\t\t\t\t\t// Passing null username, generates a login popup on Opera (#2865)\n\t\t\t\t\tif ( s.username ) {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async, s.username, s.password );\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( s.xhrFields ) {\n\t\t\t\t\t\tfor ( i in s.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = s.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( s.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( s.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !s.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch( err ) {}\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\txhr.send( ( s.hasContent && s.data ) || null );\n\n\t\t\t\t\t// Listener\n\t\t\t\t\tcallback = function( _, isAbort ) {\n\t\t\t\t\t\tvar status, responseHeaders, statusText, responses;\n\n\t\t\t\t\t\t// Firefox throws exceptions when accessing properties\n\t\t\t\t\t\t// of an xhr when a network error occurred\n\t\t\t\t\t\t// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n\t\t\t\t\t\t\t\t// Only called once\n\t\t\t\t\t\t\t\tcallback = undefined;\n\n\t\t\t\t\t\t\t\t// Do not keep as active anymore\n\t\t\t\t\t\t\t\tif ( handle ) {\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\t\t\t\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\t\t\t\t\t\t\t\t\t\tdelete xhrCallbacks[ handle ];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// If it's an abort\n\t\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\t\t// Abort it manually if needed\n\t\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\t\tstatus = xhr.status;\n\t\t\t\t\t\t\t\t\tresponseHeaders = xhr.getAllResponseHeaders();\n\n\t\t\t\t\t\t\t\t\t// When requesting binary data, IE6-9 will throw an exception\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText (#11426)\n\t\t\t\t\t\t\t\t\tif ( typeof xhr.responseText === \"string\" ) {\n\t\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t\t} catch( e ) {\n\t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\t\tif ( !status && s.isLocal && !s.crossDomain ) {\n\t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch( firefoxAccessException ) {\n\t\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\t\tcomplete( -1, firefoxAccessException );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\tcomplete( status, statusText, responses, responseHeaders );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( !s.async ) {\n\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\tsetTimeout( callback );\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandle = ++xhrId;\n\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\t\t\t\t\t\t\t// Create the active xhrs callbacks list if needed\n\t\t\t\t\t\t\t// and attach the unload handler\n\t\t\t\t\t\t\tif ( !xhrCallbacks ) {\n\t\t\t\t\t\t\t\txhrCallbacks = {};\n\t\t\t\t\t\t\t\tjQuery( window ).unload( xhrOnUnloadAbort );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Add to list of active xhrs callbacks\n\t\t\t\t\t\t\txhrCallbacks[ handle ] = callback;\n\t\t\t\t\t\t}\n\t\t\t\t\t\txhr.onreadystatechange = callback;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback( undefined, true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n}\nvar fxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [function( prop, value ) {\n\t\t\tvar end, unit,\n\t\t\t\ttween = this.createTween( prop, value ),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tstart = +target || 0,\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( parts ) {\n\t\t\t\tend = +parts[2];\n\t\t\t\tunit = parts[3] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\n\t\t\t\t// We need to compute starting value\n\t\t\t\tif ( unit !== \"px\" && start ) {\n\t\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\t\t// Prefer the current property, because this process will be trivial if it uses the same units\n\t\t\t\t\t// Fallback to end or a simple constant\n\t\t\t\t\tstart = jQuery.css( tween.elem, prop, true ) || end || 1;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t\t// Adjust and apply\n\t\t\t\t\t\tstart = start / scale;\n\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t\t}\n\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = start;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;\n\t\t\t}\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\nfunction createTweens( animation, props ) {\n\tjQuery.each( props, function( prop, value ) {\n\t\tvar collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( collection[ index ].call( animation, prop, value ) ) {\n\n\t\t\t\t// we're done with this property\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcreateTweens( animation, props );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar value, name, index, easing, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/*jshint validthis:true */\n\tvar prop, index, length,\n\t\tvalue, dataShow, toggle,\n\t\ttween, hooks, oldfire,\n\t\tanim = this,\n\t\tstyle = elem.style,\n\t\torig = {},\n\t\thandled = [],\n\t\thidden = elem.nodeType && isHidden( elem );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE does not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t// inline-level elements accept inline-block;\n\t\t\t// block-level elements need to be inline with layout\n\t\t\tif ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\n\t\t\t} else {\n\t\t\t\tstyle.zoom = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tif ( !jQuery.support.shrinkWrapBlocks ) {\n\t\t\tanim.always(function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t});\n\t\t}\n\t}\n\n\n\t// show/hide pass\n\tfor ( index in props ) {\n\t\tvalue = props[ index ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ index ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thandled.push( index );\n\t\t}\n\t}\n\n\tlength = handled.length;\n\tif ( length ) {\n\t\tdataShow = jQuery._data( elem, \"fxshow\" ) || jQuery._data( elem, \"fxshow\", {} );\n\t\tif ( \"hidden\" in dataShow ) {\n\t\t\thidden = dataShow.hidden;\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\t\t\tjQuery._removeData( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( index = 0 ; index < length ; index++ ) {\n\t\t\tprop = handled[ index ];\n\t\t\ttween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );\n\t\t\torig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Remove in 2.0 - this supports IE8's panic based approach\n// to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\t\t\t\tdoAnimation.finish = function() {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t};\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || jQuery._data( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = jQuery._data( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = jQuery._data( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.cur && hooks.cur.finish ) {\n\t\t\t\thooks.cur.finish.call( this );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth? 1 : 0;\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\n\t}\n};\n\njQuery.timers = [];\njQuery.fx = Tween.prototype.init;\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tif ( timer() && jQuery.timers.push( timer ) ) {\n\t\tjQuery.fx.start();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n}\njQuery.fn.offset = function( options ) {\n\tif ( arguments.length ) {\n\t\treturn options === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t}\n\n\tvar docElem, win,\n\t\tbox = { top: 0, left: 0 },\n\t\telem = this[ 0 ],\n\t\tdoc = elem && elem.ownerDocument;\n\n\tif ( !doc ) {\n\t\treturn;\n\t}\n\n\tdocElem = doc.documentElement;\n\n\t// Make sure it's not a disconnected DOM node\n\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\treturn box;\n\t}\n\n\t// If we don't have gBCR, just use 0,0 rather than error\n\t// BlackBerry 5, iOS 3 (original iPhone)\n\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n\t\tbox = elem.getBoundingClientRect();\n\t}\n\twin = getWindow( doc );\n\treturn {\n\t\ttop: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n\t\tleft: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n\t};\n};\n\njQuery.offset = {\n\n\tsetOffset: function( elem, options, i ) {\n\t\tvar position = jQuery.css( elem, \"position\" );\n\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tvar curElem = jQuery( elem ),\n\t\t\tcurOffset = curElem.offset(),\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" ),\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" ),\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n\t\t\tprops = {}, curPosition = {}, curTop, curLeft;\n\n\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\n\njQuery.fn.extend({\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\tparentOffset = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ];\n\n\t\t// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || document.documentElement;\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent || document.documentElement;\n\t\t});\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n\tvar top = /Y/.test( prop );\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn jQuery.access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? (prop in win) ? win[ prop ] :\n\t\t\t\t\twin.document.documentElement[ method ] :\n\t\t\t\t\telem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\t\t\t\t\ttop ? val : jQuery( win ).scrollTop()\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ?\n\t\telem :\n\t\telem.nodeType === 9 ?\n\t\t\telem.defaultView || elem.parentWindow :\n\t\t\tfalse;\n}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n// Limit scope pollution from any deprecated API\n// (function() {\n\n// })();\n\n// Expose for component\nmodule.exports = jQuery;\n\n// Expose jQuery to the global object\n//window.jQuery = window.$ = jQuery;\n\n// Expose jQuery as an AMD module, but only for AMD loaders that\n// understand the issues with loading multiple versions of jQuery\n// in a page that all might call define(). The loader will indicate\n// they have special allowances for multiple jQuery versions by\n// specifying define.amd.jQuery = true. Register as a named module,\n// since jQuery can be concatenated with other files that may use define,\n// but not use a proper concatenation script that understands anonymous\n// AMD modules. A named AMD is safest and most robust way to register.\n// Lowercase jquery is used because AMD module names are derived from\n// file names, and jQuery is normally delivered in a lowercase file name.\n// Do this after creating the global so that if an AMD module wants to call\n// noConflict to hide this version of jQuery, it will work.\nif ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n\tdefine( \"jquery\", [], function () { return jQuery; } );\n}\n\n})( window );\n//@ sourceURL=component-jquery/index.js"
));
require.register("visionmedia-batch/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\ntry {\n  var EventEmitter = require('events').EventEmitter;\n} catch (err) {\n  var Emitter = require('emitter');\n}\n\n/**\n * Noop.\n */\n\nfunction noop(){}\n\n/**\n * Expose `Batch`.\n */\n\nmodule.exports = Batch;\n\n/**\n * Create a new Batch.\n */\n\nfunction Batch() {\n  this.fns = [];\n  this.concurrency(Infinity);\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    this.push(arguments[i]);\n  }\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\nif (EventEmitter) {\n  Batch.prototype.__proto__ = EventEmitter.prototype;\n} else {\n  Emitter(Batch.prototype);\n}\n\n/**\n * Set concurrency to `n`.\n *\n * @param {Number} n\n * @return {Batch}\n * @api public\n */\n\nBatch.prototype.concurrency = function(n){\n  this.n = n;\n  return this;\n};\n\n/**\n * Queue a function.\n *\n * @param {Function} fn\n * @return {Batch}\n * @api public\n */\n\nBatch.prototype.push = function(fn){\n  this.fns.push(fn);\n  return this;\n};\n\n/**\n * Execute all queued functions in parallel,\n * executing `cb(err, results)`.\n *\n * @param {Function} cb\n * @return {Batch}\n * @api public\n */\n\nBatch.prototype.end = function(cb){\n  var self = this\n    , total = this.fns.length\n    , pending = total\n    , results = []\n    , cb = cb || noop\n    , fns = this.fns\n    , max = this.n\n    , index = 0\n    , done;\n\n  // empty\n  if (!fns.length) return cb(null, results);\n\n  // process\n  function next() {\n    var i = index++;\n    var fn = fns[i];\n    if (!fn) return;\n    var start = new Date;\n    fn(function(err, res){\n      if (done) return;\n      if (err) return done = true, cb(err);\n      var complete = total - pending + 1;\n      var end = new Date;\n\n      results[i] = res;\n\n      self.emit('progress', {\n        index: i,\n        value: res,\n        pending: pending,\n        total: total,\n        complete: complete,\n        percent: complete / total * 100 | 0,\n        start: start,\n        end: end,\n        duration: end - start\n      });\n\n      if (--pending) next()\n      else cb(null, results);\n    });\n  }\n\n  // concurrency\n  for (var i = 0; i < fns.length; i++) {\n    if (i == max) break;\n    next();\n  }\n\n  return this;\n};\n//@ sourceURL=visionmedia-batch/index.js"
));
require.register("component-inherit/index.js", Function("exports, require, module",
"\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};//@ sourceURL=component-inherit/index.js"
));
require.register("component-preloader/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar Batch = require('batch')\n  , inherit = require('inherit');\n\n/**\n * Expose `Preloader`.\n */\n\nmodule.exports = Preloader;\n\n/**\n * Initialize a new `Preloader`.\n *\n * @return {Type}\n * @api public\n */\n\nfunction Preloader(urls) {\n  Batch.call(this);\n  this.urls = [];\n}\n\n/**\n * Inherits from `Batch.prototype`.\n */\n\ninherit(Preloader, Batch);\n\n/**\n * Preload the given image `url`.\n *\n * @param {String} url\n * @api public\n */\n\nPreloader.prototype.add = function(url){\n  this.urls.push(url);\n  this.push(function(done){\n    var img = new Image;\n    img.onload = function(){ done(); };\n    img.src = url;\n  });\n};//@ sourceURL=component-preloader/index.js"
));
require.register("publicclass-request-animation-frame/index.js", Function("exports, require, module",
"var requestAnimationFrame = function(fn){ setTimeout(fn, 1000 / 60) };\n\nmodule.exports = typeof window != 'undefined'\n  ? window.requestAnimationFrame\n    || window.webkitRequestAnimationFrame\n    || window.mozRequestAnimationFrame\n    || window.oRequestAnimationFrame\n    || window.msRequestAnimationFrame\n    || requestAnimationFrame\n  : requestAnimationFrame;//@ sourceURL=publicclass-request-animation-frame/index.js"
));
require.register("publicclass-now/index.js", Function("exports, require, module",
"\nmodule.exports = (function() {\n  return typeof window != 'undefined' && window.performance\n    ? (window.performance.now\n    || window.performance.mozNow\n    || window.performance.msNow\n    || window.performance.oNow\n    || window.performance.webkitNow\n    || Date.now).bind(window.performance || {})\n    : Date.now || function(){ return +new Date() };\n})()\n//@ sourceURL=publicclass-now/index.js"
));
require.register("publicclass-geom-vec/index.js", Function("exports, require, module",
"\nvar unallocated = []\n  , allocated = []\n  , totalAllocated = 0;\n\n// TODO see if `new Vec()` is better than `[]` or `new Array(2)`\n// in both memory and speed\nfunction Vec(x,y){this[0] = x; this[1] = y};\n\n\n// Used by sin/cos to fix floating point precision errors\n// slower, but testable\nvar EPS = 1e-12;\nfunction eps(x){ return Math.round(x/EPS) * EPS }\n\nvar vec = module.exports = {\n\n  verbose: true,\n\n  _unallocated: unallocated,\n  _allocated: allocated,\n\n  make: function(x,y){\n    var c = vec.alloc();\n    if( typeof x == 'object' ){\n      c[0] = x[0] || x.x || x.u || 0;\n      c[1] = x[1] || x.y || x.v || 0;\n    } else {\n      c[0] = x || 0;\n      c[1] = y || 0;\n    }\n    return c;\n  },\n\n  alloc: function(){\n    if( !unallocated.length ){\n      var i = totalAllocated\n        , u = unallocated.length - i;\n      totalAllocated = (totalAllocated || 64) * 2; // double the size (128>256>512 etc)\n      allocated.length = totalAllocated;\n      vec.verbose && console.warn('vec alloc',totalAllocated)\n      while(i < totalAllocated){\n        var v = [0,0]; //new Array(2); //new Vec(0.0,0.0);\n        unallocated[u+i] = v;\n        allocated[i] = v;\n        i++;\n      }\n    }\n    return unallocated.pop();\n  },\n\n  free: function(v){\n    v && unallocated.push(v);\n    return vec;\n  },\n\n  copy: function(a,b){\n    b = b ||vec.make()\n    b[0] = a[0]\n    b[1] = a[1]\n    return b;\n  },\n\n  add: function(a,b,c){\n    c = c ||vec.make()\n    c[0] = a[0] + b[0];\n    c[1] = a[1] + b[1];\n    return c;\n  },\n\n  sadd: function(a,s,c){\n    c = c || vec.make()\n    c[0] = a[0] + s;\n    c[1] = a[1] + s;\n    return c;\n  },\n\n  sub: function(a,b,c){\n    c = c ||vec.make()\n    c[0] = a[0] - b[0];\n    c[1] = a[1] - b[1];\n    return c;\n  },\n\n  ssub: function(a,s,c){\n    c = c || vec.make()\n    c[0] = a[0] - s;\n    c[1] = a[1] - s;\n    return c;\n  },\n\n  mul: function(a,b,c){\n    c = c ||vec.make()\n    c[0] = a[0] * b[0];\n    c[1] = a[1] * b[1];\n    return c;\n  },\n\n  smul: function(a,s,c){\n    c = c || vec.make()\n    c[0] = a[0] * s;\n    c[1] = a[1] * s;\n    return c;\n  },\n\n  div: function(a,b,c){\n    c = c ||vec.make()\n    c[0] = a[0] / b[0];\n    c[1] = a[1] / b[1];\n    return c;\n  },\n\n  sdiv: function(a,s,c){\n    c = c || vec.make()\n    c[0] = a[0] / s;\n    c[1] = a[1] / s;\n    return c;\n  },\n\n  min: function(a,b,c){\n    c = c ||vec.make()\n    c[0] = Math.min(a[0],b[0])\n    c[1] = Math.min(a[1],b[1])\n    return c;\n  },\n\n  smin: function(a,s,c){\n    c = c ||vec.make()\n    c[0] = Math.min(a[0],s)\n    c[1] = Math.min(a[1],s)\n    return c;\n  },\n\n  max: function(a,b,c){\n    c = c ||vec.make()\n    c[0] = Math.max(a[0],b[0])\n    c[1] = Math.max(a[1],b[1])\n    return c;\n  },\n\n  smax: function(a,s,c){\n    c = c ||vec.make()\n    c[0] = Math.max(a[0],s)\n    c[1] = Math.max(a[1],s)\n    return c;\n  },\n\n  clamp: function(lo,v,hi,c){\n    c = c ||vec.make()\n    vec.min(hi,v,c)\n    vec.max(lo,c,c)\n    return c;\n  },\n\n  sclamp: function(lo,a,hi,c){\n    c = c ||vec.make()\n    vec.min(v,hi,c)\n    vec.max(c,lo,c)\n    return c;\n  },\n\n  abs: function(a,c){\n    c = c ||vec.make()\n    c[0] = Math.abs(a[0])\n    c[1] = Math.abs(a[1])\n    return c;\n  },\n\n  neg: function(a,c){\n    c = c ||vec.make()\n    c[0] = -a[0]\n    c[1] = -a[1]\n    return c;\n  },\n\n  // note: dot(perp(a), b) == cross(a, b)\n  perp: function(a,c){\n    c = c || vec.make()\n    var x=a[0], y=a[1];\n    c[0] = -y\n    c[1] = +x\n    return c;\n  },\n\n  // cross product of two vectors\n  cross: function(a,b){\n    return a[0]*b[1] - a[1]*b[0];\n  },\n\n  // dot product of two vectors\n  dot: function(a,b){\n    return a[0]*b[0] + a[1]*b[1];\n  },\n\n  len: function(a){\n    return Math.sqrt(vec.lenSq(a));\n  },\n\n  lenSq: function(a){\n    return vec.dot(a,a);\n  },\n\n  dist: function(a,b){\n    var d = vec.sub(a,b)\n    var l = vec.len(d)\n    vec.free(d)\n    return l;\n  },\n\n  distSq: function(a,b){\n    var d = vec.sub(a,b)\n    var l = vec.lenSq(d)\n    vec.free(d)\n    return l;\n  },\n\n  norm: function(a,c){\n    c = c || vec.make()\n    var l = vec.len(a);\n    c[0] = !l ? 0 : a[0] / l;\n    c[1] = !l ? 0 : a[1] / l;\n    return c;\n  },\n\n  // to move `a` around `origin`:\n  //  var b = vec.sub(a,origin)\n  //  b = vec.rot(b,theta)\n  //  vec.add(b,origin,a)\n  rot: function(a,theta,c){\n    c = c || vec.make()\n    var cos = Math.cos(theta)\n      , sin = Math.sin(theta);\n    c[0] = eps(cos * a[0] - sin * a[1]);\n    c[1] = eps(sin * a[0] + cos * a[1]);\n    return c;\n  },\n\n  eq: function(a,b){\n    return a[0]===b[0] && a[1]===b[1];\n  },\n\n  lerp: function(a,b,t,c){\n    c = c || vec.make()\n    c[0] = a[0] + (b[0] - a[0]) * t;\n    c[1] = a[1] + (b[1] - a[1]) * t;\n    return c;\n  },\n\n  // m = mat\n  transform: function(a,m,c){\n    c = c || vec.make()\n    var x=a[0], y=a[1];\n    c[0] = m[0]*x + m[3]*y + m[2]\n    c[1] = m[1]*x + m[4]*y + m[5]\n    return c;\n  },\n\n  reflect: function(v,n,c){\n    c = c || vec.make()\n    var t = vec.dot(v,n);\n    c[0] = v[0] - (2 * t) * n[0];\n    c[1] = v[1] - (2 * t) * n[1];\n    return c;\n  }\n}\n//@ sourceURL=publicclass-geom-vec/index.js"
));
require.register("publicclass-geom-mat/index.js", Function("exports, require, module",
"var unallocated = []\n  , allocated = []\n  , totalAllocated = 0;\n\n// Used by sin/cos to fix floating point precision errors\n// slower, but testable\nvar EPS = 1e-12;\nfunction eps(x){ return Math.round(x/EPS) * EPS }\n\n// 2d affine transformation matrix\nvar mat = module.exports = {\n\n  verbose: true,\n\n  _unallocated: unallocated,\n  _allocated: allocated,\n\n  make: function(a,b,c,d,x,y){\n    var m = mat.ident()\n      , u = undefined;\n    if( a !== u ) m[0] = a;\n    if( b !== u ) m[1] = b;\n    if( c !== u ) m[3] = c;\n    if( d !== u ) m[4] = d;\n    if( x !== u ) m[2] = x;\n    if( y !== u ) m[5] = y;\n    return m;\n  },\n\n  alloc: function(){\n    if( !unallocated.length ){\n      var i = totalAllocated\n        , u = unallocated.length - i;\n      totalAllocated = (totalAllocated || 64) * 2; // double the size (128>256>512 etc)\n      allocated.length = totalAllocated;\n      mat.verbose && console.warn('mat alloc',totalAllocated)\n      while(i < totalAllocated){\n        var v = [1,0,0,0,1,0,0,0,1]; //new Array(9)\n        unallocated[u+i] = v;\n        allocated[i] = v;\n        i++;\n      }\n    }\n    return unallocated.pop();\n  },\n\n  free: function(v){\n    v && unallocated.push(v);\n    return mat;\n  },\n\n  copy: function(a,m){\n    m = m || mat.make()\n    m[0] = a[0];\n    m[1] = a[1];\n    m[2] = a[2];\n    m[3] = a[3];\n    m[4] = a[4];\n    m[5] = a[5];\n    m[6] = a[6];\n    m[7] = a[7];\n    m[8] = a[8];\n    return m;\n  },\n\n  ident: function(m){\n    m = m || mat.alloc()\n    m[0] = 1; // 0 0 / a\n    m[1] = 0; // 0 1 / b\n    m[2] = 0; // 0 2 / tx\n    m[3] = 0; // 1 0 / c\n    m[4] = 1; // 1 1 / d\n    m[5] = 0; // 1 2 / ty\n    m[6] = 0; // 2 0 / ?\n    m[7] = 0; // 2 1 / ?\n    m[8] = 1; // 2 2 / ?\n    return m;\n  },\n\n  mul: function(a,b,m){\n    var c = mat.make()\n    c[0] = a[0]*b[0] + a[3]*b[1] // a*a + c*b\n    c[1] = a[1]*b[0] + a[4]*b[1] // b*a + d*b\n    c[3] = a[0]*b[3] + a[3]*b[4] // a*c + c*d\n    c[4] = a[1]*b[3] + a[4]*b[4] // b*c + d*d\n    c[2] = a[0]*b[2] + a[3]*b[5] + a[2] // a*tx + c*ty + tx\n    c[5] = a[1]*b[2] + a[4]*b[5] + a[5] // b*tx + d*ty + ty\n    if( m ){\n      mat.copy(c,m)\n      mat.free(c)\n      return m;\n    }\n    return c;\n  },\n\n  //https://github.com/STRd6/matrix.js/blob/master/matrix.js\n  translate: function(x,y,m){\n    var a = mat.make(1,0,0,1,x,y)\n    if( m ){\n      mat.mul(a,m,m)\n      mat.free(a)\n      return m;\n    }\n    return a;\n  },\n\n  rotate: function(theta,m){\n    var c = eps(Math.cos(theta))\n      , s = eps(Math.sin(theta))\n      , a = mat.make(c,s,-s,c);\n    if( m ){\n      mat.mul(a,m,m)\n      mat.free(a)\n      return m;\n    }\n    return a;\n  },\n\n  scale: function(x,y,m){\n    var a = mat.make(x,0,0,y)\n    if( m ){\n      mat.mul(a,m,m)\n      mat.free(a)\n      return m;\n    }\n    return a;\n  },\n\n  // TODO transpose\n  // TODO shear\n\n  inv: function(a,m){\n    var id = 1 / (a[0]*a[4] - a[1]*a[3]);\n    a = mat.make(\n       a[4]*id,\n      -a[1]*id,\n      -a[3]*id,\n       a[0]*id,\n      (a[3]*a[5] - a[4]*a[2])*id,\n      (a[1]*a[2] - a[0]*a[5])*id\n    )\n    if( m ){\n      mat.mul(a,m,m)\n      mat.free(a)\n      return m;\n    }\n    return a;\n  }\n}//@ sourceURL=publicclass-geom-mat/index.js"
));
require.register("publicclass-geom-poly/index.js", Function("exports, require, module",
"var vec = require('geom-vec');\n\n\nvar unallocated = []\n  , allocated = []\n  , totalAllocated = 0;\n\nfunction Poly(){\n  this.length = 0;\n  this.vertices = []\n  this.edges = []\n}\n\nvar poly = module.exports = {\n\n  verbose: true,\n\n  make: function(){\n    var p = poly.alloc();\n    if( arguments.length ){\n      for( var i=0; i < arguments.length; i+=2 )\n        poly.add(p,arguments[i],arguments[i+1]);\n      poly.close(p);\n    }\n    return p;\n  },\n\n  alloc: function(){\n    if( !unallocated.length ){\n      var i = totalAllocated\n        , u = unallocated.length - i;\n      totalAllocated = (totalAllocated || 64) * 2; // double the size (128>256>512 etc)\n      allocated.length = totalAllocated;\n      poly.verbose && console.warn('poly alloc',totalAllocated)\n      while(i < totalAllocated){\n        var p = new Poly();\n        unallocated[u+i] = p;\n        allocated[i] = p;\n        i++;\n      }\n    }\n    return unallocated.pop();\n  },\n\n  free: function(p){\n    if( p ){\n      while(p.vertices.length)\n        vec.free(p.vertices.pop());\n      while(p.edges.length)\n        vec.free(p.edges.pop());\n      p.length = 0;\n      unallocated.push(p);\n    }\n    return p;\n  },\n\n  copy: function(p,c){\n    c = poly.free(c) || poly.make()\n    for (var i = 0; i < p.vertices.length; i++) {\n      poly.add(c,p.vertices[i][0],p.vertices[i][1])\n    }\n    poly.close(c);\n    return c;\n  },\n\n  add: function(p,x,y){\n    var v = vec.make(x,y)\n    if( p.length ){\n      // an edge is a vector between the last and\n      // the current vertex\n      var l = p.vertices[p.length-1];\n      p.edges.push(vec.sub(v,l));\n    }\n    p.vertices.push(v);\n    p.length++;\n    return p;\n  },\n\n  close: function(p){\n    if( p.length ){\n      // an edge is a vector between the last and\n      // the current vertex\n      var l = p.vertices[p.length-1]\n      var v = p.vertices[0];\n      p.edges.push(vec.sub(v,l));\n    }\n    return p;\n  },\n\n  // source: http://alienryderflex.com/polygon/\n  inside: function(p,x,y){\n    var oddNodes = false;\n    for( var i=0,j=p.vertices.length-1; i < p.vertices.length; i++ ){\n      var vI = p.vertices[i]\n        , vJ = p.vertices[j];\n      if( (vI.y< y && vJ.y>=y\n       ||  vJ.y< y && vI.y>=y)\n       && (vI.x<=x || vJ.x<=x))\n        oddNodes ^= (vI.x+(y-vI.y)/(vJ.y-vI.y)*(vJ.x-vI.x)<x);\n      j = i;\n    }\n    return oddNodes;\n  },\n\n  area: function(p){\n    var n = p.vertices.length\n      , area = 0;\n    for(var i=0, j=n-1; i < n; j=i, i++){\n      var v = p.vertices[i];\n      var q = p.vertices[j];\n      area += v[0] * q[1];\n      area -= v[1] * q[0];\n    }\n    return Math.abs(area / 2);\n  },\n\n  perimeter: function(p){\n    var sum = 0;\n    for(var i=0; i < p.edges.length; i++){\n      var e = p.edges[i];\n      sum += vec.len(e); // TODO optimize away sqrt?\n    }\n    return sum;\n  },\n\n  radiusSq: function(p,c){\n    var r = 0;\n    c = c || poly.centroid(p);\n    for(var i=0; i < p.length; i++){\n      var v = p.vertices[i];\n      var d = vec.distSq(v,c);\n      if( d > r ) r = d;\n    }\n    return r;\n  },\n\n  radius: function(p,c){\n    return Math.sqrt(poly.radiusSq(p,c));\n  },\n\n  centroid: function(p){\n    var a = poly.area(p) // TODO maybe accept area as an argument (in case it's cached?)\n      , n = p.length\n      , P = p.vertices\n      , c = vec.make();\n    for(var i=0, j=n-1; i < n; j=i, i++){\n      var v = P[i]\n        , q = P[j]\n        , x = vec.cross(v,q);\n      c[0] += (v[0] + q[0]) * x\n      c[1] += (v[1] + q[1]) * x\n    }\n    var b = 1 / (6 * a);\n    vec.smul(c,b,c)\n    if( c[0] < 0 ){\n      vec.neg(c,c)\n    }\n    return c;\n  },\n\n  translate: function(p,x,y,o){\n    if( o && (o.length !== p.length) ){\n      // TODO this will not make a functional `o` (should use poly.add()/poly.close())\n      throw new Error('translate to unequal polys are not supported')\n      return;\n    }\n    var t = vec.make(x,y)\n    o = o || p;\n    for(var j=0; j < p.length; j++){\n      vec.add(p.vertices[j],t,o.vertices[j]);\n    }\n    vec.free(t)\n    return o;\n  },\n\n  rotate: function(p,theta,o){\n    // TODO\n    throw new Error('rotate not implemented')\n  },\n\n  scale: function(p,theta,o){\n    // TODO\n    throw new Error('scale not implemented')\n  },\n\n  transform: function(p,mat,o){\n    if( o && (o.length !== p.length) ){\n      // TODO this will not make a functional `o` (should use poly.add()/poly.close())\n      throw new Error('transform to unequal polys are not supported')\n      return;\n    }\n    o = o || p\n    var n = p.length;\n    for(var i=0, j=n-1; i < n; j=i, i++){\n      vec.transform(p.vertices[i],mat,o.vertices[i]);\n      vec.sub(p.vertices[i],p.vertices[j],o.edges[j])\n    }\n    vec.sub(p.vertices[0],p.vertices[n-1],o.edges[n-1])\n    return o;\n  },\n\n  convexHull: function(p,o){\n    // TODO\n    throw new Error('convexHull not implemented')\n  },\n\n  reverse: function(p){\n    var o = poly.make();\n    for(var i=p.length-1; i>=0; i--){\n      var v = p.vertices[i];\n      poly.add(o,v[0],v[1]);\n    }\n    return poly.close(o);\n  },\n\n  aabb: function(p,o){\n    // [t,r,b,l]\n    var aabb = o || [0,0,0,0]\n    aabb[0] =  Infinity;\n    aabb[1] = -Infinity;\n    aabb[2] = -Infinity;\n    aabb[3] =  Infinity;\n    for(var j=0; j < p.length; j++){\n      var v = p.vertices[j];\n      if( v[1] < aabb[0] ) aabb[0] = v[1] // t\n      if( v[0] > aabb[1] ) aabb[1] = v[0] // r\n      if( v[1] > aabb[2] ) aabb[2] = v[1] // b\n      if( v[0] < aabb[3] ) aabb[3] = v[0] // l\n    }\n    return aabb;\n      // or [x,y,w,h]?\n      // or Poly(x1,y1,x2,y2,x3,y3,x4,y4)?\n  },\n\n  // a->b goes through an edge of p? if so set the intersection\n  // at i and the normal of the edge at n\n  intersects: function(p,a,b,i,n){\n    // TODO\n    throw new Error('intersects not implemented')\n  },\n\n  // http://www.codeproject.com/Articles/15573/2D-Polygon-Collision-Detection\n  // is polygon `a` going to collide with polygon `b`?\n  // `v` is the relative velocity of the polygons (ie. velA - velB)\n  // returns a collision info object:\n  //    { intersect: Bool, willIntersect: Bool, nearestEdge: vec, minTranslationVector: vec}\n  collides: function(a,b,v,o){\n    var res = o || {};\n    res.intersect = true;\n    res.willIntersect = true;\n    res.minTranslationVector = null;\n    res.nearestEdge = null;\n\n    v = v || vec.make()\n    var minIntervalDistance = Infinity;\n    var translationAxis = vec.make();\n    var nearestEdge = vec.make();\n    var axis = vec.make()\n    var iA = vec.make();\n    var iB = vec.make();\n    var cA, cB, cD;\n\n    // loop through all edges of both polygons\n    for(var i=0; i < (a.length+b.length); i++){\n      var e = i < a.length ? i : i-a.length\n      var edge = i < a.length ? a.edges[e] : b.edges[e]\n\n      vec.perp(edge,axis)\n      vec.norm(axis,axis)\n\n      poly.project(a,axis,iA)\n      poly.project(b,axis,iB)\n\n      // are they currently intersecting?\n      var iD = intervalDistance(iA,iB);\n      if( iD >= 0 ){\n        res.intersect = false;\n      }\n\n      // will they intersect?\n      var vProj = vec.dot(axis,v);\n      if( vProj < 0 ){\n        iA[0] += vProj;\n      } else {\n        iA[1] += vProj;\n      }\n\n      iD = intervalDistance(iA,iB);\n      if( iD >= 0 ){\n        res.willIntersect = false;\n      }\n\n      // find out if it's the closest one\n      iD = Math.abs(iD);\n      if( iD < minIntervalDistance ){\n        minIntervalDistance = iD;\n        vec.copy(edge, nearestEdge);\n        vec.copy(axis, translationAxis);\n\n        cA = cA || poly.centroid(a)\n        cB = cB || poly.centroid(b)\n        cD = vec.sub(cA, cB, cD);\n        if( vec.dot(cD, translationAxis) < 0 ){\n          vec.neg(translationAxis,translationAxis)\n        }\n      }\n\n      // no intersection is and won't happen\n      if( !res.intersect && !res.willIntersect ){\n        break;\n      }\n\n    }\n\n    // the minimum translation vector can\n    // be used to push the polygons apart\n    if( res.willIntersect ){\n      translationAxis[0] *= minIntervalDistance;\n      translationAxis[1] *= minIntervalDistance;\n      res.minTranslationVector = translationAxis;\n      res.nearestEdge = nearestEdge;\n    } else {\n      vec.free(translationAxis)\n      vec.free(nearestEdge)\n    }\n\n    vec.free(iA)\n    vec.free(iB)\n    vec.free(cA)\n    vec.free(cB)\n    vec.free(cD)\n    vec.free(axis)\n\n    // free `v` if it wasn't passed in as\n    // an argument\n    if( !arguments[2] ){\n      vec.free(v);\n    }\n\n    return res;\n  },\n\n\n  // `i` (interval) will be [min,max]\n  // `axis` (vec) will be [x,y]\n  project: function(p,axis,i){\n    i = i || vec.make();\n    i[0] =  Infinity;\n    i[1] = -Infinity;\n    for(var j=0; j < p.length; j++){\n      var dot = vec.dot(axis,p.vertices[j])\n      if( dot < i[0] ){\n        i[0] = dot;\n      }\n      if( dot > i[1] ){\n        i[1] = dot;\n      }\n    }\n    return i;\n  }\n\n}\n\n\n\nfunction intervalDistance(a,b){\n  return a[0] < b[0] ? b[0] - a[1] : a[0] - b[1];\n}//@ sourceURL=publicclass-geom-poly/index.js"
));
require.register("publicclass-geom/index.js", Function("exports, require, module",
"exports.vec = require('geom-vec')\nexports.mat = require('geom-mat')\nexports.poly = require('geom-poly')//@ sourceURL=publicclass-geom/index.js"
));
require.register("component-type/index.js", Function("exports, require, module",
"\n/**\n * toString ref.\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Return the type of `val`.\n *\n * @param {Mixed} val\n * @return {String}\n * @api public\n */\n\nmodule.exports = function(val){\n  switch (toString.call(val)) {\n    case '[object Function]': return 'function';\n    case '[object Date]': return 'date';\n    case '[object RegExp]': return 'regexp';\n    case '[object Arguments]': return 'arguments';\n    case '[object Array]': return 'array';\n    case '[object String]': return 'string';\n  }\n\n  if (val === null) return 'null';\n  if (val === undefined) return 'undefined';\n  if (val && val.nodeType === 1) return 'element';\n  if (val === Object(val)) return 'object';\n\n  return typeof val;\n};\n//@ sourceURL=component-type/index.js"
));
require.register("publicclass-copy/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar type;\n\ntry {\n  type = require('type');\n} catch(e){\n  type = require('type-component');\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = copy;\n\n/**\n * Copies the properties of `obj`.\n *\n * @param {Mixed} any object\n * @param {Mixed} any object\n * @param {Boolean} remove missing keys\n * @api public\n */\n\nfunction copy(obj,to,clean){\n  switch (type(obj)) {\n    case 'object':\n      var c = type(to) == 'object' ? to : {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          c[key] = copy(obj[key],c[key],clean);\n        }\n      }\n      if( clean ){\n        for (var key in c) {\n          if (c.hasOwnProperty(key) && !obj.hasOwnProperty(key)) {\n            delete c[key];\n          }\n        }\n      }\n      return c;\n\n    case 'array':\n      var c = type(to) == 'array' ? to : [];\n      c.length = obj.length;\n      for (var i = 0, l = obj.length; i < l; i++) {\n        c[i] = copy(obj[i],c[i],clean);\n      }\n      return c;\n\n    case 'regexp':\n      // from millermedeiros/amd-utils - MIT\n      var flags = '';\n      flags += obj.multiline ? 'm' : '';\n      flags += obj.global ? 'g' : '';\n      flags += obj.ignoreCase ? 'i' : '';\n      return new RegExp(obj.source, flags);\n\n    case 'date':\n      return new Date(obj.getTime());\n\n    default: // string, number, boolean, \n      return obj;\n  }\n}\n//@ sourceURL=publicclass-copy/index.js"
));
require.register("publicclass-stash/index.js", Function("exports, require, module",
"\nmodule.exports = function createStash(){\n  return new Stash();\n}\n\nmodule.exports.Stash = Stash;\n\nfunction Stash(){\n  this.values = [];\n  this.lookup = {};   // [key] = index\n  this.reverse = {};  // [index] = key\n  this.length = 0;\n}\n\nStash.prototype = {\n\n  set: function(key,val){\n    key = ''+key\n    if( key in this.lookup ){\n      console.warn('key \"%s\" already exists in stash. deleting it first.',key)\n      this.del(key);\n    }\n    var index = this.values.length;\n    this.lookup[key] = index;\n    this.reverse[index] = key;\n    this.values.push(val)\n    this.length++;\n    return this\n  },\n\n  has: function(key){\n    return (''+key) in this.lookup;\n  },\n\n  get: function(key){\n    key = ''+key\n    if( key in this.lookup ){\n      var index = this.lookup[key];\n      return this.values[index];\n    } else console.error('tried to get \"%s\" that didn\\'t exist',key)\n    return undefined;\n  },\n\n  del: function(key){\n    key = ''+key\n    if( key in this.lookup ){\n      // move the last values into the\n      // position of the deleted value\n      // to keep the array dense (and\n      // avoid unnecessary allocation)\n      var index = this.lookup[key]\n        , end = this.length-1;\n\n      // special case if the deleted key is last value (no need to reorder stuff)\n      if( index == end ){\n        this.values.pop();\n        delete this.reverse[index];\n        delete this.lookup[key];\n        this.length--;\n\n      } else if( index >= 0 && index < end ){\n        this.values[index] = this.values.pop();\n\n        // update the lookups\n        var rindex = this.values.length;\n        var rkey = this.reverse[rindex];\n        this.lookup[rkey] = index;\n        this.reverse[index] = rkey;\n        delete this.reverse[rindex];\n        delete this.lookup[key];\n        this.length--;\n      } else console.warn('tried to delete \"%s\" with an invalid index %s',key,index)\n    } else console.warn('tried to delete \"%s\" that didn\\'t exist',key)\n    return this;\n  },\n\n  empty: function(){\n    this.values.length = 0\n    this.length = 0\n    for(var i in this.reverse){\n      var k = this.reverse[i]\n      delete this.lookup[k]\n      delete this.reverse[i]\n    }\n    return this;\n  }\n\n}//@ sourceURL=publicclass-stash/index.js"
));
require.register("publicclass-netchan/index.js", Function("exports, require, module",
"\nmodule.exports = NetChannel;\n\n/**\n * NetChannel wraps an unreliable DataChannel\n * with a sequence and an ack.\n *\n * When a message is received it checks the ack against\n * the messages buffer and the ones \"acknowledged\" will\n * be removed from the buffer and the rest will be resent.\n *\n * After sending and the buffer is not empty after a timeout\n * it will try to send again until it is.\n *\n * Inspired by NetChan by Id software.\n *\n *  Options:\n *\n *    - {Number} `resend` a number in ms if how often it should try to flush again.\n *    - {Boolean} `ack` if true an ACK packet will automatically be responded with to keep the buffer clean.\n *\n * @param {DataChannel} channel\n * @param {Object} opts\n */\nfunction NetChannel(channel,opts){\n  this.seq = 1;\n  this.ack = 0;\n  this.buffer = []; // [seq,buf]\n  this.bufferLength = 0;\n  this.encoded = null; // cached\n  this.options = opts || {}\n\n  channel && this.setChannel(channel)\n}\n\n// magic packet\nvar ACK = 'ncACK'.split('').map(function(c){return c.charCodeAt(0)})\nNetChannel.ACK = new Uint8Array(ACK).buffer;\nNetChannel._isACK = isACK; // export for testing only\n\nNetChannel.prototype = {\n\n  onmessage: noop,\n\n  setChannel: function(channel){\n    if( channel.reliable )\n      throw new ArgumentError('channel must be unreliable. just use the normal data channel instead.')\n    var netchan = this;\n    this.channel = channel;\n    this.channel.addEventListener('message',function(e){ netchan.recv(e) },false)\n  },\n\n  recv: function(e){\n    this.decode(e.data)\n    this.flush()\n  },\n\n  send: function(msg){\n    // accept any TypedArray\n    if( msg && (msg.buffer instanceof ArrayBuffer) ){\n      msg = msg.buffer;\n    }\n\n    if( !(msg instanceof ArrayBuffer) ){\n      throw new Error('invalid message type, only binary is supported');\n    }\n\n    if( msg.byteLength > 255 ){\n      throw new Error('invalid message length, only up to 256 bytes are supported')\n    }\n\n    // grow by 3 bytes (seq & len)\n    var seq = this.seq++;\n    var buf = new Uint8Array(3+msg.byteLength);\n    var dat = new DataView(buf.buffer);\n    dat.setUint16(0,seq);\n    dat.setUint8(2,msg.byteLength);\n    buf.set(new Uint8Array(msg),3);\n\n    this.bufferLength += buf.byteLength;\n    this.buffer.push(seq,buf);\n    this.encoded = null;\n\n    this.flush();\n  },\n\n  flush: function(){\n    if( this.bufferLength && this.channel && this.channel.readyState == 'open' ){\n      this.channel.send(this.encoded || this.encode());\n\n      // try again every X ms and stop when buffer is empty\n      if( this.options.resend ){\n        clearTimeout(this._timeout)\n        this._timeout = setTimeout(this.flush.bind(this),this.options.resend)\n      }\n    }\n  },\n\n  // encodes into a message like this:\n  // ack,seq1,len1,data1[,seq2,len2,data2...]\n  encode: function(){\n    // grow by 2 bytes (ack) + unsent buffer\n    var buf = new Uint8Array(2+this.bufferLength);\n    var data = new DataView(buf.buffer);\n\n    // prepend with ack number\n    data.setUint16(0,this.ack)\n\n    // write all buffered messages\n    var offset = 2;\n    for(var i=1; i < this.buffer.length; i+=2){\n      var msg = this.buffer[i];\n      buf.set(msg,offset);\n      offset += msg.byteLength;\n    }\n    return this.encoded = buf.buffer;\n  },\n\n  // decodes from a message like this:\n  // ack,seq1,len1,data1[,seq2,len2,data2...]\n  decode: function(buf){\n    // read the sequence and ack\n    var data = new DataView(buf.buffer || buf)\n    var ack = data.getUint16(0)\n    this.shrink(ack)\n\n    // read messages\n    var offset = 2 // start after ack\n      , length = buf.byteLength\n      , seq = this.ack // in case no messages are read, its the same\n      , len = 0\n      , sendACK = false;\n\n    while(offset < length){\n      seq = data.getUint16(offset,false); // false is required for node test only\n      len = data.getUint8(offset+2);\n      if( seq <= this.ack ){\n        offset += len+3; // len + seq = 3 bytes\n        continue;\n      }\n\n      // get the message\n      var msg = data.buffer.slice(offset+3,offset+3+len);\n      offset += len+3;\n\n      // emit onmessage for each message unless it's an ACK\n      if( !this.options.ack || !isACK(msg) ){\n        this.onmessage(msg);\n        sendACK = true;\n      }\n\n      // store the sequence as the last acknowledged one\n      this.ack = seq;\n    }\n\n    // send an ACK\n    if( this.options.ack && sendACK ){\n      this.send(NetChannel.ACK);\n    }\n  },\n\n  // shrink the buffer & bufferLength up to the\n  // acknowledged messages.\n  // assumes this.buffer is sorted by sequence\n  shrink: function(ack){\n    var index = null\n      , length = 0;\n    for(var i=0; i < this.buffer.length; i+=2){\n      var s = this.buffer[i];\n      if( s <= ack ){\n        index = i+2;\n        length += this.buffer[i+1].byteLength;\n      } else {\n        break;\n      }\n    }\n    if( index !== null ){\n      this.buffer.splice(0,index);\n      this.bufferLength -= length;\n      this.encoded = null;\n    }\n  },\n\n  toString: function(){\n    return 'NetChannel\\n\\t' + [\n      'seq: '+this.seq,\n      'ack: '+this.ack,\n      'buffer: '+this.buffer.length,\n      'buffer size: '+this.bufferLength,\n      'encoded: '+(this.encoded&&this.encoded.byteLength)\n    ].join('\\n\\t')\n  }\n}\n\nfunction noop(){}\n\nfunction isACK(msg){\n  // check the type\n  if( !msg || typeof msg != typeof NetChannel.ACK ){\n    return false;\n  }\n\n  // check the length\n  if( msg.byteLength !== NetChannel.ACK.byteLength ){\n    return false;\n  }\n  // check if they have the same contents\n  var arr = new Uint8Array(msg);\n  for(var i=0; i<ACK.length; i++){\n    if( arr[i] !== ACK[i] ){\n      return false;\n    }\n  }\n\n  // yup. it's an ACK\n  return true;\n}//@ sourceURL=publicclass-netchan/index.js"
));
require.register("component-to-function/index.js", Function("exports, require, module",
"\n/**\n * Expose `toFunction()`.\n */\n\nmodule.exports = toFunction;\n\n/**\n * Convert `obj` to a `Function`.\n *\n * @param {Mixed} obj\n * @return {Function}\n * @api private\n */\n\nfunction toFunction(obj) {\n  switch ({}.toString.call(obj)) {\n    case '[object Object]':\n      return objectToFunction(obj);\n    case '[object Function]':\n      return obj;\n    case '[object String]':\n      return stringToFunction(obj);\n    case '[object RegExp]':\n      return regexpToFunction(obj);\n    default:\n      return defaultToFunction(obj);\n  }\n}\n\n/**\n * Default to strict equality.\n *\n * @param {Mixed} val\n * @return {Function}\n * @api private\n */\n\nfunction defaultToFunction(val) {\n  return function(obj){\n    return val === obj;\n  }\n}\n\n/**\n * Convert `re` to a function.\n *\n * @param {RegExp} re\n * @return {Function}\n * @api private\n */\n\nfunction regexpToFunction(re) {\n  return function(obj){\n    return re.test(obj);\n  }\n}\n\n/**\n * Convert property `str` to a function.\n *\n * @param {String} str\n * @return {Function}\n * @api private\n */\n\nfunction stringToFunction(str) {\n  // immediate such as \"> 20\"\n  if (/^ *\\W+/.test(str)) return new Function('_', 'return _ ' + str);\n\n  // properties such as \"name.first\" or \"age > 18\"\n  return new Function('_', 'return _.' + str);\n}\n\n/**\n * Convert `object` to a function.\n *\n * @param {Object} object\n * @return {Function}\n * @api private\n */\n\nfunction objectToFunction(obj) {\n  var match = {}\n  for (var key in obj) {\n    match[key] = typeof obj[key] === 'string'\n      ? defaultToFunction(obj[key])\n      : toFunction(obj[key])\n  }\n  return function(val){\n    if (typeof val !== 'object') return false;\n    for (var key in match) {\n      if (!(key in val)) return false;\n      if (!match[key](val[key])) return false;\n    }\n    return true;\n  }\n}\n//@ sourceURL=component-to-function/index.js"
));
require.register("component-mean/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar toFunction = require('to-function');\n\n/**\n * Return the mean value in `arr` with optional callback `fn(val, i)`.\n *\n * @param {Array} arr\n * @param {Function} [fn]\n * @return {Number}\n * @api public\n */\n\nmodule.exports = function(arr, fn){\n  if (0 == arr.length) return null;\n  var sum = 0;\n\n  if (fn) {\n    fn = toFunction(fn);\n    for (var i = 0; i < arr.length; ++i) {\n      sum += fn(arr[i], i);\n    }\n  } else {\n    for (var i = 0; i < arr.length; ++i) {\n      sum += arr[i];\n    }\n  }\n\n  return sum / arr.length;\n};\n//@ sourceURL=component-mean/index.js"
));
require.register("component-variance/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar toFunction = require('to-function')\n  , mean = require('mean');\n\n/**\n * Return the variance of `arr` with optional callback `fn(val, i)`.\n *\n * @param {Array} arr\n * @param {Function} [fn]\n * @return {Number}\n * @api public\n */\n\nmodule.exports = function(arr, fn){\n  if (0 == arr.length) return null;\n\n  var m = mean(arr);\n  var d = [];\n\n  if (fn) {\n    fn = toFunction(fn);\n    for (var i = 0; i < arr.length; i++) {\n      d.push(Math.pow(fn(arr[i], i) - m, 2));\n    }\n  } else {\n    for (var i = 0; i < arr.length; i++) {\n      d.push(Math.pow(arr[i] - m, 2));\n    }\n  }\n\n  return mean(d);\n};\n//@ sourceURL=component-variance/index.js"
));
require.register("component-standard-deviation/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar variance = require('variance');\n\n/**\n * Return the standard deviation of `arr` with optional callback `fn(val, i)`.\n *\n * @param {Array} arr\n * @param {Function} [fn]\n * @return {Number}\n * @api public\n */\n\nmodule.exports = function(arr, fn){\n  if (0 == arr.length) return null;\n  return Math.sqrt(variance(arr, fn));\n};\n//@ sourceURL=component-standard-deviation/index.js"
));
require.register("publicclass-median/index.js", Function("exports, require, module",
"\n/**\n * Return the median of the numbers in `arr`.\n *\n * @param {Array} arr\n * @return {Number}\n * @api public\n */\n\nmodule.exports = function(arr){\n  var n = arr.length;\n  if( n % 2 == 0 ){\n    return arr[n/2];\n  } else {\n    var l = Math.floor(n/2)\n    return (arr[l] + arr[l+1]) / 2;\n  }\n}//@ sourceURL=publicclass-median/index.js"
));
require.register("publicclass-latency/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\nvar median = require('median')\n  , sd = require('standard-deviation');\n\n\n/**\n * Calculates the latency from an `arr` of\n * times (each the result of `now - started`).\n *\n * Based on: http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/clock-synchronization-of-client-programs-r2493\n *\n * @param {Array} arr\n * @return {Number}\n * @api public\n */\nmodule.exports = function(arr){\n  var std = sd(arr);\n  var m = median(arr);\n  var sum = 0;\n  var n = 0;\n  for (var i = 0; i < arr.length; ++i) {\n    if( Math.abs(m - arr[i]) <= std ){\n      sum += arr[i];\n      n++;\n    }\n  }\n  return sum / n;\n}//@ sourceURL=publicclass-latency/index.js"
));
require.register("publicclass-base64-arraybuffer/index.js", Function("exports, require, module",
"/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nexports.encode = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer)\n    , len = bytes.byteLength\n    , base64 = \"\";\n\n  for(var i = 0; i < len; i+=3){\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n\n  if ((len % 3) === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n\n  return base64;\n};\n\nexports.decode =  function(base64) {\n  var bufferLength = base64.length * 0.75\n    , len = base64.length\n    , p = 0\n    , encoded1\n    , encoded2\n    , encoded3\n    , encoded4;\n\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n\n  var arraybuffer = new ArrayBuffer(bufferLength),\n  bytes = new Uint8Array(arraybuffer);\n\n  for(var i=0; i < len; i+=4){\n    encoded1 = chars.indexOf(base64[i]);\n    encoded2 = chars.indexOf(base64[i+1]);\n    encoded3 = chars.indexOf(base64[i+2]);\n    encoded4 = chars.indexOf(base64[i+3]);\n\n    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n  }\n\n  return arraybuffer;\n};//@ sourceURL=publicclass-base64-arraybuffer/index.js"
));
require.register("visionmedia-debug/index.js", Function("exports, require, module",
"if ('undefined' == typeof window) {\n  module.exports = require('./lib/debug');\n} else {\n  module.exports = require('./debug');\n}\n//@ sourceURL=visionmedia-debug/index.js"
));
require.register("visionmedia-debug/debug.js", Function("exports, require, module",
"\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\nif (window.localStorage) debug.enable(localStorage.debug);\n//@ sourceURL=visionmedia-debug/debug.js"
));
require.register("component-event/index.js", Function("exports, require, module",
"\n/**\n * Bind `el` event `type` to `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.bind = function(el, type, fn, capture){\n  if (el.addEventListener) {\n    el.addEventListener(type, fn, capture || false);\n  } else {\n    el.attachEvent('on' + type, fn);\n  }\n  return fn;\n};\n\n/**\n * Unbind `el` event `type`'s callback `fn`.\n *\n * @param {Element} el\n * @param {String} type\n * @param {Function} fn\n * @param {Boolean} capture\n * @return {Function}\n * @api public\n */\n\nexports.unbind = function(el, type, fn, capture){\n  if (el.removeEventListener) {\n    el.removeEventListener(type, fn, capture || false);\n  } else {\n    el.detachEvent('on' + type, fn);\n  }\n  return fn;\n};\n//@ sourceURL=component-event/index.js"
));
require.register("ecarter-css-emitter/index.js", Function("exports, require, module",
"\n/**\n * Module Dependencies\n */\n\nvar Emitter = require('emitter')\n  , events = require('event');\n\n// CSS events\n\nvar watch = [\n  'transitionend'\n, 'webkitTransitionEnd'\n, 'oTransitionEnd'\n, 'MSTransitionEnd'\n, 'animationend'\n, 'webkitAnimationEnd'\n, 'oAnimationEnd'\n, 'MSAnimationEnd'\n];\n\n/**\n * Expose `CSSnext`\n */\n\nmodule.exports = CssEmitter;\n\n/**\n * Initialize a new `CssEmitter`\n *\n */\n\nfunction CssEmitter(element){\n  if (!(this instanceof CssEmitter)) return new CssEmitter(element);\n  Emitter.call(this);\n  this.el = element;\n  this.bind();\n}\n\n/**\n * Inherit from `Emitter.prototype`\n */\n\nCssEmitter.prototype = new Emitter;\n\n/**\n * Bind CSS events.\n *\n * @api private\n */\n\nCssEmitter.prototype.bind = function(){\n  var self = self || this;\n  for (var i=0; i < watch.length; i++) {\n    events.bind(this.el, watch[i], function(e){\n      self.emit('end', e);\n    });\n  }\n};\n\n//@ sourceURL=ecarter-css-emitter/index.js"
));
require.register("slam/index.js", Function("exports, require, module",
"module.exports = require('./lib/app.js')//@ sourceURL=slam/index.js"
));
require.register("slam/lib/tracking.js", Function("exports, require, module",
"module.exports = {\n  replayClicks:1,\n  levelStartTime:0,\n  currentLevel: -1\n}//@ sourceURL=slam/lib/tracking.js"
));
require.register("slam/lib/settings.js", Function("exports, require, module",
"var Emitter = require('emitter')\n  , Themes = require('./themes');\n\nvar settings = Emitter(exports);\n\nsettings.CAMERA_SCRIPTED = 0\nsettings.CAMERA_FPS = 1\nsettings.CAMERA_CLASSIC = 2\nsettings.CAMERA_RABBIT = 3\nsettings.CAMERA_MOUNTAINVIEW = 4\n\nsettings.QUALITY_BEST = 'best'\nsettings.QUALITY_HIGH = 'high'\nsettings.QUALITY_LOW = 'low'\nsettings.QUALITY_MOBILE = 'mobile'\n\n// the default theme\n// to be overridden by levels\nsettings.ai = null;\nsettings.theme = Themes.current;\n\nsettings.data = {\n\n  framerate: 60,\n  timestep: 1000/60,\n  maxUpdatesPerFrame: 15,\n\n  cameraType:settings.CAMERA_SCRIPTED,\n  antialias: false,\n  cameraFov: 50,\n  cameraOverlay: true,\n  cameraGrid: 0,\n  godMode: false,\n  showDebugInfo: false,\n  //overrideCamera: '',\n  fpsCamera: false,\n\n  // game\n  arenaWidth: 1700,\n  arenaHeight: 1700/18*26,\n  arenaColumns: 18,\n  arenaRows: 26,\n  unitSize: Math.round(1700/18), //= 94\n  unitSpeed: 18,\n  arenaSideHeight: 200,\n  shieldPadding:2,\n  defaultShields: 3,\n  videoBoxDepth:700,\n  paddleMass: 0.8,\n  paddleDamping: 0.8,\n\n  // minimum Y velocity of puck\n  minYSpeed: 10,\n\n  // speed of bullets\n  // (multiplier of unitSpeed)\n  bulletSpeed: 1.6,\n\n  // time in ms how long a newly spawned\n  // extra should be GHOSTed. this is so\n  // the user has time to see what it is\n  // first.\n  extraGhostDuration: 400,\n\n  // the default probability of an extra\n  // to be spawned. so if for example only\n  // one of the available extras defines\n  // a probability of `1` it will be 10x\n  // less likely then all the other extras\n  // to be found.\n  defaultProbability: 10,\n\n  // the interval on which the forces\n  // will toggle between active/inactive\n  // set to 0 or non-number to disable.\n  forcesInterval: 3000,\n\n  // turn on paddle 'slam' effect\n  paddleMomentum: true,\n\n  // special 'speedup' which is damped\n  // until it goes back to the normal\n  // speed.\n  speedupMomentum: true,\n\n  // if the puck hit momentum should affect\n  // the direction\n  directionMomentum: true,\n\n  // when true the collision reflection angle\n  // is based on the edge intersecting the\n  // centroid of the two colliding shapes instead\n  // of the `nearestEdge` guessed by `poly.collide()`.\n  // It may use a few more cycles on collision but\n  // makes the bouncing much more reliable.\n  improvedNormals: true,\n\n  // the amount we narrow down the angle of reflection\n  // with or without momentum.\n  // higher value means more narrow as it's a divisor\n  // of the position on the paddle.\n  steerWidth: 2,\n  steerWidthMomentum: 3,\n\n  fireballSpeedup: 1.5,\n\n  interpolationMaxFrames: 10,    // set to 0 to turn off\n  interpolationMinDistance: 1,   // distance in pixels\n  interpolationMaxDistance: 500, // distance in pixels\n\n  clearColor: 0xedecd6,\n  fireColor: 0xefce06,\n  fireColor2: 0xff0000,\n\n  //ambientLightColor: 0x444444,\n  //ambientLightIntensity: 0.40,\n  dirLightColor: 0xffffff,\n  dirLightIntensity: 0.88,\n  dirLightX: 0.107,\n  dirLightY: 0.15,\n  dirLightZ: 0.07,\n  hemisphereLightSkyColor: 0xffffff,\n  hemisphereLightGroundColor: 0xb1b1b1,\n  hemisphereLightIntensity:0.74,\n  useShadows:false,\n  arenaSurfaceY: -200,\n\n  hue: 0,\n  saturate: 100,\n  extraHue:0,\n  extraSaturate: 100,\n\n  quality: 'high',\n  overrideSpawnExtras: false,\n  spawnExtras: {\n    bulletproof: false,\n    mirroredcontrols: false,\n    fog: false,\n    extralife: false,\n    ghostball: false,\n    fireball: false,\n    multiball: false,\n    paddleresize: false,\n    timebomb: false,\n    laser: false,\n    deathball: false\n  },\n  testCPUMorph: -1,\n\n  // networking\n  keepAliveInterval: 250, // ms\n  sendRate: 15, // hz\n\n  // controls\n  mouseSensitivity: 0.07,\n  keyboardSensitivity: 0.9,\n  invertControls: false,\n\n  forrestPredefined:true,\n  forrestThreshold:0.5,\n  forrestGridX:200,\n  forrestGridY:200,\n  forrestBaseScale:0.5,\n  forrestRandomSeed:0.5\n}\n\n// [t,r,b,l]\nsettings.data.bounds = [0,settings.data.arenaWidth,settings.data.arenaHeight,0];\n\nsettings.emit('lightsUpdated');\n\nsettings.getSpawnlist = function(){\n  var list = [];\n  for (var key in settings.data.spawnExtras) {\n    if(settings.data.spawnExtras[key]){\n      list.push({id: key});\n    }\n  }\n  return list;\n}\n\nsettings.changeTheme = function(theme){\n  for( var key in theme ) {\n    if( settings.theme.hasOwnProperty(key) ){\n      settings.theme[key] = theme[key];\n    }\n  }\n  settings.emit('colorsUpdated');\n}\n\n//@ sourceURL=slam/lib/settings.js"
));
require.register("slam/lib/settings-gui.js", Function("exports, require, module",
"/* global dat: true, _gaq: true */\n\nvar settings = require('./settings')\n  , Themes = require('./themes')\n  , keys = require('mousetrap')\n  , $ = require('jquery');\n\nvar gui\n  , extraRows = [];\n\nvar CAMERA_TYPES = {\n  'Scripted (1)': 0,\n  'FPS (2)': 1,\n  'Classic (3)': 2,\n  'Rabbit Cam (4)': 3,\n  'Mountain View (5)': 4\n}\n\nexports.createGenericUI = function( initParams ) {\n  // dat.GUI is global, included in the HTML\n  gui = new dat.GUI({ autoPlace: false });\n  settings.gui = gui;\n\n  gui.width = 400;\n  document.getElementById('settingsDataGUI').appendChild(gui.domElement);\n\n  gui.domElement.addEventListener('click', logSettingsClick)\n\n  function logSettingsClick(){\n    gui.domElement.removeEventListener('click', logSettingsClick)\n    _gaq.push(['_trackEvent', 'settings', 'open']);\n  }\n\n  var f;\n\n  f = gui.addFolder('Generic');\n  f.add(exports,'shortcut','O').name('Show panels')\n  f.add(exports,'shortcut','0').name('Debug renderer')\n  f.add(exports,'shortcut','P').name('Add puck');\n  f.add(exports,'shortcut','E').name('Explode');\n  f.add(exports,'shortcut','H').name('Heal');\n  f.add(exports,'shortcut','M').name('Mirror effect');\n  f.add(settings.data, 'godMode').name('God mode');\n  f.add(settings.data, 'quality',{'High quality':'high','High performance':'low','Mobile':'mobile'}).onChange(function(value){\n    settings.data.quality = value;\n    this.emit('qualityChanged');\n  }.bind(this));\n  f.add(settings.data, 'framerate').min(1).max(120).name('Framerate (fps)').onChange(framerateUpdated)\n  f.add(settings.data, 'unitSpeed').min(1).max(120).name('Speed')\n\n  f = gui.addFolder('Camera');\n  f.add(settings.data, 'cameraType',CAMERA_TYPES).name('Mode').listen().onChange(function(value){\n    settings.data.cameraType = parseInt(value,10);\n    this.emit('cameraTypeChanged')\n  }.bind(this));\n  f.add(settings.data,'cameraOverlay').name('Overlay').onChange(function(){\n    this.emit('cameraSettingsChanged')\n  }.bind(this))\n  f.add(settings.data,'cameraFov').min(10).max(100).step(1).name('FOV').onChange(function(){\n    this.emit('cameraSettingsChanged')\n  }.bind(this))\n  f.add(settings.data,'cameraGrid').min(0).max(1).name('Scanlines').onChange(function(){\n    this.emit('cameraSettingsChanged')\n  }.bind(this))\n  f.add(exports, 'shortcut','C').name('Log position');\n\n\n  f = gui.addFolder('Theme');\n  this.themelist = {};\n  for (var i = Themes.list.length - 1; i >= 0; i--) {\n    this.themelist[Themes.list[i].name] = i\n  }\n\n  f.add(this,'themelist',this.themelist).name('Presets').onChange(function(value){\n    Themes.goto(parseInt(value,10)-1);\n  })\n\n  f.addColor(settings.theme, 'shieldColor').name('Shield color').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'puckColor').name('Puck').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'arenaColor').name('Arena').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'terrainColor1').name('Terrain1').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'terrainColor2').name('Terrain2').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'terrainColor3').name('Terrain3').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'treeBranchColor').name('Trees').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'iconColor').name('Icons').onChange(colorsUpdated);\n  f.addColor(settings.theme, 'cpuBackdropColor').name('CPU backdrop').onChange(colorsUpdated);\n  f.add(settings.theme, 'gridBrightness').min(0).max(1).name('Grid brightness').onChange(colorsUpdated);\n\n\n  if( initParams.isMobile ) {\n    f = gui.addFolder('Mobile Colors');\n    f.add(settings.data, 'hue').min(0).max(360).name('Hue').onChange(mobileColor);\n    f.add(settings.data, 'saturate').min(0).max(100).name('Saturate').onChange(mobileColor);\n    f.add(settings.data, 'extraHue').min(0).max(360).name('Extras Hue').onChange(mobileExtrasColor);\n    f.add(settings.data, 'extraSaturate').min(0).max(100).name('Extras Saturate').onChange(mobileExtrasColor);\n  }\n\n  f = gui.addFolder('Extras');\n  f.add(settings.data,'overrideSpawnExtras').name('override extras').onChange(setExtraStatus);\n  for (var key in settings.data.spawnExtras) {\n    extraRows[key] = f.add(settings.data.spawnExtras,key).name(key);\n  }\n  setExtraStatus()\n\n  f = gui.addFolder('Paddle');\n  f.add(settings.data, 'paddleMomentum').name('Use momentum');\n  f.add(settings.data, 'speedupMomentum').name('Momentum speedup');\n  f.add(settings.data, 'directionMomentum').name('Momentum direction');\n  f.add(settings.data, 'paddleMass').min(0).max(1).name('Mass');\n  f.add(settings.data, 'paddleDamping').min(0).max(1).name('Damping');\n  f.add(settings.data, 'keyboardSensitivity').min(0).max(100).name('Keyboard Sens.');\n  f.add(settings.data, 'mouseSensitivity').min(0).max(100).name('Mouse/Touch Sens.');\n\n  f = gui.addFolder('Forest');\n  f.add(settings.data, 'forrestThreshold').min(0).max(1).name('Amount');\n  f.add(settings.data, 'forrestGridX').min(50).max(500).name('Grid Size X');\n  f.add(settings.data, 'forrestGridY').min(50).max(500).name('Grid Size Y');\n  f.add(settings.data, 'forrestBaseScale').min(0).max(3).name('Base Scale');\n  f.add(settings.data, 'forrestRandomSeed').min(0).max(10).name('Groups/Random');\n  f.add(exports, 'createForrest').name('Generate');\n\n  f = gui.addFolder('Lights');\n  f.addColor(settings.data, 'dirLightColor').name('Dir color').onChange(lightsUpdated);\n  f.add(settings.data, 'dirLightIntensity').min(0).max(2).name('Dir').onChange(lightsUpdated);\n  f.add(settings.data, 'dirLightX').min(-1.01).max(1.01).listen().name('Dir pos X').onChange(lightsUpdated);\n  f.add(settings.data, 'dirLightY').min(0).max(1.01).listen().name('Dir pos Y').onChange(lightsUpdated);\n  f.add(settings.data, 'dirLightZ').min(-1.01).max(1.01).listen().name('Dir Pos Z').onChange(lightsUpdated);\n  f.addColor(settings.data, 'hemisphereLightSkyColor').name('Hemisphere Sky').onChange(lightsUpdated);\n  f.addColor(settings.data, 'hemisphereLightGroundColor').name('Hemisphere Ground').onChange(lightsUpdated);\n  f.add(settings.data, 'hemisphereLightIntensity').min(0).max(2).name('Hemisphere').onChange(lightsUpdated);\n\n  if( initParams.isNetwork ){\n    f = gui.addFolder('Networking');\n    f.add(settings.data, 'keepAliveInterval').min(16).max(1000).name('Keep Alive Interval (ms)');\n    f.add(settings.data, 'sendRate').min(1).max(60).name('Send Rate (hz)');\n\n    f = gui.addFolder('Interpolation');\n    f.add(settings.data, 'interpolationMaxFrames').min(0).max(120).name('Max frames (0=none)');\n    f.add(settings.data, 'interpolationMaxDistance').min(0).max(1000).name('Max distance diff (px/frame)');\n    f.add(settings.data, 'interpolationMinDistance').min(0).max(1000).name('Min distance diff (px/frame)');\n  }\n\n  gui.close();\n\n  settings.on('colorsUpdated',function(){\n    for (var i in gui.__folders['Theme'].__controllers) {\n      gui.__folders['Theme'].__controllers[i].updateDisplay();\n    }\n  })\n}\n\nfunction colorsUpdated() {\n  settings.emit('colorsUpdated');\n}\n\n\nfunction lightsUpdated( value ) {\n  settings.emit('lightsUpdated');\n}\n\nfunction mobileColor() {\n  var filter = 'hue-rotate('+settings.data.hue+'deg) saturate('+settings.data.saturate+'%)';\n  $('#canv-css .background')[0].style.webkitFilter = filter;\n}\n\nfunction mobileExtrasColor() {\n  var filter = 'hue-rotate('+settings.data.extraHue+'deg) saturate('+settings.data.extraSaturate+'%)';\n  $('#canv-css .extra').each( function(){\n    this.style.webkitFilter = filter;\n  })\n}\n\nfunction framerateUpdated(v){\n  settings.data.timestep = 1000/v;\n}\n\nfunction setExtraStatus() {\n  for (var key in extraRows) {\n    var item = extraRows[key];\n\n    if( !settings.data.overrideSpawnExtras ) {\n      item.domElement.lastChild.disabled = true;\n      item.domElement.parentNode.className='disabled';\n    }\n    else {\n      item.domElement.lastChild.disabled = false;\n      item.domElement.parentNode.className='';\n    }\n  }\n}\n\nexports.createForrest = function() {\n  settings.data.forrestPredefined = false;\n  settings.emit('generateForrest');\n}\n\nexports.shortcut = function(label){\n  keys.trigger(label.toLowerCase());\n}\n\n//@ sourceURL=slam/lib/settings-gui.js"
));
require.register("slam/lib/app.js", Function("exports, require, module",
"function noop(){}\nif(!window.console) { window.console = {log:noop,warn:noop,error:noop} }\nif(!window.console.time) { window.console.time = window.console.timeEnd = noop }\nif(!window.console.profile) { window.console.profile = noop }\nif(!window.console.group) { window.console.group = window.console.groupEnd = window.console.groupCollapsed = noop }\n\nconsole.groupCollapsed('load')\nconsole.time('load')\n\nvar debug = require('debug').enable(d('')) // <-- enable within d() (prefer using ?d=xyz)\n  , see = require('./support/see')\n  , states = require('./states')\n  , $ = require('jquery');\n\nsee('/',states.IO)\nsee('/',states.Mobile)\nsee('/',states.Setup) // game / network / audio / localization\nsee('/loading',states.Loading)\nsee('/main-menu',states.MainMenu)\nsee('/friend/invite',states.Friend.Invite)\nsee('/friend/waiting',states.Friend.Waiting)\nsee('/friend/accept',states.Friend.Accept)\nsee('/friend/arrived',states.Friend.Arrived)\nsee('/friend/left',states.Friend.Left)\nsee('/webcam/activate',states.Webcam.Activation)\nsee('/webcam/information',states.Webcam.Information)\nsee('/webcam/waiting',states.Webcam.Waiting) // (for friend to pick camera)\nsee('/game',states.Game.Input)\nsee('/game',states.Game.Multiplayer)\nsee('/game',states.Game.Verify)\nsee('/game',states.Game.Setup)        // Editor / Puppeteer / AI / mouse & keyboard controls\nsee('/game/instructions',states.Game.Instructions)\nsee('/game/wait',states.Game.Wait)    // (for friend to start game)\nsee('/game/start',states.Game.Start)  // setup game / create puck / create paddles / create shields\nsee('/game/play',states.Game.Play)    // unpause game\nsee('/game/next',states.Game.Next)    // update progress / distort screen / decide if game is really over\nsee('/game/pause',states.Game.Pause)  // show pause screen\nsee('/game/over',states.Game.Over)    // show winner!\nsee('/game/prompt',states.Prompt)     // show round prompt\nsee('/game/prompt/round',states.Prompt.Round)   // show round prompt\nsee('/game/prompt/level',states.Prompt.Level)   // show level prompt\nsee('/game/prompt/start',states.Prompt.Start)   // show level prompt\nsee('/game/prompt/over',states.Prompt.Over)     // show game over prompt\nsee('/game/invite',states.Friend.Invite)\nsee('/game/arrived',states.Friend.Arrived)\nsee('/game/cssinfo',states.Mobile.Info)\nsee('/game/over/cssinfo',states.Mobile.Info)\nsee('/cssinfo',states.Mobile.Info)\nsee('/error',states.Error)\nsee('/error/fullroom',states.Error.FullRoom)\nsee('/error/connection',states.Error.ConnectionError)\nsee('/error/datachannels',states.Error.DataChannels)\nsee('/error/browser',states.Error.Browser)\nsee('/error/lonelyroom',states.Error.Lonely)\n\nsee.on('enter',function(ctx,state){\n  var name = slug(ctx.pathname)||'setup'\n\n  if( name !== 'setup') {\n    _gaq.push(['_trackPageview', name]);\n  }\n\n  $('body').addClass(name);\n  $('.state.' + name).show().addClass('active enter');\n  setTimeout(function(){\n    $('.state.' + name).removeClass('inactive');\n  },4);\n  ctx.el = $('.state.' + name);\n})\n\nsee.on('leave',function(ctx,state){\n  var name = slug(ctx.pathname)||'setup'\n\n  $('body').removeClass(name);\n  var stateElem = $('.state.' + name).removeClass('active enter').addClass('inactive');\n  stateElem.each(function(){\n    if(!$(this).hasClass('animate') && $('.animate', $(this)).length < 1) {\n      $(this).hide();\n    }\n  })\n  ctx.el = $('.state.' + name);\n})\n\nsee.on('error',function(err){\n  console.error('see error:',err)\n})\n\nmodule.exports = function main(ctx){\n  // add query object to ctx\n  ctx.query = qs();\n  see.ctx(ctx)\n\n  setTimeout(function(){\n    see('/loading') // GO!\n  },4)\n}\n\nfunction slug(str){\n  return str.replace(/^\\//,'').replace(/[\\/ ]/g,'-');\n}\n\nfunction d(enabled){\n  if( enabled ) { return enabled; }\n  var m = /&?d=([^&]+)/g.exec(location.search);\n  if( m ){\n    return m[1].replace(/%20|\\+/g,' ');\n  } else {\n    return '';\n  }\n}\n\nfunction qs(){\n  var obj = {};\n  var query = window.location.search.substring(1);\n  var vars = query.split('&');\n  for (var i = 0; i < vars.length; i++) {\n    var pair = vars[i].split('=')\n      , key = decodeURIComponent(pair[0])\n      , val = decodeURIComponent(pair[1]);\n    obj[key] = val || true; // true so \"?x\"; if( query.x ){}\n  }\n  return obj;\n}//@ sourceURL=slam/lib/app.js"
));
require.register("slam/lib/game.js", Function("exports, require, module",
"var requestAnimationFrame = require('request-animation-frame')\n  , Emitter = require('emitter')\n  , debug = require('debug')('game')\n  , settings = require('./settings')\n  , World = require('./world')\n  , actions = require('./actions')\n  , physics = require('./sim/physics')\n  , Tick = require('./support/tick')\n  , now = require('now')\n  , AI = require('./ai');\n\n// Example usage:\n//  var g = new Game()\n//  g.actions.register({name:fn})\n//  g.run()\n\nmodule.exports = Game;\n\nfunction Game(name,renderer){\n  this.tick = new Tick();\n  this.world = new World(name,this.tick);\n  this.ai = new AI(name);\n\n  this.running = false;\n  this.paused = false;\n\n  this.on('update',physics.update)\n  this.on('update',this.ai.update.bind(this.ai))\n  this.on('update',this.tick.update.bind(this.tick))\n\n  renderer && this.setRenderer(renderer)\n}\n\nEmitter(Game.prototype);\n\nGame.prototype.reset = function(){\n  debug('reset %s',this.world.name)\n  this.world.reset();\n  if( this.renderer ){\n    this.renderer.reset();\n  }\n}\n\nGame.prototype.setRenderer = function(renderer){\n  debug('set renderer %s',this.world.name)\n  if( this.renderer ){\n    this.off('render')\n    actions.off('renderer')\n  }\n  this.renderer = renderer;\n  this.on('render',this.renderer.render.bind(this.renderer))\n  // redirect 'renderer'-events from actions to renderer.triggerEvent\n  actions.on('renderer',this.renderer.triggerEvent.bind(this.renderer))\n}\n\nGame.prototype.update = function(){\n  var ts = settings.data.timestep;\n  this.emit('pre update',this.world,ts)\n  this.emit('update',this.world,ts)\n  this.emit('post update',this.world,ts)\n}\n\nGame.prototype.render = function(){\n  this.emit('render',this.world,0);\n}\n\nGame.prototype.pause = function(){\n  debug('pause %s',this.world.name)\n  this.paused = true;\n}\n\nGame.prototype.resume = function(){\n  debug('resume %s',this.world.name)\n  this.paused = false;\n}\n\nGame.prototype.run = function(){\n  debug('run')\n\n  if( this.running ){\n    throw new Error('already running');\n  }\n\n  var currentTime = now()\n    , accumulator = 0.0\n    , game = this\n    , world = this.world;\n\n  function changevisibility( event ) {\n    if( document.hidden === false || document.webkitHidden === false ){\n      currentTime = now();\n    }\n  }\n  document.addEventListener( 'visibilitychange',changevisibility,false);\n  document.addEventListener( 'webkitvisibilitychange',changevisibility,false);\n\n  function loop(){\n    if( game.running ){\n      requestAnimationFrame(loop);\n    }\n    var timestep = settings.data.timestep;\n    var frameStart = now();\n    game.emit('enter frame',world);\n\n    if( !game.paused ){\n\n      var newTime = now()\n        , deltaTime = newTime - currentTime\n        , maxDeltaTime = timestep*settings.data.maxUpdatesPerFrame;\n      currentTime = newTime;\n\n      // note: max frame time to avoid spiral of death\n      if (deltaTime > maxDeltaTime){\n        console.warn('exceeding max deltatime ('+maxDeltaTime+'): '+deltaTime)\n        deltaTime = maxDeltaTime;\n      }\n\n      // update\n      var updatesStart = now();\n      accumulator += deltaTime;\n      while(accumulator >= timestep){\n        game.emit('pre update',world,timestep)\n        game.emit('update',world,timestep)\n        game.emit('post update',world,timestep)\n        accumulator -= timestep;\n        if( !game.running ){\n          break;\n        }\n      }\n      var updatesEnd = now();\n      if( updatesEnd - updatesStart > timestep ){\n        console.warn('slow update: '+(updatesEnd - updatesStart).toFixed(2)+'ms')\n      }\n\n      // render\n      var renderStart = now();\n      game.emit('render',world,accumulator/timestep);\n      var renderEnd = now();\n      if( renderEnd - renderStart > timestep ){\n        console.warn('slow render: '+(renderEnd - renderStart).toFixed(2)+'ms')\n      }\n    }\n\n    game.emit('leave frame',world);\n\n    var frameEnd = now();\n    if( frameEnd-frameStart > timestep ){\n      console.warn('slow frame: '+(frameEnd-frameStart).toFixed(2)+' ms\\n');\n    }\n  }\n  this.running = true;\n  loop();\n  return this;\n}//@ sourceURL=slam/lib/game.js"
));
require.register("slam/lib/network.js", Function("exports, require, module",
"var Emitter = require('emitter')\n  , NetChannel = require('netchan')\n  , TimeSync = require('./support/time-sync')\n  , base64 = require('base64-arraybuffer')\n  , debug = require('debug')('network')\n  // , debug = require('./support/logger')('network')\n  , rtc = require('./rtc');\n\nmodule.exports = Network;\n\nfunction Network(ctx){\n  this.context = ctx; // TODO not sure about this...\n  this.available = rtc.available;\n  this.pathname = null;\n  this.game = null; // will refer to the game channel when it's opened\n  this.winner = false;\n  this.ready = false;\n  this.connected = false;\n  this.challenge = null;\n  this.challenged = false;\n  this.attemptedStart = false;\n  this.sync = new TimeSync();\n}\n\nEmitter(Network.prototype)\n\nNetwork.prototype.setupRemote = function(opts){\n  debug('setup rtc')\n  if( !this.available ){\n    return console.warn('RTC not available. Skipping network');\n  }\n\n  var network = this\n    , ctx = this.context\n    , now = Date.now()\n    , sync = this.sync;\n\n  sync.on('done',function(latency){\n    debug('latency',latency)\n    ctx.latency = latency;\n    network.emit('change latency',latency)\n\n    // ok, we're ready!\n    if( !network.ready ){\n      network.ready = true;\n      network.emit('ready')\n    }\n  })\n\n  this.remote = rtc.connect(opts);\n  this.remote.on('addstream',this.emit.bind(this,'addstream'))\n  this.remote.on('removestream',this.emit.bind(this,'removestream'))\n  this.remote.on('connected',function(e){ // a peer has joined\n    debug('connected')\n    network.connected = true;\n    network.emit('change connected',true)\n    network.challenge = now + Math.random()\n    this.signal.send({type:'challenge',challenge:network.challenge})\n\n    // wrap `this.channels.game` in NetChannel\n    // and base64\n    network.game = netchan(this.channels.game,network);\n    network.game.onmessage = function(msg){\n      // debug('message',ab2s(msg)) // too noisy\n      if( sync.channel && !sync.onmessage(msg) ){\n        network.emit('message',msg)\n      }\n    }\n\n    // use the game channel for sending time sync\n    // requests\n    sync.channel = network.game;\n  })\n  this.remote.on('challenge request',function(e){\n    this.signal.send({type:'challenge',challenge:network.challenge})\n  })\n  this.remote.on('challenge',function(e){\n    debug('challenge (mine: %s, theirs: %s)',network.challenge,e.challenge)\n    if( network.challenge ){\n      network.challenged = true;\n      network.winner = e.challenge > network.challenge;\n      network.emit('change winner',network.winner)\n      debug('challenge winner?',network.winner)\n\n      // send the current state and when\n      // the remote current state is received\n      // the first time we are officially connected.\n      network.emit('state',ctx.pathname)\n\n      // if previously attempted a start try again now\n      // that we're successfully challenged\n      // TODO hmm this is backwards. the challenge is sent\n      // from the one who needs one\n      network.attemptedStart && network.start();\n    } else {\n      console.warn('challenge not set, not connected?')\n    }\n  })\n  this.remote.on('open',function(e){\n    debug('open')\n    network.emit('open',e)\n  })\n  this.remote.on('full',function(){\n    debug('full')\n    network.emit('full')\n  })\n  this.remote.on('disconnected',function(e){\n    debug('disconnected')\n    network.emit('disconnected',e)\n    network.close()\n    this.reconnect();\n  })\n  this.remote.on('error',function(e){\n    debug('error',e)\n    network.emit('error',e)\n  })\n  this.remote.on('state',function(e){\n    var initial = network.pathname;\n    debug('received state %s %s',e.pathname, initial === null ? '(connected)' : '')\n    network.pathname = e.pathname;\n    network.emit('change pathname',e.pathname)\n    if( initial === null ){\n      network.emit('connected',e)\n    }\n  })\n  this.remote.on('channel game open',function(e){\n    debug('channel game open',e)\n\n    ctx.multiplayer = true;\n    network.emit('change multiplayer',true)\n\n    // get the initial latency over the data channel\n    network.winner && sync.start()\n  })\n\n  network.on('state',function(pathname){\n    if( this.connected ){\n      this.remote.signal.send({type:'state',pathname:pathname})\n    }\n  })\n}\n\nNetwork.prototype.close = function(){\n  debug('close')\n  if( this.remote ){\n    this.remote.reconnect()\n  }\n  if( this.game ){\n    this.game.onmessage = null;\n    this.game = null;\n  }\n  this.connected = false;\n  this.challenged = false;\n  this.attemptedStart = false;\n  this.context.multiplayer = false;\n  this.ready = false;\n  this.pathname = null;\n  this.winner = false;\n  this.sync.stop()\n  this.sync.channel = null;\n  this.emit('change connected',false)\n  this.emit('change multiplayer',false)\n}\n\nNetwork.prototype.send = function(msg){\n  debug('send',ab2s(msg))\n  if( this.game && this.ready ){\n    this.game.send(msg);\n  } else {\n    console.warn('sending a message too early (game channel not open)')\n  }\n}\n\nNetwork.prototype.start = function(){\n  debug('start %s',this.winner ? '(winner)' : '')\n\n  if( !this.challenged && this.challenge ){\n    this.attemptedStart = true;\n    this.remote.signal.send({type:'challenge request'})\n  }\n\n  // winner gets to send the first offer!\n  this.winner && this.remote.start()\n}\n\nvar NETCHAN_PREFIX = '';\n\nfunction netchan(channel,network,skipBase64){\n  // since data channels don't support binary yet\n  // we encode the sent message as base64\n  if( !skipBase64 ){\n    var _recv = NetChannel.prototype.recv;\n    NetChannel.prototype.recv = function(e){\n    // var _recv = channel.onmessage;\n    // channel.onmessage = function(e){\n      // MessageEvent#data is not writable\n      // so we create a new one\n      if( typeof e.data == 'string' && e.data.indexOf(NETCHAN_PREFIX) == 0 ){\n        var m = new MessageEvent('message',{\n          data: base64.decode(e.data.slice(NETCHAN_PREFIX.length)),\n          origin: e.origin,\n          lastEventId: e.lastEventId,\n          source: e.source,\n          ports: e.ports\n        })\n        // console.log('netchan recv',new Uint8Array(m.data))\n        return _recv.call(this,m);\n      } else if( typeof e.data != 'string' ){\n        return _recv.call(this,e);\n\n      } else {\n        // console.log('netchan recv (skipping, not encoded)')\n      }\n    }\n    // RTCDataChannel is not a public constructor\n    // so we take the one from the instance.\n    // var DataChannel = channel.constructor;\n    // var _send = DataChannel.prototype.send;\n    // DataChannel.prototype.send = function(msg){\n    var _send = channel.send;\n    channel.send = function(msg){\n      if( typeof msg != 'string' ){\n        // console.log('netchan send',new Uint8Array(msg))\n        msg = NETCHAN_PREFIX+base64.encode(msg);\n      }\n      if( msg.length > 1168 ){\n        var err = new Error('message too long: '+msg.length);\n        err.code = 1168;\n        network.emit('error',err)\n        return;\n      }\n      if( channel.readyState == 'open' ){\n        return _send.call(this,msg);\n      } else {\n        console.warn('tried to send message (%s) on closed channel \"%s\"',msg,channel.label)\n      }\n    }\n  }\n  // return channel;\n  return new NetChannel(channel,{ack: true})\n}\n\n\n\nvar join = [].join;\nfunction ab2s(buf){\n  return join.call(new Uint8Array(buf));\n}//@ sourceURL=slam/lib/network.js"
));
require.register("slam/lib/extra-icons.js", Function("exports, require, module",
"// actions.emit('extras changed',world)\n\n\n// fog:\n//    multiple: false\n//    show: when icon is in arena\n//          (if there is a new extra w. data.id == fog in world.extras)\n//    active: when icon has been hit\n//          (while world.timeouts.fog exists)\n//    remove: when fog has timed out or icon has been removed from arena or round is over\n//          (when no extra w data.id == fog or world.timeouts.fog does not exist anymore)\n//\n// deathball:\n//    multiple: false\n//    show: when icon is in arena\n//          (if there is a new extra w. data.id == deathball in world.extras)\n//    active: when icon is in arena\n//          (same as show)\n//    remove: when icon has been removed from arena or round is over\n//          (when no extra w data.id == deathball exist anymore)\n//\n// ghostball:\n//    multiple: true (while multiball)\n//    show: when icon is in arena\n//          (if there is a new extra w. data.id == ghostball in world.extras)\n//    active: when icon has been hit\n//          (while theres a puck with data.ghostballTimeout)\n//    remove: when ghost has timed out or icon has been removed from arena or round is over\n//          (when no puck w data.ghostballTimeout or extra w. data.id == ghostball exist anymore)\n//\n// paddleresize:\n//    multiple: true\n//    show: when icon is in arena\n//          (if there is a new extra w. data.id == paddleresize in world.extras)\n//    active: when icon has been hit\n//          (if there is a new extra w. data.id == paddleresize in world.extras)\n//    remove: when paddleresize has timed out or icon has been removed from arena or round is over\n//\n// multiball:\n//    multiple: true\n//    show: when icon is in arena\n//    active: when icon has been hit\n//    remove: when icon has been removed from arena or round is over\n//\n// extralife:\n//    multiple: false\n//    show: when icon is in arena\n//    active: never\n//    remove: when icon has been hit or round is over\n//\n// timebomb:\n//    multiple: true\n//    show: when icon is in arena\n//    active: when icon has been hit\n//    remove: when timebomb explodes or icon has been removed from arena or round is over\n//\n// fireball:\n//    multiple: true\n//    show: when icon is in arena\n//    active: never\n//    remove: when icon has been hit or round is over\n//\n//  laser:\n//    multiple: false\n//    show: when icon is in arena\n//    active: when icon has been hit\n//    remove: when laser is over or round is over\n//\n//  mirroredcontrols:\n//    multiple: false\n//    show: when icon is in arena\n//    active: when icon has been hit\n//    remove: when round is over or another mirroredcontrols icon has been hit\n//\n//  bulletproof:\n//    multiple: false\n//    show: when icon is in arena\n//    active: when icon has been hit\n//    remove: when bulletproof has timed out or round is over\n//\n//\n\nvar debug = require('debug')('extra-icons')\n  , $ = require('jquery');\n\nvar container = $('#extras ul');\nvar clonables = container.children().detach();\nvar available = [];\nvar inUse = null;\n\nexports.use = function(world){\n  inUse = world;\n}\n\nexports.clear = function(){\n  container.empty();\n  available.length = 0;\n}\n\nexports.create = function(world,extra){\n  if( world !== inUse ) return\n  var id = extra.data.id;\n  debug('create',id)\n  var element = clonables.filter('.'+id).clone();\n  setTimeout(function(element){\n    element.addClass('visible')\n  }.bind(null,element), 400)\n  available.push({\n    index: extra.index,\n    id: id,\n    element: element\n  });\n  container.append(element)\n  redistribute()\n}\n\nexports.activate = function(world,extra){\n  if( world !== inUse ) return\n  debug('activate',extra)\n  var element = find(extra);\n  if( element ){\n    element.addClass('active')\n  } else {\n    console.warn('missing icon for extra',extra)\n  }\n}\n\nexports.remove = function(world,extra){\n  if( world !== inUse ) return\n  debug('remove',extra)\n  var element = find(extra);\n  if( element ){\n    element.removeClass('active visible')\n    setTimeout(function(element){\n      element.remove()\n    }.bind(null,element), 400)\n    remove(element)\n    redistribute()\n  } else {\n    console.warn('missing icon for extra',extra)\n  }\n}\n\nfunction find(k){\n  k = k.index || k;\n  for(var i=0; i<available.length; i++){\n    var a = available[i];\n    if( a.index === k ){\n      return a.element;\n    }\n    if( a.id === k ){\n      return a.element;\n    }\n  }\n  return null;\n}\n\nfunction remove(element){\n  for(var i=0; i<available.length; i++){\n    var a = available[i];\n    if( a.element === element ){\n      available.splice(i,1);\n      return true\n    }\n  }\n  return false;\n}\n\nfunction redistribute(){\n  var top = 0;\n  var h = 50; // TODO hard coding!\n  for(var i=0; i<available.length; i++){\n    var a = available[i];\n    a.element.css('top',top);\n    top += h;\n  }\n}//@ sourceURL=slam/lib/extra-icons.js"
));
require.register("slam/lib/world.js", Function("exports, require, module",
"var debug = require('debug')('world')\n  , stash = require('stash')\n  , copy = require('copy')\n  , Body = require('./sim/body')\n  , BodyFlags = require('./sim/body-flags')\n  , Random = require('./support/rand')\n  , hashCode = require('./support/hash-code')\n  , exclude = require('./support/exclude')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec;\n\nmodule.exports = World;\n\n// states\nWorld.INIT = 'init';         // no level, no controls, no physics, no network\nWorld.PREVIEW = 'preview';   // level inactive, controls, physics, no network\nWorld.STARTING = 'starting'; // level inactive, no controls, no physics, no network\nWorld.PLAYING = 'playing';   // level active, controls, physics, network\nWorld.PAUSED = 'paused';     // level inactive, no controls, no physics, no network\nWorld.NEXT_ROUND = 'next round'; // level inactive, no controls, no physics, no network\nWorld.NEXT_LEVEL = 'next level'; // level inactive, no controls, no physics, no network, score reset\nWorld.GAME_OVER = 'game over';   // level inactive, no controls, no physics, no network, score reset\n\n// temporary properties to be\n// excluded in hash code and diff\nWorld.EXCLUDED = ['me','opponent','name','hashCode'];\n\nfunction World(name,tick){\n  debug('%s create',name)\n  this.frame = 0;\n  this.index = 0;\n  this.name = name;\n  this.tick = tick;\n\n  // keep a seeded random for the world!\n  // (don't use World#rand, use World#random() instead)\n  this.rand = new Random(seed());\n\n  this.bodies = stash();   // all bodies will be collided in physics\n  this.pucks = stash();\n  this.extras = stash();\n  this.forces = stash();\n  this.bullets = stash();\n  this.paddles = stash();\n  this.shields = stash();\n  this.obstacles = stash();\n\n  this.lastHitPucks = {}; // used to look up which paddle a puck hit last\n  this.puckBounces = {};  // used to look up how many bounces a puck has\n  this.timeouts = {};\n  this.state = World.INIT;\n\n  this.level = null;        // states/game.js setupLevels()\n  this.me = null;           // states/game.js createGame()\n  this.opponent = null;     // states/game.js createGame()\n  this.multiplayer = false; // states/game.js Setup.enter()\n\n  this.players = {\n    a: new Player('HAL (A)'),\n    b: new Player('EVE (B)')\n  }\n}\n\nWorld.prototype.code = function(){\n  debug('hash code',World.EXCLUDED)\n  var hash;\n  exclude(this,World.EXCLUDED,function(world){\n    hash = hashCode(world)\n  })\n  return hash;\n}\n\nWorld.prototype.setState = function(state){\n  debug('%s set state',this.name,state)\n  switch(state){\n    case World.INIT:\n    case World.PREVIEW:\n    case World.STARTING:\n    case World.PLAYING:\n    case World.PAUSED:\n    case World.NEXT_ROUND:\n    case World.NEXT_LEVEL:\n    case World.GAME_OVER:\n      this.state = state;\n      break;\n    default:\n      throw new Error('invalid world state: '+state)\n  }\n}\n\nWorld.prototype.random = function(){\n  return this.rand.random()\n}\n\nWorld.prototype.createBody = function(shape,x,y,flags){\n  debug('%s create body',this.name,this.index);\n  var body = Body.alloc();\n  body.index = this.index++;\n  body.shape = shape;\n  body.current[0] = body.previous[0] = x;\n  body.current[1] = body.previous[1] = y;\n  BodyFlags.set(body,flags);\n  this.bodies.set(body.index,body);\n  move(body.shape,body.current);\n  body.aabb = poly.aabb(shape,body.aabb);\n  body.radius = poly.radius(shape)\n  return body;\n}\n\n/**\n * Marks the body for removal in the collision\n * loop and in the renderer.\n *\n * @param {Body} body\n */\nWorld.prototype.releaseBody = function(body){\n  debug('%s release body',this.name,body.index)\n  body.removed = true\n  return body;\n}\n\n/**\n * Frees and removes the body from the\n * physics.\n *\n * Should only be called outside of `oncollision()`\n * since it will be removed from the bodies array\n * and the collision loop may go bananas.\n *\n * If a body is removed _inside_ the collision\n * loop use `releaseBody()`. It will be destroyed\n * then after the loop.\n *\n * @param {Body} body\n */\nWorld.prototype.destroyBody = function(body){\n  debug('%s destroy body',this.name,body.index)\n  if( !body.removed ){\n    this.releaseBody(body)\n  }\n  this.bodies.del(body.index)\n  Body.free(body)\n}\n\nWorld.prototype.copy = function(from){\n  debug('%s copy',this.name,from.name)\n\n  if( !(from instanceof World) ){\n    throw new Error('World instance expected');\n  }\n\n  // must set index first for createBody to create the correct body...\n  this.frame = from.frame;\n  this.index = from.index;\n\n  // copy (and remove) timeouts\n  copy(from.tick,this.tick,true);\n\n  copyBodies(this,from.bodies,this.bodies)\n  copyBodies(this,from.pucks,this.pucks)\n  copyBodies(this,from.extras,this.extras)\n  copyBodies(this,from.obstacles,this.obstacles)\n  copyBodies(this,from.bullets,this.bullets)\n  copyBodies(this,from.paddles,this.paddles)\n  copyBodies(this,from.shields,this.shields)\n\n  this.forces.copy(from.forces)\n\n  // copy the random state\n  this.rand.state = from.rand.state;\n\n  this.lastHitPucks = copy(from.lastHitPucks,this.lastHitPucks,true)\n  this.puckBounces = copy(from.puckBounces,this.puckBounces,true)\n  this.timeouts = copy(from.timeouts,this.timeouts,true)\n\n  this.level = copy(from.level,this.level,true);\n  this.state = from.state;\n  this.multiplayer = from.multiplayer;\n\n  this.players.a.copy(from.players.a)\n  this.players.b.copy(from.players.b)\n}\n\nWorld.prototype.reset = function(){\n  debug('%s reset',this.name)\n  this.frame = 0;\n  this.index = 0;\n\n  this.tick.reset();\n\n  this.rand = new Random(seed(this.level && this.level.index));\n\n  for(var i=this.bodies.length-1; i >= 0; i--){\n    this.destroyBody(this.bodies.values[i]);\n  }\n\n  this.obstacles.empty();\n  this.pucks.empty();\n  this.forces.empty();\n  this.bullets.empty();\n  this.paddles.empty();\n  this.shields.empty();\n  this.extras.empty();\n\n  // TODO would it be better to loop/delete?\n  this.lastHitPucks = {}\n  this.puckBounces = {}\n  this.timeouts = {};\n\n  var resetScores = this.state === World.GAME_OVER\n                 || this.state === World.NEXT_LEVEL;\n\n  this.players.a.reset(resetScores);\n  this.players.b.reset(resetScores);\n\n  return this;\n}\n\n// default player object\nfunction Player(name){\n  this.name = name\n  this.shields = []   // shields down (should be set to [1,1,1] on round start and if first one is hit it will turn into [0,1,1] etc)\n  this.score = 0      // rounds won\n  this.paddle = -1    // set in Simulator#create, an index to a paddle\n  this.wins = 0\n  this.hit = -1;      // was this player hit?\n}\nPlayer.prototype.copy = function(from){\n  this.name = from.name;\n  this.score = from.score;\n  this.paddle = from.paddle;\n  this.wins = from.wins;\n  this.hit = from.hit;\n  copy(from.shields,this.shields)\n}\nPlayer.prototype.reset = function(resetScores, resetWins){\n  this.shields.length = 0;\n  if( resetScores ){\n      this.score = 0;\n  }\n  if( resetWins ){\n    this.wins = 0;\n  }\n  this.hit = -1;\n  this.paddle = -1;\n  return this;\n}\n\n// extend Stash with a copy method\nstash.Stash.prototype.copy = function(from){\n  copy(from.values,this.values,true)\n  copy(from.lookup,this.lookup,true)\n  copy(from.reverse,this.reverse,true)\n  this.length = from.length;\n}\n\n// extend Stash with a custom hashCode method\nstash.Stash.prototype.hashCode = function(){\n  // create an object from the values\n  var obj = {}; // TODO reuse object?\n  for(var k in this.lookup){\n    obj[k] = this.values[this.lookup[k]];\n  }\n  return hashCode(obj)\n}\n\n// copyBodies(this,from.bodies,this.bodies)\nfunction copyBodies(world,from,to){\n\n  // var keysFrom = Object.keys(from.lookup).sort().join(',')\n  // var keysTo = Object.keys(to.lookup).sort().join(',')\n\n  // if( keysFrom !== keysTo ){\n  //   console.log('the bodies has changed')\n  //   console.log('  from:',keysFrom)\n  //   console.log('  to:',keysTo)\n  // }\n\n  for(var i=0; i<from.length; i++){\n    var a = from.values[i]\n      , b;\n\n    if( !a ){\n      throw new Error('invalid stash!')\n    }\n\n    // check existance\n    if( !to.has(a.index) ){\n      // the body has been removed\n      // since sync. re-add it.\n\n\n      // it might have been added to\n      // bodies already, in which case\n      // use that one\n      if( world.bodies.has(a.index) ){\n        b = world.bodies.get(a.index);\n        to.set(b.index,b);\n\n      // if not we need to recreate it\n      } else {\n        // make a clone of a (properties will be copied below)\n        b = Body.alloc()\n        b.index = a.index\n        to.set(b.index,b);\n      }\n\n      // verify it got that index\n      if( b.index !== a.index ){\n        throw new Error('wrong index')\n      }\n\n    // it's there!\n    } else {\n      b = to.get(a.index);\n\n    }\n\n    if( !to.has(a.index) ){\n      throw new Error('body was never created')\n    }\n\n    var pa = a.data.id;\n    var pb = b.data.id;\n\n    // copy properties\n    copy(a,b,true);\n\n\n    if( a.data.id !== b.data.id ){\n      console.error('data.id did not get copied before: %s,%s after: %s,%s',pa,pb,a.data.id,b.data.id)\n    }\n  }\n\n  // slow way of finding the difference and destroy it\n  // at this point there should always be more `from` than `to`\n  // because `to` is ahead of `from` and may have removed a body\n  // that `from` hasn't.\n  if( from.length !== to.length ){\n    var del = [];\n    for(var i=0; i<to.length; i++){\n      var b = to.values[i];\n      if( !from.has(b.index) && !~del.indexOf(b.index) ){\n        del.push(b.index);\n      }\n    }\n    // actually delete outside of loop\n    while(del.length){\n        // console.log('deleting %s from `to` index',b.index)\n      to.del(del.pop());\n    }\n  }\n\n  if( from.length !== to.length ){\n    throw new Error('bodies does not match!')\n  }\n}\n\nfunction move(shape,to){\n  var c = poly.centroid(shape)\n  var d = vec.sub(to,c)\n  poly.translate(shape, d[0] ,d[1]);\n  vec.free(c)\n  vec.free(d)\n}\n\n// [t,r,b,l]\nfunction center(aabb){\n  return vec.make(aabb[3]+(aabb[1]-aabb[3])/2,aabb[0]+(aabb[2]-aabb[0])/2)\n}\n\n\n// generate seed from pathname\nfunction seed(extra){\n  return location.pathname.split('')\n    .map(function(c){return c.charCodeAt(0)})\n    .reduce(function(s,c){return s+c},extra||0)*location.pathname.length;\n}\n//@ sourceURL=slam/lib/world.js"
));
require.register("slam/lib/arb.js", Function("exports, require, module",
"/*\n * Copyright 2012 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Application Resource Bundle (ARB) supporting library.\n * This library provides a set of API to access resource stored in ARB and\n * methods to localize the HTML DOM tree using those resources.\n * @author shanjian@google.com (Shanjian Li)\n */\n\n\n/**\n * Creates arb namespace.\n */\nvar arb = {};\n\n\n/**\n * This is the global resource selector that can be used to switch locale,\n * scheme, etc. globally. Empty string is a valid value that means no global\n * selector.\n * @type {string}\n * @private\n */\narb.resourceSelector_ = '';\n\n\n/**\n * Sets resource selector. This will affect all future resource selection.\n *\n * @param {string} selector resource selection string joined by ':'.\n */\narb.setResourceSelector = function(selector) {\n  arb.resourceSelector_ = selector;\n};\n\n\n/**\n * DOM text node type.\n */\narb.TEXT_NODE_TYPE = 3;\n\n\n/**\n * Cross-browser function for setting the text content of an element.\n * Code is borrowed from Closure.\n *\n * @param {Element} element The element to change the text content of.\n * @param {string} text The string that should replace the current element\n *     content.\n * @private\n */\narb.setTextContent_ = function(element, text) {\n  if ('textContent' in element) {\n    element.textContent = text;\n  } else if (element.firstChild &&\n             element.firstChild.nodeType == arb.TEXT_NODE_TYPE) {\n    // If the first child is a text node we just change its data and remove the\n    // rest of the children.\n    while (element.lastChild != element.firstChild) {\n      element.removeChild(element.lastChild);\n    }\n    element.firstChild.data = text;\n  } else {\n    var child;\n    while ((child = element.firstChild)) {\n      node.removeChild(child);\n    }\n    element.appendChild(element.ownerDocument.createTextNode(text));\n  }\n};\n\n\n/**\n * Performs message substitution in DOM tree.\n */\narb.localizeHtml = function() {\n  var resource = arb.getResource();\n  arb.localizeSubtree(document, resource);\n};\n\n\n/**\n * Localizes a DOM subtree start from given elem.\n *\n * @param {Document | Element} elem the root of the subtree to be visited.\n * @param {Object.<string, string|Object>} resource ARB resource object.\n */\narb.localizeSubtree = function(elem, resource) {\n  if (elem) {\n    var origResource = resource;\n    // If namespace is specified in the element, use it in its scope.\n    if (elem.getAttribute && elem.getAttribute('arb:namespace')) {\n      resource = arb.getResource(elem.getAttribute('arb:namespace')) ||\n          resource;\n    }\n\n    // If no resource specified, don't do anything. There is nothing wrong\n    // about it. A page can choose to skip localization this way.\n    if (resource) {\n      arb.localizeNode(elem, resource);\n      for (var i = 0; i < elem.childNodes.length; i++) {\n        var child = elem.childNodes[i];\n        arb.localizeSubtree(child, resource);\n      }\n    }\n    resource = origResource;\n  }\n};\n\n\n/**\n * Localizes a DOM element. Different type of element has different type of\n * attribute to be localized, not necessarily text content.\n *\n * @param {Document | Element} elem the DOM element to be localized.\n * @param {Object.<string, string|Object>} resource resource bundle.\n */\narb.localizeNode = function(elem, resource) {\n  var resId = elem.getAttribute && elem.getAttribute('arb:id') || elem.id;\n\n  if (!resId) {\n    return;\n  }\n\n  switch(elem.nodeName) {\n    case 'IMG':\n      arb.localizeElement_(elem, resId, resource, ['src', 'alt']);\n      break;\n    case 'INPUT':\n      arb.localizeElement_(elem, resId, resource,\n                           ['value', 'placeholder', 'defaultValue']);\n      break;\n    case 'AREA':\n      arb.localizeElement_(elem, resId, resource, ['alt']);\n      break;\n    case 'OBJECT':\n      arb.localizeElement_(elem, resId, resource, ['standby']);\n      break;\n    case 'OPTION':\n      arb.localizeElement_(elem, resId, resource, ['value', 'label']);\n      break;\n    case 'OPTGROUP':\n      arb.localizeElement_(elem, resId, resource, ['label']);\n      break;\n    case 'STYLE':\n      if (resId in resource) {\n        if (elem.styleSheet) {\n          elem.styleSheet.cssText = resource[resId];\n        } else {\n          arb.setTextContent_(elem, resource[resId]);\n        }\n      }\n      break;\n    default:\n      (resId in resource) && arb.setTextContent_(elem, resource[resId]);\n  }\n};\n\n\n/**\n * Injects localized resource into element's attribute.\n *\n * @param {Element} elem the DOM element that need to have resource injected.\n * @param {string} resId ARB resource id.\n * @param {Object.<string, string|Object>} resource  ARB resource bundle.\n * @param {Array.<string>} attrs possible attributes in this element that may\n *     take localization resource.\n * @private\n */\narb.localizeElement_ = function(elem, resId, resource, attrs) {\n  for (var i = 0; i < attrs.length; i++) {\n    var fieldId = resId + '@' + attrs[i];\n    (fieldId in resource) && (elem[attrs[i]] = resource[fieldId]);\n  }\n};\n\n\n/**\n * Replaces placeholder in string with given values. For the time being\n * {} is used to mark placeholder. Placeholder will only be replaced if\n * a named argument or positional argument is available.\n *\n * @param {string} str message string possibly with placeholders.\n * @param {string} opt_values if it is a map, its key/value will be\n *     interpreted as named argument. Otherwise, it should be interpreted as\n *     positional argument.\n * @return {string} string with placeholder(s) replaced.\n */\narb.msg = function(str, opt_values) {\n  // Plural support is an optional feature. When it is desired, developer\n  // should include arbplural.js, where arb.processPluralRules_ is defined.\n  if (arb.processPluralRules_) {\n    str = arb.processPluralRules_(str, opt_values);\n  }\n  var type = typeof opt_values;\n  if (type == 'object' || type == 'function') {\n    for (var key in opt_values) {\n      var value = ('' + opt_values[key]).replace(/\\$/g, '$$$$');\n      str = str.replace(new RegExp('\\\\{' + key + '\\\\}', 'gi'), value);\n    }\n  } else {\n     for (var i = 1; i < arguments.length; i++) {\n       str = str.replace(\n           new RegExp('\\\\{' + (i - 1) + '\\\\}', 'g'), arguments[i]);\n     }\n  }\n  return str;\n};\n\n\n/**\n * Resource name part as it appears in regular expression.\n * @type {number}\n * @private\n */\narb.RESOURCE_NAME_PART_ = 1;\n\n\n/**\n * Obtains the resouce name from URL. That will allow resource to be selected\n * through use of url parameter.\n *\n * @return {string} arb name as passed in Url.\n */\narb.getParamFromUrl = function(paramName) {\n  var regex = new RegExp('[\\\\\\\\?&]' + paramName + '=([^&#]*)', 'i');\n  var m = regex.exec(window.location.href);\n  return m ? m[arb.RESOURCE_NAME_PART_] : null;\n};\n\n\n/**\n * Maps ARB namespace into ARB instance.\n * @type {Object.<string, Object>}\n * @private\n */\narb.resourceMap_ = {};\n\n\n/**\n * Checks if an object is empty or not.\n *\n * @param  {Object} obj An object to be checked for emptiness.\n * @return {boolean} true if the object has not direct properties.\n * @private\n */\narb.isEmpty = function(obj) {\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Namespace delimiter.\n * @type {string}\n * @private\n */\narb.NAMESPACE_DELIMITER_ = ':';\n\n\n/**\n * Registers a ARB resource object.\n *\n * @param {string|array.string} namespaces ARB resource object's namespaces.\n *     This parameter can be either a string or an array, the later allows a\n *     resource to be registered under different names.\n * @param {Object.<string, string|Object>} resource ARB resource object.\n */\narb.register = function(namespaces, resource) {\n  if (typeof namespaces == 'string') {\n    arb.resourceMap_[namespaces] = resource;\n  } else {\n    for (var i = 0; i < namespaces.length; i++) {\n      arb.resourceMap_[namespaces[i]] = resource;\n    }\n  }\n};\n\n\n/**\n * Calls the callback for all the registerd namespace/locale pairs. This\n * function only iterates through fully qualified namespaces.\n *\n * @param {function(string)} arbCallback\n */\narb.iterateRegistry = function(arbCallback) {\n  for (var namespace in arb.resourceMap_) {\n    if (arb.resourceMap_.hasOwnProperty(namespace)) {\n      arbCallback(namespace);\n    }\n  }\n};\n\n\n/**\n * Retrieves ARB resource object that best fits selector given. The algorithm\n * of this method tries to satisfy the selector as much as possible, and does\n * it in the specified priority. Selector given to this method takes priority\n * over global resource selector set through \"setResourceSelector\".\n *\n * @param {?string} opt_selector resource selector used to choose desired ARB\n *        resource object together with global resource selector.\n *\n * @return {Object.<string, string|Object>} The ARB resource object desired.\n *     or empty object if no ARB resource object registered with given\n *     namespace.\n */\narb.getResource = function(opt_selector) {\n  var candidates = arb.resourceMap_;\n  if (!opt_selector) {\n    opt_selector = arb.resourceSelector_;\n  } else if (arb.resourceSelector_) {\n    opt_selector += arb.NAMESPACE_DELIMITER_ + arb.resourceSelector_;\n  }\n\n  // If opt_namespace is not given, default namespace will be used.\n  if (opt_selector) {\n    // This will only be true if opt_namespace is fully qualified.\n    if (opt_selector in arb.resourceMap_) {\n        return arb.resourceMap_[opt_selector];\n    }\n\n    var parts = opt_selector.split(arb.NAMESPACE_DELIMITER_);\n    for (var i = 0; i < parts.length; i++) {\n      var newCandidates = {};\n      var pattern = new RegExp('(:|^)' + parts[i] + '(:|$)');\n      for (var namespace in candidates) {\n        if (pattern.test(namespace)) {\n          newCandidates[namespace] = candidates[namespace];\n        }\n      }\n      if (!arb.isEmpty(newCandidates)) {\n        candidates = newCandidates;\n      }\n    }\n  }\n\n  var minLength = Number.MAX_VALUE;\n  var bestNamespace = '';\n  for (var namespace in candidates) {\n    if (!namespace) { // empty string\n      bestNamespace = namespace;\n      break;\n    }\n    var len = namespace.split(arb.NAMESPACE_DELIMITER_).length;\n    if (len < minLength) {\n      minLength = len;\n      bestNamespace = namespace;\n    }\n  }\n\n  if (arb.resourceMap_.hasOwnProperty(bestNamespace)) {\n    return arb.resourceMap_[bestNamespace];\n  }\n  return {};\n};\n\n/**\n * Checks if the given arb instance is in compact form.\n *\n * @param {Object.<string, string|Object>} resource ARB resource object.\n * @return {boolean} true if it is in compact form.\n */\narb.isCompact = function(resource) {\n  for (var prop in resource) {\n    if (resource.hasOwnProperty(prop) && prop[0] == '@') {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * Creates namespace for development mode methods.\n */\narb.dbg = {};\n\n\n/**\n * Returns type of data as identified by resource id.\n * The type information might not be available for specified resource. Empty\n * string will be returned in such case.\n *\n * @param {Object.<string, string|Object>} resource ARB resource object.\n * @param {string} resId resource id.\n *\n * @return {string} type string if available, or empty string.\n */\narb.dbg.getType = function(resource, resId) {\n  if (resId.charAt(0) == '@') {\n    return 'attr';\n  }\n  var atResId = '@' + resId;\n  if (resource.hasOwnProperty(atResId) &&\n      resource[atResId].hasOwnProperty('type')) {\n    return resource[atResId]['type'];\n  }\n  return '';\n};\n\n\n/**\n * Checks if the resource identified by resId is in given context. If the\n * resource has no context or if the desired context is the prefix of\n * resource's context, it will return true as well.\n *\n * @param {Object.<string, string|Object>} resource ARB resource object.\n * @param {string} resId resource id to be checked.\n * @param {string} context context desired.\n *\n * @return {boolean} true if the resource is in given context.\n */\narb.dbg.isInContext = function(resource, resId, context) {\n  var contextRegex = new RegExp('^' + context + '($|:.*)');\n  var atResId = '@' + resId;\n  return resId.charAt(0) != '@' &&\n      (!resource.hasOwnProperty(atResId) ||\n       !resource[atResId].hasOwnProperty('context') ||\n       contextRegex.test(resource[atResId]['context']));\n};\n\n\n/**\n * Returns the value of an attribute for a resource. Empty string will\n * be returned if attribute is not available.\n *\n * @param {Object.<string, string|Object>} resource ARB resource object.\n * @param {string} resId id of the resource to be checked.\n * @param {string} attrName attribute name of interest.\n *\n * @return {string} attribute value desired, or empty string.\n */\narb.dbg.getAttr = function(resource, resId, attrName) {\n  var atResId = '@' + resId;\n  if (!resource.hasOwnProperty(atResId)) {\n    return '';\n  }\n\n  var msgAttr = resource[atResId];\n  return msgAttr.hasOwnProperty(attrName) ? msgAttr[attrName] : '';\n};\n\n/*\n * Copyright 2012 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Application Resource Bundle (ARB) plural support library.\n * This file contains data and methods to provide plural support in ARB\n * message substitution. Plural rules are based on the latest CLDR(1.9)\n * release. It should cover all the languages available in CLDR.\n *\n * @author shanjian@google.com (Shanjian Li)\n */\n\n\n/**\n * Regular expression to identify plural message.\n * @type {RegExp}\n * @private\n */\narb.PLURAL_RULE_REGEX_ = /^\\{\\s*(\\w+)\\s*,\\s*plural\\s*,(\\s*offset:(\\d+))?\\s*/;\n\n\n/**\n * The locale used for selecting plural rules.\n * @type {string}\n * @private\n */\narb.pluralLanguage_ = 'en';\n\n\n/**\n * Sets plural rules locale.\n */\narb.setPluralLanguage = function(language) {\n  if (language in arb.pluralRuleMap_) {\n    arb.pluralLanguage_ = language;\n  } else {\n    arb.pluralLanguage_ = '$$';\n  }\n}\n\n\n/**\n * Processes plural message.\n * If it is a plural message, a branch selected based on plural rule will be\n * returned for further processing. Otherwise, original message will be\n * returned. In either case, non-plural related placeholder won't be touched.\n *\n * @param {string} str original message string.\n * @param {string} opt_values if it is a map, its key/value will be\n *     interpreted as named argument. Otherwise, it should be interpreted as\n *     positional argument.\n * @return {string} string after plural processing is done.\n * @private\n */\narb.processPluralRules_ = function(str, opt_values) {\n  var m = arb.PLURAL_RULE_REGEX_.exec(str);\n  if (!m) {\n    return str;\n  }\n\n  var type = typeof opt_values;\n  var arg;\n  if (type == 'object' || type == 'function') {\n    if (!(m[1] in opt_values)) {\n      return str;\n    }\n    arg = opt_values[m[1]];\n  } else {\n    var order = parseInt(m[1]);\n    if (m[1] != '' + order || order >= arguments.length) {\n      return str;\n    }\n    arg = arguments[order];\n  }\n\n  var branches = arb.parseBranches_(str.substring(m[0].length));\n  if (!branches) {\n    return str;\n  }\n\n  if (arg in branches) {\n    return branches['' + arg];\n  }\n\n  if (typeof arg != 'number') {\n    return str;\n  }\n\n  var offset = m[3] ? parseInt(m[3]) : 0;\n\n  var rule = arb.getRuleName(arg - offset);\n\n  if (rule in branches) {\n    return branches[rule].replace('#', arg - offset);\n  }\n\n  if ('other' in branches) {\n    return branches['other'].replace('#', arg - offset);\n  }\n\n  return str;\n};\n\n\n/**\n * Parses the branches parts of a plural message into a map of selective\n * branches.\n *\n * @param {string} str plural message string to be parsed.\n * @return {?Object.<string, string>} a map of plural key name to plural\n *     select branch or null if parsing failed.\n * @private\n */\narb.parseBranches_ = function(str) {\n  var branches = {};\n  var regex = /(?:=(\\d+)|(\\w+))\\s+\\{/;\n  while (true) {\n    if (str.charAt(0) == '}') {\n      return branches;\n    }\n\n    var m = regex.exec(str);\n    if (!m) {\n      return null;\n    }\n    var key = m[1] ? m[1] : m[2];\n    str = str.substring(m[0].length);\n    var openBrackets = 1;\n    var i;\n    for (i = 0; i < str.length && openBrackets > 0; i++) {\n      var ch = str.charAt(i);\n      if (ch == '}') {\n        openBrackets--;\n      } else if (ch == '{') {\n        openBrackets++;\n      }\n    }\n    if (openBrackets != 0) {\n      return null;\n    }\n\n    // grab branch content without ending \"}\"\n    branches[key] = str.substring(0, i - 1);\n    str = str.substring(i).replace(/^\\s*/, '');\n    if (str == '') {\n      return null;\n    }\n  }\n};\n\n\n/**\n * Returns plural rule name based on given number.\n *\n * @param {number} n number for plural selection.\n * @return {string} plural rule name.\n */\narb.getRuleName = function(n) {\n  return arb.pluralRules_[arb.pluralRuleMap_[arb.pluralLanguage_]](n);\n};\n\n\n/**\n * Collection of all possible plural rules.\n * This tables is manually created from CLDR 1.9. Size is the biggest concern.\n * @type {Object.<number, function(number):string>}\n * @private\n */\narb.pluralRules_ = {\n    // \"one\": \"n is 1\"\n    0: function(n) {\n        return (n == 1) ? 'one' : 'other';\n    },\n\n    // \"one\": \"n in 0..1\"\n    1: function(n) {\n        return (n == 0 || n == 1) ? 'one' : 'other';\n    },\n\n    // \"few\": \"n mod 100 in 3..10\",\n    // \"zero\": \"n is 0\",\n    // \"one\": \"n is 1\",\n    // \"two\": \"n is 2\",\n    // \"many\": \"n mod 100 in 11..99\"\n    2: function(n) {\n        return ((n % 100) >= 3 && (n % 100) <= 10 && n == Math.floor(n)) ?\n            'few' : (n == 0) ? 'zero' : (n == 1) ? 'one' : (n == 2) ?\n            'two' : ((n % 100) >= 11 && (n % 100) <= 99 && n == Math.floor(n)) ?\n            'many' : 'other';\n    },\n\n    // \"few\": \"n mod 10 in 2..4 and n mod 100 not in 12..14\",\n    // \"one\": \"n mod 10 is 1 and n mod 100 is not 11\",\n    // \"many\": \"n mod 10 is 0 or n mod 10 in 5..9 or n mod 100 in 11..14\"\n    3: function(n) {\n        return ((n % 10) >= 2 && (n % 10) <= 4 &&\n            ((n % 100) < 12 || (n % 100) > 14) && n == Math.floor(n)) ?\n            'few' : ((n % 10) == 1 && (n % 100) != 11) ? 'one' :\n            ((n % 10) == 0 || ((n % 10) >= 5 && (n % 10) <= 9) ||\n            ((n % 100) >= 11 && (n % 100) <= 14) && n == Math.floor(n)) ?\n            'many' : 'other';\n    },\n\n    // \"few\": \"n is 3\",\n    // \"zero\": \"n is 0\",\n    // \"one\": \"n is 1\",\n    // \"two\": \"n is 2\",\n    // \"many\": \"n is 6\"\n    4: function(n) {\n        return (n == 3) ? 'few' : (n == 0) ? 'zero' : (n == 1) ? 'one' :\n            (n == 2) ? 'two' : (n == 6) ? 'many' : 'other';\n    },\n\n    // \"one\": \"n within 0..2 and n is not 2\"\n    5: function(n) {\n        return (n >= 0 && n < 2) ? 'one' : 'other';\n    },\n\n    // \"two\": \"n is 2\",\n    // \"one\": \"n is 1\"\n    6: function(n) {\n        return (n == 2) ? 'two' : (n == 1) ? 'one' : 'other';\n    },\n\n    // \"few\": \"n in 2..4\",\n    // \"one\": \"n is 1\"\n    7: function(n) {\n        return (n == 2 || n == 3 || n == 4) ? 'few' :\n            (n == 1) ? 'one' : 'other';\n    },\n\n    // \"zero\": \"n is 0\",\n    // \"one\": \"n within 0..2 and n is not 0 and n is not 2\"\n    8: function(n) {\n        return (n == 0) ? 'zero' : (n > 0 && n < 2) ? 'one' : 'other';\n    },\n\n    // \"few\": \"n mod 10 in 2..9 and n mod 100 not in 11..19\",\n    // \"one\": \"n mod 10 is 1 and n mod 100 not in 11..19\"\n    9: function(n) {\n        return ((n % 10) >= 2 && (n % 10) <= 9 &&\n               ((n % 100) < 11 || (n % 100) > 19) && n == Math.floor(n)) ?\n               'few' :\n               ((n % 10) == 1 && ((n % 100) < 11 || (n % 100) > 19)) ? 'one' :\n               'other';\n    },\n\n    // \"zero\": \"n is 0\",\n    // \"one\": \"n mod 10 is 1 and n mod 100 is not 11\"\n    10: function(n) {\n        return (n == 0) ? 'zero' : ((n % 10) == 1 && (n % 100) != 11) ?\n            'one' : 'other';\n    },\n\n    // \"one\": \"n mod 10 is 1 and n is not 11\"\n    11: function(n) {\n        return ((n % 10) == 1 && n != 11) ? 'one' : 'other';\n    },\n\n    // \"few\": \"n is 0 OR n is not 1 AND n mod 100 in 1..19\",\n    // \"one\": \"n is 1\"\n    12: function(n) {\n        return (n == 1) ? 'one' :\n            (n == 0 ||\n             (n % 100) >= 11 && (n % 100) <= 19 && n == Math.floor(n)) ?\n            'few' : 'other';\n    },\n\n    // \"few\": \"n is 0 or n mod 100 in 2..10\",\n    // \"one\": \"n is 1\",\n    // \"many\": \"n mod 100 in 11..19\"\n    13: function(n) {\n        return (n == 0 || (n % 100) >= 2 && (n % 100) <= 10 &&\n                n == Math.floor(n)) ? 'few' : (n == 1) ? 'one' :\n            ((n % 100) >= 11 && (n % 100) <= 19 && n == Math.floor(n)) ?\n            'many' : 'other';\n\n    },\n\n    // \"few\": \"n mod 10 in 2..4 and n mod 100 not in 12..14\",\n    // \"one\": \"n is 1\",\n    // \"many\": \"n is not 1 and n mod 10 in 0..1 or\n    //          n mod 10 in 5..9 or n mod 100 in 12..14\"\n    14: function(n) {\n        return ((n % 10) >= 2 && (n % 10) <= 4 &&\n            ((n % 100) < 12 || (n % 100) > 14) && n == Math.floor(n)) ?\n            'few' : (n == 1) ? 'one' :\n            ((n % 10) == 0 || (n % 10) == 1 ||\n             (((n % 10) >= 5 && (n % 10) <= 9) ||\n            ((n % 100) >= 12 && (n % 100) <= 14)) && n == Math.floor(n)) ?\n            'many' : 'other';\n    },\n\n    // \"few\": \"n in 2..10\",\n    // \"one\": \"n within 0..1\"\n    15: function(n) {\n        return (n >= 2 && n <= 10 && n == Math.floor(n)) ? 'few' :\n            (n >= 0 && n <= 1) ? 'one' : 'other';\n    },\n\n    // \"few\": \"n mod 100 in 3..4\",\n    // \"two\": \"n mod 100 is 2\",\n    // \"one\": \"n mod 100 is 1\"\n    16: function(n) {\n        var m = n % 100;\n        return (m == 3 || m == 4) ? 'few' : (m == 2) ? 'two' :\n               (m == 1) ? 'one' : 'other';\n    },\n\n    // No plural form\n    17: function(n) {\n        return 'other';\n    }\n};\n\n\n/**\n * Mapping of locale to plural rule type.\n * @type {Object}\n * @private\n */\narb.pluralRuleMap_ = {\n    'af': 0, 'ak': 1, 'am': 1, 'ar': 2,\n    'be': 3, 'bem': 0, 'bg': 0, 'bh': 1, 'bn': 0, 'br': 4, 'brx': 0, 'bs': 3,\n    'ca': 0, 'chr': 0, 'ckb': 0, 'cs': 7, 'cy': 4, 'da': 0, 'dz': 0,\n    'el': 0, 'en': 0, 'eo': 0, 'es': 0, 'et': 0, 'eu': 0,\n    'ff': 5, 'fi': 0, 'fil': 1, 'fo': 0, 'fr': 5, 'fur': 0, 'fy': 0,\n    'ga': 6, 'gl': 0, 'gsw': 0, 'gu': 0, 'guw': 1,\n    'ha': 0, 'he': 0, 'hi': 1, 'hr': 3,\n    'is': 0, 'it': 0, 'iw': 0, 'kab': 5, 'ku': 0,\n    'lag': 8, 'lb': 0, 'ln': 1, 'lt': 9, 'lv': 10,\n    'mg': 1, 'mk': 11, 'ml': 0, 'mn': 0, 'mo': 12, 'mr': 0, 'mt': 13,\n    'nah': 0, 'nb': 0, 'ne': 0, 'nl': 0, 'nn': 0, 'no': 0, 'nso': 1,\n    'om': 0, 'or': 0,\n    'pa': 0, 'pap': 0, 'pl': 14, 'ps': 0, 'pt': 0,\n    'rm': 0, 'ro': 12, 'ru': 3,\n    'se': 6, 'sh': 3, 'shi': 15, 'sk': 7, 'sl': 16, 'sma': 6, 'smi': 6,\n    'smj': 6, 'smn': 6, 'sms': 6, 'so': 0, 'sg': 0, 'sr': 3, 'sv': 0, 'sw': 0,\n    'ta': 0, 'te': 0, 'ti': 1, 'tk': 0, 'tl': 1,\n    'uk': 3, 'ur': 0, 'wa': 1, 'zu': 0,\n    '$$': 17   // Special item for language without plural rules.\n};\n\n\n/**\n * Make this exportable.\n */\n\nmodule.exports = arb;\n\n//@ sourceURL=slam/lib/arb.js"
));
require.register("slam/lib/localization.js", Function("exports, require, module",
"var arb = require('./arb.js')\n  , Emitter = require('emitter')\n  , $ = require('jquery');\n\n// Override standard arb register, to emit events.\nvar register = arb.register;\narb.register = function(n) {\n  register.apply(this, arguments);\n\n  if (typeof n == 'string') {\n    localization.emit('new', n);\n  } else {\n    for (var i = 0; i < n.length; i++) {\n      localization.emit('new', n);\n    }\n  }\n};\n\n// because we want html\nvar setTextContent_ = arb.setTextContent_;\narb.setTextContent_ = function(el,txt){\n  $(el).html(txt);\n}\n\n// We are emitting those events:\n// * new - each time a new language was registered by arb.\n// * load - when loading all languages was finished.\n// * changed - each time the language of the site changed.\n\nvar localization = {\n  currentLanguage: 'en', // HTML is in this language, so this is the default.\n  acceptLanguages: [],\n  maxLanguages: 2,\n  genericLanguage: 'en',\n  languages: {},\n  init: function(acceptLanguage) {\n    // Store was languages are accepted by the visitor. Check for dupes and only store the language code without country/quality stuff.\n    acceptLanguage = (acceptLanguage || '').split(',');\n    for (var i = 0; i < acceptLanguage.length; i++) {\n      if (acceptLanguage[i].length >= 2) {\n        acceptLanguage[i] = acceptLanguage[i].substr(0,2);\n        if (this.acceptLanguages.indexOf(acceptLanguage[i]) == -1) {\n          this.acceptLanguages.push(acceptLanguage[i]);\n        }\n      }\n    }\n\n    $.ajax({\n      'url': '/lang/slam.arb', // All arb stuff should go in this file.\n      'dataType': 'text',\n      'success': function(arbData) {\n        if( arbData ){\n          eval(arbData); // Run arb.register\n          this.emit('load');\n        }\n      }.bind(this)\n    });\n\n    // When localization data is loaded the first time,\n    // set language to the user's primary Accept-Language (that we support):\n    this.once('load', function() {\n      if (this.acceptLanguages.length > 0) {\n        this.setLanguage(this.acceptLanguages[0]);\n      }\n    });\n\n    // This listener is fired when a new language is registered by arb.\n    this.on('new', function(namespace) {\n      var language = namespace;\n      if (language.indexOf(':') != -1) { // Get the language code without countrycode, quality setting, etc.\n        language = namespace.substr(language.indexOf(':') + 1);\n      }\n      if (language.length >= 2) { // Empty strings are/was common in Accept-Language, so we have to check the length.\n        language = language.substr(0, 2);\n        if (this.acceptLanguages.indexOf(language) != -1) {\n          if (typeof(this.languages[language]) == 'undefined') {\n            this.languages[language] = [];\n          }\n          this.languages[language].push(namespace);  // Add the resource namespace to this language.\n        }\n      }\n\n    }.bind(this));\n\n  },\n\n  // Change language of the site.\n  setLanguage: function(language) {\n    if (language != this.currentLanguage) {\n      var availLanguages = this.availLanguages();\n      if (availLanguages.indexOf(language) != -1) {\n        this.currentLanguage = language;\n        for (var i = 0; i < this.languages[this.currentLanguage].length; i++) {\n          arb.setResourceSelector(this.languages[this.currentLanguage][i]);\n          arb.localizeHtml();\n        }\n        this.emit('changed');\n      } else {\n        console.log('Language is not available.');\n      }\n    }\n  },\n\n  // Change to the next language.\n  nextLanguage: function() {\n    var availLanguages = this.availLanguages();\n    var index = availLanguages.indexOf(this.currentLanguage);\n    index += 1;\n    if (index >= availLanguages.length) {\n      index = 0;\n    }\n\n    _gaq.push(['_trackEvent', 'localization','switch', availLanguages[index]]);\n\n    this.setLanguage(availLanguages[index]);\n  },\n\n  // Returns the available languages in the order they came as \"accepted\" from the Accept-Language http header,\n  // not more than maxLanguages, and with genericLanguage always included.\n  // If the generic language is the first Accept-Language language, then only return the generic language.\n  availLanguages: function() {\n    var r = [];\n    for(var i=0; i<this.acceptLanguages.length; i++) {\n      var lang = this.acceptLanguages[i];\n      if (typeof(this.languages[lang]) != 'undefined') {\n        r.push(lang);\n\n        // Only return the generic language if it was the first Accept-Language language.\n        //  commented out because this means that any secondary languages will not be visible\n        //  if the primary language is english. is this the expected behaviour?\n        // if (r.length == 1 && r[0] == this.genericLanguage) {\n        //   return r;\n        // }\n\n        // Include genericLanguage if it is not there yet and there is only one position left to fill.\n        if (r.length == this.maxLanguages - 1 && r.indexOf(this.genericLanguage) == -1) {\n          r.push(this.genericLanguage);\n          break;\n\n        // Do not return more than maxLanguages.\n        } else if (r.length == this.maxLanguages) {\n          break;\n        }\n      }\n    }\n    // Always include the generic language:\n    if (r.indexOf(this.genericLanguage) == -1) {\n      r.push(this.genericLanguage);\n    }\n    return r;\n  }\n\n}\n\nEmitter(localization);\n\nmodule.exports = localization;\n//@ sourceURL=slam/lib/localization.js"
));
require.register("slam/lib/ai.js", Function("exports, require, module",
"var debug = require('debug')('ai')\n  , geom = require('geom')\n  , settings = require('./settings')\n  , actions = require('./actions')\n  , vec = geom.vec\n  , ImprovedNoise = require('./support/improved-noise');\n\nmodule.exports = AI;\n\nfunction AI( name ){\n  debug('created')\n  this.name = name;\n  this.active = false;\n  this.noiseAmount = 0;\n  this.guiInit = false;\n  this.time = 0;\n  this.target = null;\n  this.currentConfusionOffsetX = 0;\n  //stores logic\n  this.brain = {};\n\n  this.defaults = {\n    maxSpeed:20,\n    reaction:0.9,\n    viewRange:0.6,\n    confusion:0\n  }\n\n  this.resetBrain();\n\n  actions.on('opponentPaddleHit', this.paddleHit.bind(this) )\n}\n\nAI.prototype = {\n\n  resetBrain: function(){\n    debug('reset brain')\n\n    this.time = 0;\n    this.brain = {};\n    for( var key in this.defaults ) {\n      this.brain[key] = this.defaults[key];\n    }\n  },\n\n  updateBrain: function( data ) {\n    debug('update brain',data)\n\n    this.resetBrain();\n\n    for( var key in data ) {\n      if( this.brain.hasOwnProperty(key) ){\n        this.brain[key] = data[key];\n      }\n    }\n\n    if( !this.guiInit && settings.gui && this.name == 'game'){\n\n      this.guiInit = true;\n\n      var f = settings.gui.addFolder('AI')\n\n      for( key in this.defaults ) {\n        if( key == 'maxSpeed' ){\n          f.add(this.brain,key).min(0).max(20).step(0.1).listen();\n        } else {\n          f.add(this.brain,key).min(0).max(1).step(0.1).listen();\n        }\n      }\n\n    }\n\n  },\n\n  paddleHit: function(){\n    this.currentConfusionOffsetX = Math.random()*500-250;\n  },\n\n  start: function(){\n    debug('start')\n    this.active = true;\n    this.noiseAmount = 0;\n  },\n\n  stop: function(){\n    debug('stop')\n    this.active = false;\n    this.time = 0;\n  },\n\n  setTarget: function(target){\n    debug('set target',target)\n    this.target = target;\n  },\n\n  update: function(world){\n    // skip if target doesn't exist (yet)\n    if( !this.active || this.target === null || !world.bodies.has(this.target) ){\n      return false;\n    }\n\n    // find closest puck\n    var closest = null\n      , minDist = settings.data.arenaHeight*this.brain.viewRange\n      , target = world.bodies.get(this.target)\n      , current = target.current\n      , paddleWidth = (target.aabb[1]-target.aabb[3])*0.5;\n\n    for(var i=0; i < world.pucks.length; i++){\n      var puck = world.pucks.values[i]\n        , testPos = [puck.current[0],current[1]]\n        , dist = vec.distSq(testPos,puck.current)\n\n      minDist *= minDist\n\n      if( dist < minDist ){\n        minDist = dist;\n        closest = puck;\n      }\n    }\n\n    // no puck found\n    var targetX = settings.data.arenaWidth*0.5;\n    if( closest ) {\n      targetX = closest.current[0];\n    } else {\n      targetX += this.currentConfusionOffsetX*this.brain.confusion;\n    }\n\n    if(this.noiseAmount<1){\n      this.noiseAmount+= 0.004;\n    }\n\n    //offset target with confusion\n    targetX += this.currentConfusionOffsetX*this.brain.confusion*0.3*this.noiseAmount;\n\n    this.time += 0.1;\n\n    targetX += Math.sin(this.time*2.2)*40*this.noiseAmount*this.brain.confusion;\n\n    if( closest && closest.velocity[1] < 0 ){\n      current[0] += Math.max(-this.brain.maxSpeed, Math.min(this.brain.maxSpeed,( targetX - current[0])))*this.brain.reaction;\n\n    } else {\n      current[0] += (targetX - current[0])*0.01*this.noiseAmount;\n    }\n\n    if( current[0] > settings.data.arenaWidth - paddleWidth) {\n      current[0] = settings.data.arenaWidth - paddleWidth;\n    } else if( current[0] < paddleWidth) {\n      current[0] = paddleWidth;\n    }\n\n    // ai has moved, let them know\n    return true;\n  }\n\n}//@ sourceURL=slam/lib/ai.js"
));
require.register("slam/lib/dmaf.min.js", Function("exports, require, module",
"var dmaf=function(e){function t(e,t,a){return e&&t&&a?(I||i(e,t,a),void 0):(console.log(n()),void 0)}function i(e,t,i){A[e]=i,i.deps=t,i.name=e}function n(){return\"Dinahmoe Web Audio Framework Version: \"+T}function a(e){return P[e]||(s([e]),P[e]||{})}function s(e){for(var i,n=0,a=e.length;a>n;n++)if(i=e[n],!P[i]&&A[i]){if(!A[i].deps)return null;s.call(t,A[i].deps),P[i]=A[i].apply(t,o(A[i].deps))||{}}}function o(e){for(var t=[],i=0;e.length>i;i++)t.push(P[e[i]]);return t}function r(e){t.dev&&N.projectPath?d(N.projectPath+\"project.xml\",\"document\",u):l(e),t.init=function(){t.log&&console.warn(\"dmaf has already been initialized.\")}}function l(e){a(\"init\")(e,a,A,N.descriptorsXML,N.configXML,N.logs||[])}function c(e,t){var i=document.createElement(\"script\");i.type=\"text/javascript\",i.charset=\"utf-8\",i.async=!0,i.onload=function(){t(),setTimeout(function(){document.body.removeChild(i)},1)},i.src=e,document.body.appendChild(i)}function d(e,t,i){var n=new XMLHttpRequest;n.onload=function(){i(this.response)},n.open(\"GET\",e,!0),n.responseType=t,n.send()}function u(e){var t=e.querySelector(\"framework\"),i=e.querySelector(\"include\"),n=e.querySelector(\"logs\");if(t=t&&t.getAttribute(\"path\"),i=i&&i.getAttribute(\"scripts\"),n=n&&n.getAttribute(\"channels\"),!t)throw new TypeError(\"Missing framework path.\");N.customScripts=i&&i.split(\",\")||[],N.logs=n&&n.split(\",\"),N.frameworkPath=t,N.configPath=N.projectPath+\"config.xml\",N.assetsPath=N.projectPath+\"assets/\";for(var a=0;N.customScripts.length>a;a++)N.customScripts[a]=N.assetsPath+\"js/\"+N.customScripts[a];d(t+\"src/scripts.json\",\"text\",p)}function p(e){var t,i=JSON.parse(e);i=i.concat(N.customScripts),N.files.toLoad=i.length,I=!1,console.log(\"Loading dmaf from:\",N.frameworkPath);for(var n=0;N.files.toLoad>n;n++)t=/http/.test(i[n])?i[n]:N.frameworkPath+i[n],c(t,h)}function h(){++N.files.loaded===N.files.toLoad&&d(N.frameworkPath+\"src/xml/descriptors.xml\",\"document\",m)}function m(e){N.descriptorsXML=e,d(N.configPath,\"document\",f)}function f(e){N.configXML=e,l(N.assetsPath)}function g(e){var i=[],n=function(){i.push(arguments)};n.resolve=function(n){for(t[e]=n||function(){};i.length;)n.apply(t,i.shift())},t[e]=n}for(var y=!(\"undefined\"==typeof window||!e.navigator||!e.document),_=y&&!(!e.webkitAudioContext&&!e.AudioContext),v=e.location&&e.location.href.split(\"?\")||[],b=(!(!Object.create||!Object.keys),/^dmaf\\=/),T=\"4.2.8\",A={},P={},E=[\"once\",\"registerObject\",\"unregisterObject\",\"addEventListener\",\"removeEventListener\",\"tell\"],N={files:{loaded:0,total:0},projectPath:\"\"},I=!1,M=0;E.length>M;M++)g(E[M]);for(t.prototype=null,t.isBrowser=y,t.hasContext=_,t.toString=n,t.init=r,t.dev=!1,M=0;v.length>M;M++)if(b.test(v[M])){console.log(\"DMAF is running in development mode.\"),t.dev=I=!0,N.projectPath=v[M].replace(b,\"\");break}return\"undefined\"!=typeof module&&module.exports?module.exports=t:\"undefined\"!=typeof define&&define(\"dmaf\",[],function(){return t}),1&&(e.dmaf=t)}(this);dmaf(\"settings\",[\"DMAF\"],function(e){e.Settings={assetsPath:\"./dmaf__assets/\",descriptors:{validActions:[\"loadCustomCode\",\"loadSound\",\"loadMIDI\",\"loadSampleMap\",\"customCode\",\"userObject\",\"mediaElement\",\"mediaController\",\"genericPlay\",\"stepPlay\",\"soundStop\",\"midiProcessor\",\"makeNote\",\"transform\",\"macro\",\"state\",\"eventMapper\",\"midiNoteMapper\",\"timePatternPlayer\",\"beatPatternPlayer\",\"sampler\",\"audioBus\"],validTypes:[\"noteMap\",\"stateMap\",\"eventMap\",\"file\",\"map\",\"target\",\"sampleMapGroup\",\"sampleMap\",\"start\",\"stop\",\"beatEvent\",\"add\",\"band\",\"chorus\",\"overdrive\",\"compressor\",\"cabinet\",\"filter\",\"convolver\",\"delay\",\"envelopeFollower\",\"equalizer\",\"lfo\",\"phaser\",\"pingPongDelay\",\"tremolo\",\"wahWah\"],action:{assetController:{loadCustomCode:{type:\"assetController\",id:\"loadCustomCode\",instanceId:{name:\"instanceId\",type:\"string\"},returnEvent:{name:\"returnEvent\",type:\"string\"},files:{name:\"files\",type:\"array\",valueType:\"file\"},\"\":{type:\"assetController\"}},type:\"assetController\",loadSound:{type:\"assetController\",id:\"loadSound\",instanceId:{name:\"instanceId\",type:\"string\"},returnEvent:{name:\"returnEvent\",type:\"string\"},files:{name:\"files\",type:\"array\",valueType:\"file\"},\"\":{type:\"assetController\"}},loadMIDI:{type:\"assetController\",id:\"loadMIDI\",instanceId:{name:\"instanceId\",type:\"string\"},returnEvent:{name:\"returnEvent\",type:\"string\"},files:{name:\"files\",type:\"array\",valueType:\"file\"},\"\":{type:\"assetController\"}},loadSampleMap:{type:\"assetController\",id:\"loadSampleMap\",instanceId:{name:\"instanceId\",type:\"string\"},returnEvent:{name:\"returnEvent\",type:\"string\"},files:{name:\"files\",type:\"array\",valueType:\"file\"},\"\":{type:\"assetController\"}}},customCode:{customCode:{type:\"customCode\",id:\"customCode\",instanceId:{name:\"instanceId\",type:\"string\"},\"\":{type:\"customCode\"}},type:\"customCode\",userObject:{type:\"customCode\",id:\"userObject\",instanceId:{name:\"instanceId\",type:\"string\"},\"\":{type:\"customCode\"}}},mediaElement:{mediaElement:{type:\"mediaElement\",id:\"mediaElement\",instanceId:{name:\"instanceId\",type:\"string\"},\"\":{type:\"mediaElement\"}},type:\"mediaElement\"},control:{mediaController:{type:\"control\",id:\"mediaController\",instanceId:{name:\"instanceId\",type:\"string\",\"default\":\"multi\"},\"\":{type:\"control\"}},type:\"control\"},sound:{genericPlay:{type:\"sound\",id:\"genericPlay\",delay:{name:\"delay\",type:\"int\",\"default\":0,min:-1e6,max:1e6},instanceId:{name:\"instanceId\",type:\"string\",\"default\":\"multi\"},soundFile:{name:\"soundFile\",type:\"string\",\"default\":\"multi\"},multiSuffix:{name:\"multiSuffix\",type:\"string\",\"default\":\"\"},volume:{name:\"volume\",type:\"float\",unit:\"dB\",\"default\":0,min:-90,max:48},pan:{name:\"pan\",type:\"int\",\"default\":0,min:-100,max:100},loop:{name:\"loop\",type:\"int\",unit:\"mS\",\"default\":-1,min:-2,max:1e5},reTrig:{name:\"reTrig\",type:\"int\",unit:\"mS\",\"default\":-1,min:-1,max:1e5},returnEvent:{name:\"returnEvent\",type:\"string\"},returnEventTime:{name:\"returnEventTime\",type:\"int\",unit:\"mS\",\"default\":-1,min:-1e6,max:1e5},preListen:{name:\"preListen\",type:\"int\",\"default\":0,min:0,max:500},bus:{name:\"bus\",type:\"string\",\"default\":\"master\"},priority:{name:\"priority\",type:\"boolean\",\"default\":!1},timingCorrection:{name:\"timingCorrection\",type:\"enum\",\"default\":\"PLAY\",values:[\"RESYNC\",\"SYNC\",\"PLAY\"]},\"\":{type:\"sound\"}},type:\"sound\",stepPlay:{type:\"sound\",id:\"stepPlay\",delay:{name:\"delay\",type:\"int\",\"default\":0,min:0,max:1e5},instanceId:{name:\"instanceId\",type:\"string\"},soundFiles:{name:\"soundFiles\",type:\"list\"},generator:{name:\"generator\",type:\"enum\",\"default\":\"SHUFFLE\",values:[\"SHUFFLE\",\"RANDOM\",\"RANDOM_FIRST\",\"ROUND_ROBIN\"]},volume:{name:\"volume\",type:\"float\",\"default\":0,min:-90,max:48},pan:{name:\"pan\",type:\"int\",\"default\":0,min:-100,max:100},reTrig:{name:\"reTrig\",type:\"int\",\"default\":-1,min:-1,max:1e5},returnEvent:{name:\"returnEvent\",type:\"string\",\"default\":\"\",values:[\"ALL\"]},returnEventTime:{name:\"returnEventTime\",type:\"int\",\"default\":-1,min:-1e6,max:1e5},preListen:{name:\"preListen\",type:\"int\",\"default\":0,min:0,max:500},bus:{name:\"bus\",type:\"string\",\"default\":\"master\",values:[\"ALL\"]},priority:{name:\"priority\",type:\"boolean\",\"default\":!1},timingCorrection:{name:\"timingCorrection\",type:\"enum\",\"default\":\"SYNC\",values:[\"SYNC\",\"PLAY\"]},\"\":{type:\"sound\"}},soundStop:{type:\"sound\",id:\"soundStop\",instanceId:{name:\"instanceId\",type:\"string\"},delay:{name:\"delay\",type:\"int\",\"default\":0,min:0,max:9999999},targets:{name:\"targets\",type:\"list\"},multiSuffix:{name:\"multiSuffix\",type:\"string\",\"default\":\"\"},\"\":{type:\"sound\"}}},midiProcessor:{midiProcessor:{type:\"midiProcessor\",id:\"midiProcessor\",instanceId:{name:\"instanceId\",type:\"string\"},transpose:{name:\"transpose\",type:\"int\",\"default\":0,min:-127,max:127},dynamic:{name:\"dynamic\",type:\"int\",\"default\":0,min:-127,max:127},quantize:{name:\"quantize\",type:\"string\"},scale:{name:\"scale\",type:\"string\",values:[\"off\",\"major\",\"harmonicMinor\",\"naturalMinor\",\"majorPentatonic\",\"minorPentatonic\",\"dorian\",\"phyrgian\",\"lydian\",\"mixolydian\",\"locrian\",\"doubleHarmonic\",\"halfDim\",\"custom\",\"off\"]},customScale:{name:\"customScale\",type:\"string\",\"default\":\"0,0,0,0,0,0,0,0,0,0,0,0\"},root:{name:\"root\",type:\"string\",\"default\":\"C\",values:[\"C\",\"C#\",\"D\",\"D#\",\"E\",\"F\",\"F#\",\"G\",\"G#\",\"A\",\"A#\",\"B\"]},\"\":{type:\"midiProcessor\"}},type:\"midiProcessor\",makeNote:{type:\"midiProcessor\",id:\"makeNote\",instanceId:{name:\"instanceId\",type:\"string\",\"default\":\"someProcessor\"},reTrig:{name:\"reTrig\",type:\"int\",\"default\":0,min:0,max:1e4},noteMaps:{name:\"noteMaps\",type:\"array\",valueType:\"noteMap\"},\"\":{type:\"midiProcessor\"}}},parameterProcessor:{transform:{type:\"parameterProcessor\",id:\"transform\",instanceId:{name:\"instanceId\",type:\"string\"},delay:{name:\"delay\",type:\"int\",\"default\":0,min:0,max:9999999},targetType:{name:\"targetType\",type:\"enum\",\"default\":\"SOUND\",values:[\"sound\",\"audioRouter\",\"synth\",\"parameterProcessor\"]},targets:{name:\"targets\",type:\"list\"},targetParameter:{name:\"targetParameter\",type:\"string\"},multiSuffix:{name:\"multiSuffix\",type:\"string\"},value:{name:\"value\",type:\"float\",\"default\":0,min:-9999999,max:9999999},duration:{name:\"duration\",type:\"int\",\"default\":0,min:0,max:9999999},curve:{name:\"curve\",type:\"int\",\"default\":0,min:-100,max:100},\"\":{type:\"parameterProcessor\"}},type:\"parameterProcessor\",macro:{type:\"parameterProcessor\",id:\"macro\",instanceId:{name:\"instanceId\",type:\"string\"},delay:{name:\"delay\",type:\"int\",\"default\":0,min:0,max:9999999},macroTargets:{name:\"macroTargets\",type:\"array\",valueType:\"macroTarget\"},\"\":{type:\"parameterProcessor\"}}},stateProcessor:{state:{type:\"stateProcessor\",id:\"state\",instanceId:{name:\"instanceId\",type:\"string\"},update:{name:\"update\",type:\"enum\",\"default\":\"onChange\",values:[\"onChange\",\"always\"]},stateMaps:{name:\"stateMaps\",type:\"array\",valueType:\"stateMap\"},\"\":{type:\"stateProcessor\"}},type:\"stateProcessor\"},eventProcessor:{eventMapper:{type:\"eventProcessor\",id:\"eventMapper\",instanceId:{name:\"instanceId\",type:\"string\"},reTrig:{name:\"reTrig\",type:\"int\",\"default\":0,min:0,max:1e4},clearPending:{name:\"clearPending\",type:\"boolean\",\"default\":!1},eventMaps:{name:\"eventMaps\",type:\"array\",valueType:\"eventMap\"},\"\":{type:\"eventProcessor\"}},type:\"eventProcessor\",midiNoteMapper:{type:\"eventProcessor\",id:\"midiNoteMapper\",instanceId:{name:\"instanceId\",type:\"string\"},eventMaps:{name:\"eventMaps\",type:\"array\",valueType:\"eventMap\"},\"\":{type:\"eventProcessor\"}}},player:{timePatternPlayer:{type:\"player\",id:\"timePatternPlayer\",instanceId:{name:\"instanceId\",type:\"string\",\"default\":\"master_time_player\"},behavior:{name:\"behavior\",type:\"enum\",values:[\"LINEAR\",\"DEFAULT\"],\"default\":\"DEFAULT\"},\"\":{type:\"player\"}},type:\"player\",beatPatternPlayer:{type:\"player\",id:\"beatPatternPlayer\",instanceId:{name:\"instanceId\",type:\"string\",\"default\":\"master_beat_player\"},flowItems:{name:\"flowItems\",type:\"array\",valueType:\"flowItem\"},\"\":{type:\"player\"}}},synth:{sampler:{type:\"synth\",id:\"sampler\",instanceId:{name:\"instanceId\",type:\"string\"},ignoreNoteOff:{name:\"ignoreNoteOff\",type:\"boolean\",\"default\":!1},bus:{name:\"bus\",type:\"string\",\"default\":\"master\"},volume:{name:\"volume\",type:\"float\",\"default\":0,min:-100,max:10},loop:{name:\"loop\",type:\"boolean\",\"default\":!1},ampAttack:{name:\"ampAttack\",type:\"int\",\"default\":0,min:0,max:500},ampDecay:{name:\"ampDecay\",type:\"int\",\"default\":0,min:0,max:500},ampRelease:{name:\"ampRelease\",type:\"int\",\"default\":0,min:0,max:1e3},ampSustain:{name:\"ampSustain\",type:\"float\",\"default\":1,min:0,max:1},ampVelocityRatio:{name:\"ampVelocityRatio\",type:\"float\",\"default\":1,min:0,max:1},filterOn:{name:\"filterOn\",type:\"boolean\",\"default\":!1},filterAttack:{name:\"filterAttack\",type:\"int\",\"default\":0,min:0,max:500},filterDecay:{name:\"filterDecay\",type:\"int\",\"default\":0,min:0,max:500},filterRelease:{name:\"filterRelease\",type:\"int\",\"default\":0,min:0,max:1e3},filterSustain:{name:\"filterSustain\",type:\"float\",\"default\":1,min:0,max:1},filterVelocityRatio:{name:\"filterVelocityRatio\",type:\"float\",\"default\":1,min:0,max:1},filterQ:{name:\"filterQ\",type:\"float\",\"default\":1e-4,min:1e-4,max:30},filterFrequency:{name:\"filterFrequency\",type:\"int\",\"default\":0,min:0,max:10},filterGain:{name:\"filterGain\",type:\"float\",\"default\":0,min:0,max:1},audioNodes:{name:\"audioNodes\",type:\"array\",valueType:\"audioNode\"},sampleMapGroups:{name:\"sampleMapGroups\",type:\"array\",valueType:\"sampleMapGroup\"},\"\":{type:\"synth\"}},type:\"synth\"},audioRouter:{audioBus:{type:\"audioRouter\",id:\"audioBus\",instanceId:{name:\"instanceId\",type:\"string\"},out:{name:\"out\",type:\"list\",\"default\":[\"\"]},volume:{name:\"volume\",type:\"float\",\"default\":0,min:-100,max:10},pan:{name:\"pan\",type:\"int\",\"default\":0,min:-100,max:100},audioNodes:{name:\"audioNodes\",type:\"array\",valueType:\"audioNode\"},\"\":{type:\"audioRouter\"}},type:\"audioRouter\"}},type:{noteMap:{noteMap:{type:\"noteMap\",id:\"noteMap\",triggerIn:{name:\"triggerIn\",type:\"string\"},triggerOut:{name:\"triggerOut\",type:\"string\"},note:{name:\"note\",type:\"string\",\"default\":\"C4\"},velocity:{name:\"velocity\",type:\"int\",min:0,max:127,\"default\":127},duration:{name:\"duration\",type:\"int\",min:0,max:9999999,\"default\":0},\"\":{type:\"noteMap\"}},type:\"noteMap\"},stateMap:{stateMap:{type:\"stateMap\",id:\"stateMap\",\"in\":{name:\"in\",type:\"list\"},state:{name:\"state\",type:\"string\"},\"\":{type:\"stateMap\"}},type:\"stateMap\"},eventMap:{eventMap:{type:\"eventMap\",id:\"eventMap\",\"in\":{name:\"in\",type:\"list\"},out:{name:\"out\",type:\"string\"},delay:{name:\"delay\",type:\"int\",\"default\":0,max:1e4,min:0},\"\":{type:\"eventMap\"}},type:\"eventMap\"},file:{file:{type:{name:\"type\",type:\"enum\",values:[\"beatPattern\",\"timePattern\"],\"default\":\"\"},id:\"file\",name:{name:\"name\",type:\"string\"},\"\":{type:\"file\"}},type:\"file\"},map:{map:{type:\"map\",id:\"map\",inValue:{name:\"inValue\",type:\"string\"},outValue:{name:\"outValue\",type:\"string\"},\"\":{type:\"map\"}},type:\"map\"},macroTarget:{target:{type:\"macroTarget\",id:\"target\",targetId:{name:\"targetId\",type:\"string\"},min:{name:\"min\",type:\"float\",\"default\":1e5,min:-1e5,max:1e5},max:{name:\"max\",type:\"float\",\"default\":1e5,min:-1e5,max:1e5},targetInstance:{name:\"targetInstance\",type:\"string\"},targetParameter:{name:\"targetParameter\",type:\"string\"},curve:{name:\"curve\",type:\"enum\",\"default\":\"LINEAR\",values:[\"LINEAR\",\"EXP\",\"LOG\"]},\"\":{type:\"macroTarget\"}},type:\"macroTarget\"},sampleMapGroup:{sampleMapGroup:{type:\"sampleMapGroup\",id:\"sampleMapGroup\",name:{name:\"name\",type:\"string\"},sampleMaps:{name:\"sampleMaps\",type:\"array\",valueType:\"sampleMap\"},\"\":{type:\"sampleMapGroup\"}},type:\"sampleMapGroup\"},sampleMap:{sampleMap:{type:\"sampleMap\",id:\"sampleMap\",name:{name:\"name\",type:\"string\"},velocityLow:{name:\"velocityLow\",type:\"int\",\"default\":0,min:0,max:127},velocityHigh:{name:\"velocityHigh\",type:\"int\",\"default\":127,min:0,max:127},\"\":{type:\"sampleMap\"}},type:\"sampleMap\"},flowItem:{start:{type:\"flowItem\",id:\"start\",delay:{name:\"delay\",type:\"int\",\"default\":0,min:0,max:null},tempo:{name:\"tempo\",type:\"float\",\"default\":120,min:40,max:280},beatsPerBar:{name:\"beatsPerBar\",type:\"int\",\"default\":16,min:1,max:16},meter:{name:\"meter\",type:\"list\",\"default\":[\"simple\"],value:[\"simple\",\"compound\"]},subdivision:{name:\"subdivision\",type:\"string\",\"default\":\"16\",values:[\"1\",\"2D\",\"2\",\"2T\",\"4D\",\"4\",\"4T\",\"8D\",\"8\",\"8T\",\"16D\",\"16\",\"16T\",\"32D\",\"32\",\"32T\"]},\"\":{type:\"flowItem\"}},type:\"flowItem\",stop:{type:\"flowItem\",id:\"stop\",songPosition:{name:\"songPosition\",type:\"string\",\"default\":\"NEXT_BEAT\"},returnEvent:{name:\"returnEvent\",type:\"string\"},\"\":{type:\"flowItem\"}},beatEvent:{type:\"flowItem\",id:\"beatEvent\",songPosition:{name:\"songPosition\",type:\"string\",\"default\":\"NEXT_BEAT\"},returnEvent:{name:\"returnEvent\",type:\"string\"},output:{name:\"output\",type:\"enum\",\"default\":\"onEvent\",values:[\"dispatch\",\"onEvent\"]},\"\":{type:\"flowItem\"}},add:{type:\"flowItem\",id:\"add\",patternId:{name:\"patternId\",type:\"list\",\"default\":[\"multi\"]},channel:{name:\"channel\",type:\"string\",\"default\":\"main\"},songPosition:{name:\"songPosition\",type:\"string\",\"default\":\"NEXT_BAR\"},patternPosition:{name:\"patternPosition\",type:\"enum\",\"default\":\"SYNC\",values:[\"SYNC\",\"FIRST_BEAT\"]},clearPending:{name:\"clearPending\",type:\"boolean\",\"default\":!0},replaceActive:{name:\"replaceActive\",type:\"boolean\",\"default\":!0},setAsCurrent:{name:\"setAsCurrent\",type:\"boolean\",\"default\":!0},loop:{name:\"loop\",type:\"boolean\",\"default\":!1},loopLength:{name:\"loopLength\",type:\"int\",\"default\":129,min:1,max:65536},clearPosition:{name:\"clearPosition\",type:\"string\",\"default\":\"NEXT_BAR\"},\"\":{type:\"flowItem\"}}},band:{band:{type:\"band\",id:\"band\",bandType:{name:\"bandType\",type:\"enum\",\"default\":\"PEAKING\",values:[\"LOWPASS\",\"HIGHPASS\",\"BANDPASS\",\"LOWSHELF\",\"HIGHSHELF\",\"PEAKING\",\"NOTCH\",\"ALLPASS\"],automatable:!1},frequency:{name:\"frequency\",type:\"float\",\"default\":800,min:20,max:22050,automatable:!0},Q:{name:\"Q\",type:\"float\",\"default\":1,min:0,max:100,automatable:!0},gain:{name:\"gain\",type:\"float\",\"default\":0,min:-40,max:40,automatable:!0},\"\":{type:\"band\"}},type:\"band\"},audioNode:{chorus:{type:\"audioNode\",id:\"chorus\",active:{name:\"active\",type:\"boolean\",\"default\":!0},feedback:{name:\"feedback\",type:\"float\",\"default\":0,min:0,max:1,automatable:!1},delay:{name:\"delay\",type:\"float\",\"default\":.0045,min:0,max:1,automatable:!1},rate:{name:\"rate\",type:\"float\",\"default\":1.5,min:.01,max:8,automatable:!1},bypass:{name:\"bypass\",type:\"float\",\"default\":0,min:0,max:1,automatable:!1},\"\":{type:\"audioNode\"}},type:\"audioNode\",overdrive:{type:\"audioNode\",id:\"overdrive\",active:{name:\"active\",type:\"boolean\",\"default\":!0},outputGain:{name:\"outputGain\",type:\"float\",\"default\":0,min:0,max:10,automatable:!0},drive:{name:\"drive\",type:\"float\",\"default\":0,min:0,max:10,automatable:!0},curveAmount:{name:\"curveAmount\",type:\"float\",\"default\":1,min:0,max:10,automatable:!0},algorithmIndex:{name:\"algorithmIndex\",type:\"int\",\"default\":0,min:0,max:5,automatable:!1},\"\":{type:\"audioNode\"}},compressor:{type:\"audioNode\",id:\"compressor\",active:{name:\"active\",type:\"boolean\",\"default\":!0},threshold:{name:\"threshold\",type:\"float\",\"default\":0,min:-100,max:0,automatable:!0},makeupGain:{name:\"makeupGain\",type:\"float\",\"default\":1,min:0,max:100,automatable:!0},attack:{name:\"attack\",type:\"float\",\"default\":1,min:0,max:1e3,automatable:!0},release:{name:\"release\",type:\"float\",\"default\":1,min:0,max:3e3,automatable:!0},ratio:{name:\"ratio\",type:\"float\",\"default\":4,min:1,max:20,automatable:!0},knee:{name:\"knee\",type:\"float\",\"default\":5,min:0,max:40,automatable:!0},automakeup:{name:\"automakeup\",type:\"boolean\",\"default\":!1},\"\":{type:\"audioNode\"}},cabinet:{type:\"audioNode\",id:\"cabinet\",active:{name:\"active\",type:\"boolean\",\"default\":!0},makeupGain:{name:\"makeupGain\",type:\"float\",\"default\":1,min:0,max:20,automatable:!0},impulsePath:{name:\"impulsePath\",type:\"string\"},\"\":{type:\"audioNode\"}},filter:{type:\"audioNode\",id:\"filter\",active:{name:\"active\",type:\"boolean\",\"default\":!0},frequency:{name:\"frequency\",type:\"float\",\"default\":20,min:20,max:22050,automatable:!0},Q:{name:\"Q\",type:\"float\",\"default\":1,min:0,max:100,automatable:!0},gain:{name:\"gain\",type:\"float\",\"default\":0,min:-40,max:40,automatable:!0},bypass:{name:\"bypass\",type:\"boolean\",\"default\":!0,automatable:!0},filterType:{name:\"filterType\",type:\"enum\",\"default\":\"LOWPASS\",values:[\"LOWPASS\",\"HIGHPASS\",\"BANDPASS\",\"LOWSHELF\",\"HIGHSHELF\",\"PEAKING\",\"NOTCH\",\"ALLPASS\"],automatable:!1},\"\":{type:\"audioNode\"}},convolver:{type:\"audioNode\",id:\"convolver\",active:{name:\"active\",type:\"boolean\",\"default\":!0},highCut:{name:\"highCut\",type:\"float\",\"default\":22050,min:20,max:22050,automatable:!0},lowCut:{name:\"lowCut\",type:\"float\",\"default\":20,min:20,max:22050,automatable:!0},dryLevel:{name:\"dryLevel\",type:\"float\",\"default\":1,min:0,max:1,automatable:!0},wetLevel:{name:\"wetLevel\",type:\"float\",\"default\":1,min:0,max:1,automatable:!0},level:{name:\"level\",type:\"float\",\"default\":1,min:0,max:1,automatable:!0},impulse:{name:\"impulse\",type:\"string\"},\"\":{type:\"audioNode\"}},delay:{type:\"audioNode\",id:\"delay\",active:{name:\"active\",type:\"boolean\",\"default\":!0},delayTime:{name:\"delayTime\",type:\"float\",\"default\":30,min:.001,max:1e4,automatable:!1},feedback:{name:\"feedback\",type:\"float\",\"default\":.45,min:0,max:.9,automatable:!0},cutoff:{name:\"cutoff\",type:\"float\",\"default\":20,min:20,max:22050,automatable:!0},dryLevel:{name:\"dryLevel\",type:\"float\",\"default\":1,min:0,max:1,automatable:!0},wetLevel:{name:\"wetLevel\",type:\"float\",\"default\":1,min:0,max:1,automatable:!0},tempoSync:{name:\"tempoSync\",type:\"string\",automatable:!1},subdivision:{name:\"subdivision\",type:\"enum\",\"default\":\"8D\",values:[\"1\",\"2D\",\"2\",\"2T\",\"4D\",\"4\",\"4T\",\"8D\",\"8\",\"8T\",\"16D\",\"16\",\"16T\",\"32D\",\"32\",\"32T\"],automatable:!1},\"\":{type:\"audioNode\"}},envelopeFollower:{type:\"audioNode\",id:\"envelopeFollower\",active:{name:\"active\",type:\"boolean\",\"default\":!0},attackTime:{name:\"attackTime\",type:\"float\",\"default\":.003,min:0,max:.5,automatable:!1},releaseTime:{name:\"releaseTime\",type:\"float\",\"default\":.5,min:0,max:1,automatable:!1},\"\":{type:\"audioNode\"}},equalizer:{type:\"audioNode\",id:\"equalizer\",active:{name:\"active\",type:\"boolean\",\"default\":!0},bands:{name:\"bands\",type:\"array\",valueType:\"band\"},\"\":{type:\"audioNode\"}},lfo:{type:{name:\"type\",type:\"enum\",\"default\":\"SIN\",values:[\"SIN\",\"SQUARE\",\"TRIANGLE\",\"SAWTOOTH\"],automatable:!1},id:\"lfo\",active:{name:\"active\",type:\"boolean\",\"default\":!0},frequency:{name:\"frequency\",type:\"float\",\"default\":1,min:0,max:8,automatable:!1},offset:{name:\"offset\",type:\"float\",\"default\":.85,min:0,max:22050,automatable:!1},phase:{name:\"phase\",type:\"float\",\"default\":0,min:0,max:6.28318530718,automatable:!1},oscillation:{name:\"oscillation\",type:\"float\",\"default\":.3,min:-22050,max:22050,automatable:!1},\"\":{type:\"audioNode\"}},phaser:{type:\"audioNode\",id:\"phaser\",active:{name:\"active\",type:\"boolean\",\"default\":!0},rate:{name:\"rate\",type:\"float\",\"default\":1,min:0,max:8,automatable:!1},depth:{name:\"depth\",type:\"float\",\"default\":.3,min:0,max:1,automatable:!1},feedback:{name:\"feedback\",type:\"float\",\"default\":.2,min:0,max:1,automatable:!1},stereoPhase:{name:\"stereoPhase\",type:\"int\",\"default\":30,min:0,max:180,automatable:!1},baseModulationFrequency:{name:\"baseModulationFrequency\",type:\"float\",\"default\":700,min:500,max:1500,automatable:!1},\"\":{type:\"audioNode\"}},pingPongDelay:{type:\"audioNode\",id:\"pingPongDelay\",active:{name:\"active\",type:\"boolean\",\"default\":!0},delayTime:{name:\"delayTime\",type:\"float\",\"default\":30,min:1e-4,max:1e4,automatable:!1},feedback:{name:\"feedback\",type:\"float\",\"default\":.45,min:0,max:.9,automatable:!0},cutoff:{name:\"cutoff\",type:\"float\",\"default\":20,min:20,max:22050,automatable:!0},dryLevel:{name:\"dryLevel\",type:\"float\",\"default\":1,min:0,max:1,automatable:!0},wetLevel:{name:\"wetLevel\",type:\"float\",\"default\":1,min:0,max:1,automatable:!0},tempoSync:{name:\"tempoSync\",type:\"string\",automatable:!1},subdivision:{name:\"subdivision\",type:\"enum\",\"default\":\"8D\",values:[\"1\",\"2D\",\"2\",\"2T\",\"4D\",\"4\",\"4T\",\"8D\",\"8\",\"8T\",\"16D\",\"16\",\"16T\",\"32D\",\"32\",\"32T\"],automatable:!1},\"\":{type:\"audioNode\"}},tremolo:{type:\"audioNode\",id:\"tremolo\",active:{name:\"active\",type:\"boolean\",\"default\":!0},intensity:{name:\"intensity\",type:\"float\",\"default\":.3,min:0,max:1,automatable:!1},stereoPhase:{name:\"stereoPhase\",type:\"int\",\"default\":0,min:0,max:180,automatable:!1},rate:{name:\"rate\",type:\"float\",\"default\":.1,min:.001,max:8,automatable:!1},\"\":{type:\"audioNode\"}},wahWah:{type:\"audioNode\",id:\"wahWah\",active:{name:\"active\",type:\"boolean\",\"default\":!0},automode:{name:\"automode\",type:\"boolean\",\"default\":!1},baseFrequency:{name:\"baseFrequency\",type:\"float\",\"default\":.5,min:0,max:1,automatable:!1},excursionOctaves:{name:\"excursionOctaves\",type:\"int\",\"default\":2,min:1,max:6,automatable:!1},sweep:{name:\"sweep\",type:\"float\",\"default\":.2,min:0,max:1,automatable:!1},resonance:{name:\"resonance\",type:\"float\",\"default\":10,min:1,max:100,automatable:!1},sensitivity:{name:\"sensitivity\",type:\"float\",\"default\":.5,min:-1,max:1,automatable:!1},\"\":{type:\"audioNode\"}}}}},actions:[{instanceId:\"master_bus\",out:[\"master\"],volume:-2,pan:0,audioNodes:[{id:\"compressor\",active:!0,threshold:-3,makeupGain:0,attack:0,release:0,ratio:20,knee:0,automakeup:!1}],type:\"audioRouter\",id:\"audioBus\",triggers:[\"init_routing\"],delay:0,multi:!1},{instanceId:\"active_bus\",out:[\"master_bus\"],volume:0,pan:0,audioNodes:[],type:\"audioRouter\",id:\"audioBus\",triggers:[\"init_routing\"],delay:0,multi:!1},{instanceId:\"two_player_bus\",out:[\"active_bus\"],volume:0,pan:0,audioNodes:[],type:\"audioRouter\",id:\"audioBus\",triggers:[\"init_routing\"],delay:0,multi:!1},{instanceId:\"pause_bus\",out:[\"two_player_bus\"],volume:0,pan:0,audioNodes:[],type:\"audioRouter\",id:\"audioBus\",triggers:[\"init_routing\"],delay:0,multi:!1},{instanceId:\"master_mute\",targetType:\"audioRouter\",targets:[\"master_bus\"],targetParameter:\"volume\",value:-80,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"sound_off\"],multi:!1},{instanceId:\"master_unmute\",targetType:\"audioRouter\",targets:[\"master_bus\"],targetParameter:\"volume\",value:0,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"sound_on\"],multi:!1},{instanceId:\"active_mute\",targetType:\"audioRouter\",targets:[\"active_bus\"],targetParameter:\"volume\",value:-80,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"inactive\"],multi:!1},{instanceId:\"active_unmute\",targetType:\"audioRouter\",targets:[\"active_bus\"],targetParameter:\"volume\",value:0,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"active\"],multi:!1},{instanceId:\"pause_mute\",targetType:\"audioRouter\",targets:[\"two_player_bus\"],targetParameter:\"volume\",value:-10,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"microphone_on\"],multi:!1},{instanceId:\"pause_unmute\",targetType:\"audioRouter\",targets:[\"two_player_bus\"],targetParameter:\"volume\",value:0,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"microphone_off\"],multi:!1},{instanceId:\"pause_mute\",targetType:\"audioRouter\",targets:[\"pause_bus\"],targetParameter:\"volume\",value:-80,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"pause\"],multi:!1},{instanceId:\"pause_unmute\",targetType:\"audioRouter\",targets:[\"pause_bus\"],targetParameter:\"volume\",value:0,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"unpause\"],multi:!1},{instanceId:\"CheckMobile\",type:\"customCode\",id:\"customCode\",triggers:[\"init_routing\",\"splash_screen\",\"info_screen\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"start\",tempo:126,beatsPerBar:16}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"init_beatpatternplayer\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"splash_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"splash_bass\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"splash_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"splash_stab\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"splash_strings\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"splash_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"splash_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"splash_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"splash_screen_music\"],delay:0,multi:!1},{instanceId:\"gameover_music_delayed\",reTrig:0,eventMaps:[{id:\"eventMap\",\"in\":[\"gameover_screen\"],out:\"gameover_screen_delayed\",delay:400}],type:\"eventProcessor\",id:\"eventMapper\",clearPending:!1,triggers:[\"gameover_screen\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"start\",delay:0,tempo:126,beatsPerBar:16},{id:\"add\",patternId:[\"game_over_bass\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_lead_a\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_lead_b\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_stab\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_strings\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"game_over_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"gameover_screen_delayed\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"start\",delay:0,tempo:126,beatsPerBar:16},{id:\"add\",patternId:[\"info_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"info_stab\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"},{id:\"add\",patternId:[\"info_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BAR\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BAR\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"info_screen_music\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"level_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"paddle_dizzy\",\"fireball_over\",\"fog_over\",\"multiball_over\",\"deathball_over\",\"mirroredcontrols_over\",\"timebomb_over\",\"ghostball_over\"],delay:0,multi:!1},{instanceId:\"handle_long\",reTrig:100,eventMaps:[{id:\"eventMap\",\"in\":[\"countdown_init\"],out:\"countdown_long_start\",delay:500},{id:\"eventMap\",\"in\":[\"countdown_init\"],out:\"stop_immediate\",delay:0}],type:\"eventProcessor\",id:\"eventMapper\",clearPending:!1,triggers:[\"countdown_init\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"stop\",songPosition:\"ASAP\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"stop_immediate\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"start\",delay:0,tempo:126,beatsPerBar:16},{id:\"add\",patternId:[\"countlong_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countlong_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countlong_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countlong_synth_plucked\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countlong_synth_sharp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"beatEvent\",songPosition:\"NEXT_BEAT+1.6\",returnEvent:\"gameplay_init\",output:\"onEvent\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"countdown_long_start\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"level_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"level_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"gameplay_init\"],delay:0,multi:!1},{instanceId:\"handle_short\",reTrig:0,eventMaps:[{id:\"eventMap\",\"in\":[\"countdown_short\"],out:\"countdown_short_start\",delay:600},{id:\"eventMap\",\"in\":[\"countdown_short\"],out:\"gameplay_init\",delay:3450}],type:\"eventProcessor\",id:\"eventMapper\",clearPending:!1,triggers:[\"countdown_short\"],delay:0,multi:!1},{instanceId:\"delay\",reTrig:100,eventMaps:[{id:\"eventMap\",\"in\":[\"user_won_round\"],out:\"round_end_stop_music\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_round\"],out:\"round_end_stop_music\",delay:0},{id:\"eventMap\",\"in\":[\"user_won_match\"],out:\"round_end_stop_music\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_match\"],out:\"round_end_stop_music\",delay:0}],type:\"eventProcessor\",id:\"eventMapper\",clearPending:!1,triggers:[\"user_lost_match\",\"user_won_round\",\"user_lost_round\",\"user_won_match\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"stop\",songPosition:\"ASAP\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"round_end_stop_music\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"start\",tempo:126,beatsPerBar:16},{id:\"add\",patternId:[\"countshort_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countshort_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countshort_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countshort_synth_plucked\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"countshort_synth_sharp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"FIRST_BEAT\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"countdown_short_start\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"fog_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_synth_funk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_synth_sharp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fog_synth_warm\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"fog_activate\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"mirrored_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_lead_a\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_lead_b\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_synth_funk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_synth_plucked\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"mirrored_synth_sharp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"mirroredcontrols_activate\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"multi_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_synth_funk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_synth_plucked\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_synth_sharp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"multi_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"multiball_activate\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"ghost_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_synth_funk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_synth_warm\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"ghost_strings\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"ghostball_activate\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"time_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_stab\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_synth_plucked\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_synth_sharp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"time_synth_warm\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"timebomb_activate\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"death_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_lead_a\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_synth_plucked\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_lead_b\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"death_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"deathball_activate\"],delay:0,multi:!1},{instanceId:\"main\",flowItems:[{id:\"add\",patternId:[\"fire_bass_filter\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_bass_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_bass\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_synth_comp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_synth_funk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_synth_perc\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_synth_plucked\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_synth_pop\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_synth_sharp\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_synth_warm\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"},{id:\"add\",patternId:[\"fire_dm_kraftwerk\"],channel:\"main\",songPosition:\"NEXT_BEAT\",patternPosition:\"SYNC\",clearPending:!1,replaceActive:!1,setAsCurrent:!1,loop:!0,loopLength:128,clearPosition:\"NEXT_BEAT\"}],type:\"player\",id:\"beatPatternPlayer\",triggers:[\"fireball_activate\"],delay:0,multi:!1},{instanceId:\"transpose_mapper\",reTrig:100,eventMaps:[{id:\"eventMap\",\"in\":[\"user_won_round\"],out:\"transpose_midi\",delay:2e3},{id:\"eventMap\",\"in\":[\"user_lost_round\"],out:\"transpose_midi\",delay:2e3},{id:\"eventMap\",\"in\":[\"user_lost_match\"],out:\"transpose_midi\",delay:399},{id:\"eventMap\",\"in\":[\"user_lost_match\"],out:\"transpose_midi_reset\",delay:400},{id:\"eventMap\",\"in\":[\"countdown_init\"],out:\"transpose_midi_reset\",delay:0}],type:\"eventProcessor\",id:\"eventMapper\",clearPending:!1,triggers:[\"gameover_screen\",\"user_won_round\",\"user_lost_round\",\"countdown_init\",\"user_lost_match\"],delay:0,multi:!1},{instanceId:\"LevelTransposer\",type:\"customCode\",id:\"customCode\",triggers:[\"init_routing\",\"transpose_midi\",\"transpose_midi_reset\"],delay:0,multi:!1},{instanceId:\"midi_transposer\",_dynamicValues:[{key:\"transpose\",string:\"customCode:LevelTransposer:transposeValue\"}],transpose:0,dynamic:0,quantize:\"\",scale:\"\",root:\"\",customScale:\"\",type:\"midiProcessor\",id:\"midiProcessor\",triggers:[\"item_activate\",\"shield_up\",\"item_up\",\"paddle_fx\",\"shield_hit\",\"bass_filter\",\"lead_a\",\"lead_b\",\"strings\",\"synth_funk\",\"synth_plucked\",\"synth_sharp\",\"synth_warm\",\"bass\",\"bass_comp\",\"stab\",\"synth_comp\",\"synth_perc\",\"synth_pop\"],delay:0,multi:!1},{instanceId:\"delay_effect_sounds\",reTrig:0,eventMaps:[{id:\"eventMap\",\"in\":[\"pause\"],out:\"pause_delayed\",delay:400},{id:\"eventMap\",\"in\":[\"unpause\"],out:\"unpause_delayed\",delay:40},{id:\"eventMap\",\"in\":[\"info_screen\"],out:\"info_screen_delayed\",delay:400},{id:\"eventMap\",\"in\":[\"gameover_sign_in\"],out:\"gameover_sign_in_delayed\",delay:400}],type:\"eventProcessor\",id:\"eventMapper\",clearPending:!1,triggers:[\"pause\",\"info_screen\",\"unpause\"],delay:0,multi:!1},{delay:0,instanceId:\"win_round_buzz\",soundFile:\"win_round_buzz\",volume:0,loop:-1,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"user_won_round\"],multi:!1},{delay:0,instanceId:\"loose_round_buzz\",soundFile:\"loose_round_buzz\",volume:0,loop:-1,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"user_lost_round\",\"user_lost_match\"],multi:!1},{delay:0,instanceId:\"swish_small\",soundFiles:[\"swish_fast_1\",\"swish_fast_2\",\"swish_fast_3\"],generator:\"ROUND_ROBIN\",volume:0,reTrig:-1,returnEvent:\"\",returnEventTime:0,bus:\"my_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"stepPlay\",pan:0,preListen:0,priority:!1,triggers:[\"friend_accept\",\"info_screen_delayed\",\"friend_screen\",\"friend_arrived\",\"friend_waiting\",\"gameover_sign_in_delayed\",\"gameover_sign_out\",\"unpause_delayed\",\"pause_delayed\"],multi:!1},{delay:0,instanceId:\"swish_medium\",soundFile:\"swish_medium_1\",volume:0,loop:-1,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"friend_accept_out\",\"info_screen_out\",\"friend_screen_out\",\"friend_waiting_out\",\"friend_left\"],multi:!1},{delay:0,instanceId:\"click_1\",soundFile:\"click_1\",volume:-2,loop:-1,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"button_down\"],multi:!1},{delay:0,instanceId:\"click_2\",soundFile:\"click_2\",volume:0,loop:-1,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"share_click\",\"text_button_down\",\"small_button_down\"],multi:!1},{delay:0,instanceId:\"bulletproof_activate\",soundFile:\"bulletproof_shield\",volume:0,loop:-1,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"bulletproof_activate\"],multi:!1},{delay:0,instanceId:\"timebomb_over\",soundFile:\"timebomb_explosion\",volume:5,loop:-1,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"timebomb_over\",\"paddle_dizzy\"],multi:!1},{delay:0,instanceId:\"force_field\",soundFile:\"force_field_4453\",volume:5,loop:4453,reTrig:-1,returnEvent:\"\",returnEventTime:0,preListen:0,bus:\"pause_bus\",timingCorrection:\"PLAY\",type:\"sound\",id:\"genericPlay\",multiSuffix:\"\",pan:0,priority:!1,triggers:[\"force_show\"],multi:!1},{delay:0,targets:[\"force_field\"],type:\"sound\",id:\"soundStop\",instanceId:\"\",multiSuffix:\"\",triggers:[\"force_hide\",\"user_won_round\",\"user_lost_round\",\"user_won_match\",\"user_lost_match\"],multi:!1},{instanceId:\"extras_timpattern_mapper\",reTrig:0,eventMaps:[{id:\"eventMap\",\"in\":[\"extralife_activate\"],out:\"extralife_activate_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"extralife_activate\"],out:\"extralife_activate_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_paddle_grow\"],out:\"grow_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_paddle_grow\"],out:\"grow_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_paddle_shrink\"],out:\"shrink_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_paddle_shrink\"],out:\"shrink_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_paddle_grow\"],out:\"grow_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_paddle_grow\"],out:\"grow_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_paddle_shrink\"],out:\"shrink_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_paddle_shrink\"],out:\"shrink_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"paddle_dizzy\"],out:\"paddle_dizzy_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"paddle_dizzy\"],out:\"paddle_dizzy_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"paddle_dizzy\"],out:\"paddle_dizzy_dm_kraftwerk.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_screen_explode\"],out:\"screen_explode_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_screen_explode\"],out:\"screen_explode_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_screen_heal_start\"],out:\"screen_rebuild_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"opponent_screen_heal_start\"],out:\"screen_rebuild_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_won_round\"],out:\"win_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_won_round\"],out:\"win_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_won_round\"],out:\"win_synth_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_won_match\"],out:\"win_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_won_match\"],out:\"win_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_won_match\"],out:\"win_synth_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_round\"],out:\"loose_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_round\"],out:\"loose_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_round\"],out:\"loose_synth_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_match\"],out:\"loose_paddle_fx.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_match\"],out:\"loose_bass_comp.START\",delay:0},{id:\"eventMap\",\"in\":[\"user_lost_match\"],out:\"loose_synth_comp.START\",delay:0}],type:\"eventProcessor\",id:\"eventMapper\",clearPending:!1,triggers:[\"user_won_match\",\"user_lost_match\",\"user_lost_round\",\"user_won_round\",\"opponent_screen_heal_start\",\"opponent_screen_explode\",\"extralife_activate\",\"opponent_paddle_grow\",\"opponent_paddle_shrink\",\"user_paddle_grow\",\"user_paddle_shrink\",\"paddle_dizzy\"],delay:0,multi:!1},{instanceId:\"time_player\",behavior:\"DEFAULT\",type:\"player\",id:\"timePatternPlayer\",triggers:[\"loose_synth_comp.START\",\"loose_bass_comp.START\",\"loose_paddle_fx.START\",\"win_synth_comp.START\",\"win_bass_comp.START\",\"win_paddle_fx.START\",\"screen_rebuild_bass_comp.START\",\"screen_rebuild_paddle_fx.START\",\"screen_explode_paddle_fx.START\",\"screen_explode_bass_comp.START\",\"extralife_activate_paddle_fx.START\",\"extralife_activate_bass_comp.START\",\"grow_bass_comp.START\",\"shrink_bass_comp.START\",\"grow_paddle_fx.START\",\"shrink_paddle_fx.START\",\"paddle_dizzy_dm_kraftwerk.START\",\"paddle_dizzy_paddle_fx.START\",\"paddle_dizzy_bass_comp.START\"],delay:0,multi:!1},{instanceId:\"makeFx\",reTrig:0,noteMaps:[{id:\"noteMap\",triggerIn:\"bulletproof_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"bulletproof_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"deathball_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"extralife_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"fireball_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"fireball_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"fog_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"fog_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"ghostball_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"ghostball_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"laser_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"laser_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"laser_fire\",triggerOut:\"shield_hit\",note:\"E5\",velocity:127},{id:\"noteMap\",triggerIn:\"mirroredcontrols_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"mirroredcontrols_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"multiball_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"multiball_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"timebomb_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"timebomb_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"opponent_score_hit\",triggerOut:\"shield_hit\",note:\"E3\",velocity:90},{id:\"noteMap\",triggerIn:\"opponent_shield_hit\",triggerOut:\"shield_hit\",note:\"E3\",velocity:110},{id:\"noteMap\",triggerIn:\"paddleresize_spawn\",triggerOut:\"item_up\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"paddleresize_activate\",triggerOut:\"item_activate\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"user_score_hit\",triggerOut:\"shield_hit\",note:\"E3\",velocity:90},{id:\"noteMap\",triggerIn:\"user_shield_hit\",triggerOut:\"shield_hit\",note:\"E3\",velocity:110}],type:\"midiProcessor\",id:\"makeNote\",triggers:[\"shields_reset_up\",\"extralife_activate\",\"paddleresize_activate\",\"paddleresize_spawn\",\"user_score_hit\",\"opponent_score_hit\",\"laser_fire\",\"laser_spawn\",\"laser_activate\",\"extralife_spawn\",\"mirroredcontrols_activate\",\"mirroredcontrols_spawn\",\"fireball_activate\",\"fireball_spawn\",\"bulletproof_activate\",\"bulletproof_spawn\",\"multiball_activate\",\"multiball_spawn\",\"timebomb_activate\",\"timebomb_spawn\",\"ghostball_activate\",\"ghostball_spawn\",\"deathball_spawn\",\"extralife_activate\",\"user_shield_hit\",\"opponent_shield_hit\",\"opponent_score_hit\",\"fog_spawn\",\"fog_activate\"],delay:0,multi:!1},{instanceId:\"bounce_mapper\",reTrig:30,noteMaps:[{id:\"noteMap\",triggerIn:\"opponent_paddle_hit\",triggerOut:\"paddle_fx\",note:\"E2\",velocity:127},{id:\"noteMap\",triggerIn:\"user_paddle_hit\",triggerOut:\"paddle_fx\",note:\"E1\",velocity:127},{id:\"noteMap\",triggerIn:\"obstacle_hit\",triggerOut:\"paddle_fx\",note:\"E3\",velocity:127},{id:\"noteMap\",triggerIn:\"wall_hit\",triggerOut:\"paddle_fx\",note:\"B2\",velocity:127}],type:\"midiProcessor\",id:\"makeNote\",triggers:[\"opponent_paddle_hit\",\"user_paddle_hit\",\"obstacle_hit\",\"wall_hit\"],delay:0,multi:!1},{instanceId:\"shields_up_mapper\",reTrig:500,noteMaps:[{id:\"noteMap\",triggerIn:\"shields_reset_up\",triggerOut:\"shield_up\",note:\"E3\",velocity:127}],type:\"midiProcessor\",id:\"makeNote\",triggers:[\"shields_reset_up\"],delay:0,multi:!1},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:0,loop:!1,ampAttack:1,ampDecay:1,ampRelease:260,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"shield_up\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"shield_up\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:1,loop:!1,ampAttack:1,ampDecay:1,ampRelease:260,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"paddle_fx\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"paddle_fx\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:-1,loop:!1,ampAttack:1,ampDecay:1,ampRelease:260,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"item_activate\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"item_activate\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:1,loop:!1,ampAttack:1,ampDecay:1,ampRelease:260,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"shield_hit\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"shield_hit\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:1,loop:!1,ampAttack:1,ampDecay:1,ampRelease:260,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"item_up\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"item_up\"],delay:0,multi:!0},{instanceId:\"muteInst\",targetType:\"synth\",targets:[\"multi\"],targetParameter:\"volume\",multiSuffix:\"_mute\",value:-80,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"bass_filter_mute\",\"lead_a_mute\",\"lead_b_mute\",\"strings_mute\",\"synth_funk_mute\",\"synth_plucked_mute\",\"synth_sharp_mute\",\"synth_warm_mute\",\"dm_kraftwerk_mute\",\"bass_mute\",\"bass_comp_mute\",\"stab_mute\",\"synth_comp_mute\",\"synth_perc_mute\",\"synth_pop_mute\"],multi:!1},{instanceId:\"unmuteInst\",targetType:\"synth\",targets:[\"multi\"],targetParameter:\"volume\",multiSuffix:\"_unmute\",value:-5,duration:100,type:\"parameterProcessor\",id:\"transform\",delay:0,curve:0,triggers:[\"bass_filter_unmute\",\"lead_a_unmute\",\"lead_b_unmute\",\"strings_unmute\",\"synth_funk_unmute\",\"synth_plucked_unmute\",\"synth_sharp_unmute\",\"synth_warm_unmute\",\"dm_kraftwerk_unmute\",\"bass_unmute\",\"bass_comp_unmute\",\"stab_unmute\",\"synth_comp_unmute\",\"synth_perc_unmute\",\"synth_pop_unmute\"],multi:!1},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:1,loop:!1,ampAttack:1,ampDecay:100,ampRelease:300,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"bass_filter_low\",velocityLow:0,velocityHigh:50},{id:\"sampleMap\",name:\"bass_filter_mid\",velocityLow:51,velocityHigh:100},{id:\"sampleMap\",name:\"bass_filter_hi\",velocityLow:101,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"bass_filter\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-2,loop:!1,ampAttack:1,ampDecay:50,ampRelease:100,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"bass_comp\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:-2,loop:!1,ampAttack:1,ampDecay:1,ampRelease:220,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"bass\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:-4.5,loop:!1,ampAttack:1,ampDecay:50,ampRelease:100,ampSustain:1,ampVelocityRatio:0,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"stab\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-6,loop:!1,ampAttack:1,ampDecay:1,ampRelease:220,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"strings\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:-1,loop:!1,ampAttack:1,ampDecay:1,ampRelease:50,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"synth_comp\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-5.5,loop:!1,ampAttack:1,ampDecay:50,ampRelease:300,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"synth_funk\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:-13,loop:!1,ampAttack:1,ampDecay:1,ampRelease:50,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"synth_perc\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:0,loop:!1,ampAttack:1,ampDecay:50,ampRelease:100,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"synth_plucked\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!0,bus:\"pause_bus\",volume:-2,loop:!1,ampAttack:1,ampDecay:1,ampRelease:50,ampSustain:1,ampVelocityRatio:0,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"synth_pop\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-7.5,loop:!1,ampAttack:1,ampDecay:1,ampRelease:100,ampSustain:1,ampVelocityRatio:0,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"synth_sharp\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-13,loop:!1,ampAttack:1,ampDecay:1,ampRelease:200,ampSustain:1,ampVelocityRatio:0,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"synth_warm\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-8,loop:!1,ampAttack:1,ampDecay:1,ampRelease:500,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"lead_a\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-9,loop:!1,ampAttack:1,ampDecay:1,ampRelease:400,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"lead_b\"],delay:0,multi:!0},{instanceId:\"multi\",ignoreNoteOff:!1,bus:\"pause_bus\",volume:-3,loop:!1,ampAttack:1,ampDecay:50,ampRelease:200,ampSustain:1,ampVelocityRatio:1,filterOn:!1,audioNodes:[],sampleMapGroups:[{id:\"sampleMapGroup\",name:\"map1\",sampleMaps:[{id:\"sampleMap\",name:\"multi\",velocityLow:0,velocityHigh:127}]}],type:\"synth\",id:\"sampler\",filterAttack:0,filterDecay:0,filterRelease:0,filterSustain:1,filterVelocityRatio:1,filterQ:1e-4,filterFrequency:0,filterGain:0,triggers:[\"dm_kraftwerk\"],delay:0,multi:!0},{instanceId:\"midiLoader\",returnEvent:\"\",files:[{id:\"file\",type:\"beatPattern\",name:\"music\"},{id:\"file\",type:\"timePattern\",name:\"fx\"}],type:\"assetController\",id:\"loadMIDI\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_sampleMaps\",returnEvent:\"\",files:[{id:\"file\",name:\"samplemaps\"}],type:\"assetController\",id:\"loadSampleMap\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_fx\",returnEvent:\"\",files:[{id:\"file\",name:\"click_1\"},{id:\"file\",name:\"click_2\"},{id:\"file\",name:\"swish_fast_1\"},{id:\"file\",name:\"swish_fast_2\"},{id:\"file\",name:\"swish_fast_3\"},{id:\"file\",name:\"swish_medium_1\"},{id:\"file\",name:\"item_up_E3\"},{id:\"file\",name:\"paddlefx_E0\"},{id:\"file\",name:\"paddlefx_G0\"},{id:\"file\",name:\"paddlefx_B0\"},{id:\"file\",name:\"paddlefx_E1\"},{id:\"file\",name:\"paddlefx_G1\"},{id:\"file\",name:\"paddlefx_B1\"},{id:\"file\",name:\"paddlefx_E2\"},{id:\"file\",name:\"paddlefx_G2\"},{id:\"file\",name:\"paddlefx_B2\"},{id:\"file\",name:\"paddlefx_E3\"},{id:\"file\",name:\"paddlefx_G3\"},{id:\"file\",name:\"paddlefx_B3\"},{id:\"file\",name:\"item_activate_E1\"},{id:\"file\",name:\"item_activate_B1\"},{id:\"file\",name:\"item_activate_E2\"},{id:\"file\",name:\"shield_hit_E3\"},{id:\"file\",name:\"shield_hit_B3\"},{id:\"file\",name:\"shield_hit_E4\"},{id:\"file\",name:\"shield_hit_B4\"},{id:\"file\",name:\"loose_round_buzz\"},{id:\"file\",name:\"win_round_buzz\"},{id:\"file\",name:\"timebomb_explosion\"},{id:\"file\",name:\"force_field_4453\"},{id:\"file\",name:\"bulletproof_shield\"},{id:\"file\",name:\"shield_up\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_bass_comp\",returnEvent:\"\",files:[{id:\"file\",name:\"bass_comp_E-1\"},{id:\"file\",name:\"bass_comp_As-1\"},{id:\"file\",name:\"bass_comp_E0\"},{id:\"file\",name:\"bass_comp_As0\"},{id:\"file\",name:\"bass_comp_E1\"},{id:\"file\",name:\"bass_comp_As1\"},{id:\"file\",name:\"bass_comp_E2\"},{id:\"file\",name:\"bass_comp_As2\"},{id:\"file\",name:\"bass_comp_E3\"},{id:\"file\",name:\"bass_comp_As3\"},{id:\"file\",name:\"bass_comp_E4\"},{id:\"file\",name:\"bass_comp_As4\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_bass\",returnEvent:\"\",files:[{id:\"file\",name:\"bass_E0\"},{id:\"file\",name:\"bass_As0\"},{id:\"file\",name:\"bass_E1\"},{id:\"file\",name:\"bass_As1\"},{id:\"file\",name:\"bass_E2\"},{id:\"file\",name:\"bass_As2\"},{id:\"file\",name:\"bass_E3\"},{id:\"file\",name:\"bass_As3\"},{id:\"file\",name:\"bass_E4\"},{id:\"file\",name:\"bass_As4\"},{id:\"file\",name:\"bass_E5\"},{id:\"file\",name:\"bass_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_stab\",returnEvent:\"\",files:[{id:\"file\",name:\"stab_E0\"},{id:\"file\",name:\"stab_As0\"},{id:\"file\",name:\"stab_E1\"},{id:\"file\",name:\"stab_As1\"},{id:\"file\",name:\"stab_E2\"},{id:\"file\",name:\"stab_As2\"},{id:\"file\",name:\"stab_E3\"},{id:\"file\",name:\"stab_As3\"},{id:\"file\",name:\"stab_E4\"},{id:\"file\",name:\"stab_As4\"},{id:\"file\",name:\"stab_E5\"},{id:\"file\",name:\"stab_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_kraftwerk\",returnEvent:\"\",files:[{id:\"file\",name:\"kick\"},{id:\"file\",name:\"snare\"},{id:\"file\",name:\"hit\"},{id:\"file\",name:\"hihat\"},{id:\"file\",name:\"tapp_l\"},{id:\"file\",name:\"tapp_r\"},{id:\"file\",name:\"battery_1\"},{id:\"file\",name:\"battery_2\"},{id:\"file\",name:\"battery_3\"},{id:\"file\",name:\"battery_4\"},{id:\"file\",name:\"battery_5\"},{id:\"file\",name:\"battery_6\"},{id:\"file\",name:\"battery_7\"},{id:\"file\",name:\"battery_8\"},{id:\"file\",name:\"battery_9\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_synth_perc\",returnEvent:\"\",files:[{id:\"file\",name:\"synth_perc_E0\"},{id:\"file\",name:\"synth_perc_As0\"},{id:\"file\",name:\"synth_perc_E1\"},{id:\"file\",name:\"synth_perc_As1\"},{id:\"file\",name:\"synth_perc_E2\"},{id:\"file\",name:\"synth_perc_As2\"},{id:\"file\",name:\"synth_perc_E3\"},{id:\"file\",name:\"synth_perc_As3\"},{id:\"file\",name:\"synth_perc_E4\"},{id:\"file\",name:\"synth_perc_As4\"},{id:\"file\",name:\"synth_perc_E5\"},{id:\"file\",name:\"synth_perc_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_synth_pop\",returnEvent:\"\",files:[{id:\"file\",name:\"synth_pop_E0\"},{id:\"file\",name:\"synth_pop_As0\"},{id:\"file\",name:\"synth_pop_E1\"},{id:\"file\",name:\"synth_pop_As1\"},{id:\"file\",name:\"synth_pop_E2\"},{id:\"file\",name:\"synth_pop_As2\"},{id:\"file\",name:\"synth_pop_E3\"},{id:\"file\",name:\"synth_pop_As3\"},{id:\"file\",name:\"synth_pop_E4\"},{id:\"file\",name:\"synth_pop_As4\"},{id:\"file\",name:\"synth_pop_E5\"},{id:\"file\",name:\"synth_pop_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_synth_comp\",returnEvent:\"\",files:[{id:\"file\",name:\"synth_comp_E0\"},{id:\"file\",name:\"synth_comp_As0\"},{id:\"file\",name:\"synth_comp_E1\"},{id:\"file\",name:\"synth_comp_As1\"},{id:\"file\",name:\"synth_comp_E2\"},{id:\"file\",name:\"synth_comp_As2\"},{id:\"file\",name:\"synth_comp_E3\"},{id:\"file\",name:\"synth_comp_As3\"},{id:\"file\",name:\"synth_comp_E4\"},{id:\"file\",name:\"synth_comp_As4\"},{id:\"file\",name:\"synth_comp_E5\"},{id:\"file\",name:\"synth_comp_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_strings\",returnEvent:\"\",files:[{id:\"file\",name:\"strings_E0\"},{id:\"file\",name:\"strings_As0\"},{id:\"file\",name:\"strings_E1\"},{id:\"file\",name:\"strings_As1\"},{id:\"file\",name:\"strings_E2\"},{id:\"file\",name:\"strings_As2\"},{id:\"file\",name:\"strings_E3\"},{id:\"file\",name:\"strings_As3\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1},{instanceId:\"load_synth_plucked\",returnEvent:\"\",files:[{id:\"file\",name:\"synth_plucked_E0\"},{id:\"file\",name:\"synth_plucked_As0\"},{id:\"file\",name:\"synth_plucked_E1\"},{id:\"file\",name:\"synth_plucked_As1\"},{id:\"file\",name:\"synth_plucked_E2\"},{id:\"file\",name:\"synth_plucked_As2\"},{id:\"file\",name:\"synth_plucked_E3\"},{id:\"file\",name:\"synth_plucked_As3\"},{id:\"file\",name:\"synth_plucked_E4\"},{id:\"file\",name:\"synth_plucked_As4\"},{id:\"file\",name:\"synth_plucked_E5\"},{id:\"file\",name:\"synth_plucked_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_synth_sharp\",returnEvent:\"\",files:[{id:\"file\",name:\"synth_sharp_E1\"},{id:\"file\",name:\"synth_sharp_As1\"},{id:\"file\",name:\"synth_sharp_E2\"},{id:\"file\",name:\"synth_sharp_As2\"},{id:\"file\",name:\"synth_sharp_E3\"},{id:\"file\",name:\"synth_sharp_As3\"},{id:\"file\",name:\"synth_sharp_E4\"},{id:\"file\",name:\"synth_sharp_As4\"},{id:\"file\",name:\"synth_sharp_E5\"},{id:\"file\",name:\"synth_sharp_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_synth_funk\",returnEvent:\"\",files:[{id:\"file\",name:\"synth_funk_E0\"},{id:\"file\",name:\"synth_funk_As0\"},{id:\"file\",name:\"synth_funk_E1\"},{id:\"file\",name:\"synth_funk_As1\"},{id:\"file\",name:\"synth_funk_E2\"},{id:\"file\",name:\"synth_funk_As2\"},{id:\"file\",name:\"synth_funk_E3\"},{id:\"file\",name:\"synth_funk_As3\"},{id:\"file\",name:\"synth_funk_E4\"},{id:\"file\",name:\"synth_funk_As4\"},{id:\"file\",name:\"synth_funk_E5\"},{id:\"file\",name:\"synth_funk_As5\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_synth_warm\",returnEvent:\"\",files:[{id:\"file\",name:\"synth_warm_E0\"},{id:\"file\",name:\"synth_warm_As0\"},{id:\"file\",name:\"synth_warm_E1\"},{id:\"file\",name:\"synth_warm_As1\"},{id:\"file\",name:\"synth_warm_E2\"},{id:\"file\",name:\"synth_warm_As2\"},{id:\"file\",name:\"synth_warm_E3\"},{id:\"file\",name:\"synth_warm_As3\"},{id:\"file\",name:\"synth_warm_E4\"},{id:\"file\",name:\"synth_warm_As4\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_lead_a\",returnEvent:\"\",files:[{id:\"file\",name:\"lead_a_E1\"},{id:\"file\",name:\"lead_a_As1\"},{id:\"file\",name:\"lead_a_E2\"},{id:\"file\",name:\"lead_a_As2\"},{id:\"file\",name:\"lead_a_E3\"},{id:\"file\",name:\"lead_a_As3\"},{id:\"file\",name:\"lead_a_E4\"},{id:\"file\",name:\"lead_a_As4\"},{id:\"file\",name:\"lead_a_E5\"},{id:\"file\",name:\"lead_a_As5\"},{id:\"file\",name:\"lead_a_E6\"},{id:\"file\",name:\"lead_a_As6\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_lead_b\",returnEvent:\"\",files:[{id:\"file\",name:\"lead_b_E1\"},{id:\"file\",name:\"lead_b_As1\"},{id:\"file\",name:\"lead_b_E2\"},{id:\"file\",name:\"lead_b_As2\"},{id:\"file\",name:\"lead_b_E3\"},{id:\"file\",name:\"lead_b_As3\"},{id:\"file\",name:\"lead_b_E4\"},{id:\"file\",name:\"lead_b_As4\"},{id:\"file\",name:\"lead_b_E5\"},{id:\"file\",name:\"lead_b_As5\"},{id:\"file\",name:\"lead_b_E6\"},{id:\"file\",name:\"lead_b_As6\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"dmaf_ready\"],delay:0,multi:!1},{instanceId:\"load_bass_filter\",returnEvent:\"\",files:[{id:\"file\",name:\"bass_filter_low_E2\"},{id:\"file\",name:\"bass_filter_low_As2\"},{id:\"file\",name:\"bass_filter_low_E3\"},{id:\"file\",name:\"bass_filter_low_As3\"},{id:\"file\",name:\"bass_filter_low_E4\"},{id:\"file\",name:\"bass_filter_low_As4\"},{id:\"file\",name:\"bass_filter_low_E5\"},{id:\"file\",name:\"bass_filter_low_As5\"},{id:\"file\",name:\"bass_filter_low_E6\"},{id:\"file\",name:\"bass_filter_low_As6\"},{id:\"file\",name:\"bass_filter_mid_E2\"},{id:\"file\",name:\"bass_filter_mid_As2\"},{id:\"file\",name:\"bass_filter_mid_E3\"},{id:\"file\",name:\"bass_filter_mid_As3\"},{id:\"file\",name:\"bass_filter_mid_E4\"},{id:\"file\",name:\"bass_filter_mid_As4\"},{id:\"file\",name:\"bass_filter_mid_E5\"},{id:\"file\",name:\"bass_filter_mid_As5\"},{id:\"file\",name:\"bass_filter_mid_E6\"},{id:\"file\",name:\"bass_filter_mid_As6\"},{id:\"file\",name:\"bass_filter_hi_E2\"},{id:\"file\",name:\"bass_filter_hi_As2\"},{id:\"file\",name:\"bass_filter_hi_E3\"},{id:\"file\",name:\"bass_filter_hi_As3\"},{id:\"file\",name:\"bass_filter_hi_E4\"},{id:\"file\",name:\"bass_filter_hi_As4\"},{id:\"file\",name:\"bass_filter_hi_E5\"},{id:\"file\",name:\"bass_filter_hi_As5\"},{id:\"file\",name:\"bass_filter_hi_E6\"},{id:\"file\",name:\"bass_filter_hi_As6\"}],type:\"assetController\",id:\"loadSound\",triggers:[\"preload_assets\"],delay:0,multi:!1}]}\n}),dmaf(\"AudioNodes\",[\"DMAF\",\"Utils\",\"Instance\",\"events\"],function(e,t,i,n){function a(e){return(Math.exp(e)-Math.exp(-e))/(Math.exp(e)+Math.exp(-e))}function s(e){return 0===e?1:Math.abs(e)/e}function o(e,t){var i,n,a=0,s=0,o=0,r=0;return i=e.toExponential().match(/^.\\.?(.*)e(.+)$/),a=parseInt(i[2],10)-(i[1]+\"\").length,i=t.toExponential().match(/^.\\.?(.*)e(.+)$/),s=parseInt(i[2],10)-(i[1]+\"\").length,s>a&&(a=s),n=e%t,-100>a||a>20?(o=Math.round(Math.log(n)/Math.log(10)),r=Math.pow(10,o),(n/r).toFixed(o-a)*r):parseFloat(n.toFixed(-a))}var r=Object.create(null),l={lowpass:0,highpass:1,bandpass:2,lowshelf:3,highshelf:4,peaking:5,notch:6,allpass:7},c={32:.125,\"16T\":.16666666666666666,\"32D\":.1875,16:.25,\"8T\":.3333333333333333,\"16D\":.375,8:.5,\"4T\":.6666666666666666,\"8D\":.75,4:1,\"2T\":1.3333333333333333,\"4D\":1.5,2:2,\"2D\":3,1:4},d=function(e,t){e.value=t},u=Object.create(i,{activate:{writable:!0,value:function(e){this.input.disconnect(),this._activated=e,e?(this.input.connect(this.activateNode),this.activateCallback&&this.activateCallback(e)):this.input.connect(this.output)}},bypass:{get:function(){return this._activated},set:function(e){this.activate(e)}},active:{get:function(){return this._activated},set:function(e){this.activate(e)}},connect:{value:function(e){this.output.connect(e)}},connectInOrder:{value:function(e){for(var t=e.length-1;t--;)e[t].connect(e[t+1])}}});return r.createRecursive=function(e,i){for(var n,a,s=[],o=0;i.length>o;o++)n=i[o],a=new(r[t.capitalize(n.id)])(n),n.active?a.activate(!0):a.activate(!1),s.push(a),e.connect(a.input),e=a;return s},r.Filter=function(t){this.input=e.context.createGainNode(),this.filter=this.activateNode=e.context.createBiquadFilter(),this.output=e.context.createGainNode(),this.filter.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.filter,this.frequency=t.frequency,this.Q=t.resonance,this.filterType=t.filterType,this.gain=t.gain},r.Filter.prototype=Object.create(u,{name:{value:\"Filter\"},filterType:{enumerable:!0,get:function(){return this._filterType},set:function(e){this._filterType=e,this.filter.type=l[this._filterType.toLowerCase()]}},Q:{enumerable:!0,get:function(){return this.filter.Q},set:function(e){this.filter.Q.value=e}},gain:{enumerable:!0,get:function(){return this.filter.gain},set:function(e){this.filter.gain.value=e}},frequency:{enumerable:!0,get:function(){return this.filter.frequency},set:function(e){this.filter.frequency.value=e}}}),r.Cabinet=function(t){this.input=e.context.createGainNode(),this.activateNode=e.context.createGainNode(),this.convolver=this.newConvolver(t.impulsePath),this.makeupNode=e.context.createGainNode(),this.output=e.context.createGainNode(),this.activateNode.connect(this.convolver.input),this.convolver.output.connect(this.makeupNode),this.makeupNode.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.cabinet,this.makeupGain=t.makeupGain,this.convolver.activate(!0)},r.Cabinet.prototype=Object.create(u,{name:{value:\"Cabinet\"},makeupGain:{enumerable:!0,get:function(){return this.makeupNode.gain},set:function(e){this.makeupNode.gain.value=e}},newConvolver:{value:function(e){return new r.Convolver({impulse:e,dryLevel:0,wetLevel:1})}}}),r.Chorus=function(t){this.input=e.context.createGainNode(),this.attenuator=this.activateNode=e.context.createGainNode(),this.splitter=e.context.createChannelSplitter(2),this.delayL=e.context.createDelayNode(),this.delayR=e.context.createDelayNode(),this.feedbackGainNodeLR=e.context.createGainNode(),this.feedbackGainNodeRL=e.context.createGainNode(),this.merger=e.context.createChannelMerger(2),this.output=e.context.createGainNode(),this.lfoL=new r.LFO({target:this.delayL.delayTime,callback:d}),this.lfoR=new r.LFO({target:this.delayR.delayTime,callback:d}),this.input.connect(this.attenuator),this.attenuator.connect(this.output),this.attenuator.connect(this.splitter),this.splitter.connect(this.delayL,0),this.splitter.connect(this.delayR,1),this.delayL.connect(this.feedbackGainNodeLR),this.delayR.connect(this.feedbackGainNodeRL),this.feedbackGainNodeLR.connect(this.delayR),this.feedbackGainNodeRL.connect(this.delayL),this.delayL.connect(this.merger,0,0),this.delayR.connect(this.merger,0,1),this.merger.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.chorus,this.feedback=t.feedback,this.rate=t.rate,this.delay=t.delay,this.depth=t.depth,this.lfoR.phase=Math.PI/2,this.attenuator.gain.value=.6934,this.lfoL.activate(!0),this.lfoR.activate(!0)},r.Chorus.prototype=Object.create(u,{name:{value:\"Chorus\"},delay:{enumerable:!0,get:function(){return this._delay},set:function(e){this._delay=2e-4*Math.pow(10,2*e),this.lfoL.offset=this._delay,this.lfoR.offset=this._delay,this._depth=this._depth}},depth:{enumerable:!0,get:function(){return this._depth},set:function(e){this._depth=e,this.lfoL.oscillation=this._depth*this._delay,this.lfoR.oscillation=this._depth*this._delay}},feedback:{enumerable:!0,get:function(){return this._feedback},set:function(e){this._feedback=e,this.feedbackGainNodeLR.gain.value=this._feedback,this.feedbackGainNodeRL.gain.value=this._feedback}},rate:{enumerable:!0,get:function(){return this._rate},set:function(e){this._rate=e,this.lfoL._frequency=this._rate,this.lfoR._frequency=this._rate}}}),r.Compressor=function(t){this.input=e.context.createGainNode(),this.compNode=this.activateNode=e.context.createDynamicsCompressor(),this.makeupNode=e.context.createGainNode(),this.output=e.context.createGainNode(),this.compNode.connect(this.makeupNode),this.makeupNode.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.compressor,this.automakeup=t.automakeup,this.makeupGain=t.makeupGain,this.threshold=t.threshold,this.release=t.release,this.attack=t.attack,this.ratio=t.ratio,this.knee=t.knee},r.Compressor.prototype=Object.create(u,{name:{value:\"Compressor\"},computeMakeup:{value:function(){var e=4,t=this.compNode;return-(t.threshold.value-t.threshold.value/t.ratio.value)/e}},automakeup:{enumerable:!0,get:function(){return this._automakeup},set:function(e){this._automakeup=e,this._automakeup&&(this.makeupGain=this.computeMakeup())}},threshold:{enumerable:!0,get:function(){return this.compNode.threshold},set:function(e){this.compNode.threshold.value=e,this._automakeup&&(this.makeupGain=this.computeMakeup())}},ratio:{enumerable:!0,get:function(){return this.compNode.ratio},set:function(e){this.compNode.ratio.value=e,this._automakeup&&(this.makeupGain=this.computeMakeup())}},knee:{enumerable:!0,get:function(){return this.compNode.knee},set:function(e){this.compNode.knee.value=e,this._automakeup&&(this.makeupGain=this.computeMakeup())}},attack:{enumerable:!0,get:function(){return this.compNode.attack},set:function(e){this.compNode.attack.value=e/1e3}},release:{enumerable:!0,get:function(){return this.compNode.release},set:function(e){this.compNode.release=e/1e3}},makeupGain:{enumerable:!0,get:function(){return this.makeupNode.gain},set:function(e){var i=e;this.makeupNode.gain.value=t.dbToWAVolume(i)}}}),r.Convolver=function(t){this.input=e.context.createGainNode(),this.activateNode=e.context.createGainNode(),this.convolver=e.context.createConvolver(),this.dry=e.context.createGainNode(),this.filterLow=e.context.createBiquadFilter(),this.filterHigh=e.context.createBiquadFilter(),this.wet=e.context.createGainNode(),this.output=e.context.createGainNode(),this.activateNode.connect(this.filterLow),this.activateNode.connect(this.dry),this.filterLow.connect(this.filterHigh),this.filterHigh.connect(this.convolver),this.convolver.connect(this.wet),this.wet.connect(this.output),this.dry.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.convolver,this.dryLevel=t.dryLevel,this.wetLevel=t.wetLevel,this.highCut=t.highCut,this.buffer=t.impulse,this.lowCut=t.lowCut,this.level=t.level,this.filterHigh.type=0,this.filterLow.type=1},r.Convolver.prototype=Object.create(u,{name:{value:\"Convolver\"},lowCut:{get:function(){return this.filterLow.frequency},set:function(e){this.filterLow.frequency.value=e}},highCut:{get:function(){return this.filterHigh.frequency},set:function(e){this.filterHigh.frequency.value=e}},level:{get:function(){return this.output.gain},set:function(e){this.output.gain.value=e}},dryLevel:{get:function(){return this.dry.gain},set:function(e){this.dry.gain.value=e}},wetLevel:{get:function(){return this.wet.gain},set:function(e){this.wet.gain.value=e,this.wet.gain=e}},buffer:{enumerable:!1,get:function(){return this.convolver.buffer},set:function(t){var i=this.convolver,a=new XMLHttpRequest;return t?(a.open(\"GET\",t,!0),a.responseType=\"arraybuffer\",a.onreadystatechange=function(){4===a.readyState&&(300>a.status&&a.status>199||302===a.status)&&e.context.decodeAudioData(a.response,function(e){i.buffer=e},function(e){n.dispatch(\"log:error\",\"Convolver.setBuffer: Error decoding data\",e)})},a.send(null),void 0):(n.dispatch(\"log:error\",\"AudioNodes.Convolver.setBuffer: Missing impulse path!\"),void 0)}}}),r.Delay=function(t){this.input=e.context.createGainNode(),this.activateNode=e.context.createGainNode(),this.dry=e.context.createGainNode(),this.wet=e.context.createGainNode(),this.filter=e.context.createBiquadFilter(),this.delay=e.context.createDelayNode(),this.feedbackNode=e.context.createGainNode(),this.output=e.context.createGainNode(),this.activateNode.connect(this.delay),this.activateNode.connect(this.dry),this.delay.connect(this.filter),this.filter.connect(this.feedbackNode),this.feedbackNode.connect(this.delay),this.feedbackNode.connect(this.wet),this.wet.connect(this.output),this.dry.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.delay,this.tempoSync=t.tempoSync,this.tempoSync&&(this.subdivision=t.subdivision),this.delayTime=t.delayTime,this.feedback=t.feedback,this.wetLevel=t.wetLevel,this.dryLevel=t.dryLevel,this.cutoff=t.cutoff,this.filter.type=1},r.Delay.prototype=Object.create(u,{name:{value:\"Delay\"},tempoListener:{value:function(e){this.tempo=e,this.delayTime=this.tempo}},tempoSync:{get:function(){return this._tempoSync},set:function(t){if(t&&\"string\"==typeof t){var i=e.getInstance(\"player:\"+t);this.tempo=i?i.tempo:90,this._tempoSync=t,dmaf.addEventListener(\"tempo_\"+this._tempoSync,this.tempoListener.bind(this))}else this._tempoSync=!1}},subdivision:{get:function(){return this._subdivision},set:function(e){this._subdivision=e}},tempo:{get:function(){return this._tempo},set:function(e){this._tempo=e}},delayTime:{enumerable:!0,get:function(){return this.delay.delayTime},set:function(e){this.delay.delayTime.value=this._tempoSync?60*c[this.subdivision]/this.tempo:e/1e3}},wetLevel:{enumerable:!0,get:function(){return this.wet.gain},set:function(e){this.wet.gain.value=e}},dryLevel:{enumerable:!0,get:function(){return this.dry.gain},set:function(e){this.dry.gain.value=e}},feedback:{enumerable:!0,get:function(){return this.feedbackNode.gain},set:function(e){this.feedbackNode.gain.value=e}},cutoff:{enumerable:!0,get:function(){return this.filter.frequency},set:function(e){this.filter.frequency.value=e}}}),r.EnvelopeFollower=function(t){this.input=e.context.createGainNode(),this.jsNode=this.output=e.context.createJavaScriptNode(this.buffersize,1,1),this.input.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.envelopeFollower,this.attackTime=t.attackTime,this.releaseTime=t.releaseTime,this._envelope=0,this.target=t.target,this.callback=t.callback},r.EnvelopeFollower.prototype=Object.create(u,{name:{value:\"EnvelopeFollower\"},buffersize:{value:256},envelope:{value:0},sampleRate:{value:44100},attackTime:{enumerable:!0,get:function(){return this._attackTime},set:function(e){this._attackTime=e,this._attackC=Math.exp(-1/this._attackTime*this.sampleRate/this.buffersize)}},releaseTime:{enumerable:!0,get:function(){return this._releaseTime},set:function(e){this._releaseTime=e,this._releaseC=Math.exp(-1/this._releaseTime*this.sampleRate/this.buffersize)}},callback:{get:function(){return this._callback},set:function(e){this._callback=e}},target:{get:function(){return this._target},set:function(e){this._target=e}},activate:{value:function(t){this.activated=t,t?(this.jsNode.connect(e.context.destination),this.jsNode.onaudioprocess=this.returnCompute(this)):(this.jsNode.disconnect(),this.jsNode.onaudioprocess=null)}},returnCompute:{value:function(e){return function(t){e.compute(t)}}},compute:{value:function(e){var t,i,n,a,s=e.inputBuffer.getChannelData(0).length,o=e.inputBuffer.numberOfChannels;if(i=n=0,o>1)for(a=0;s>a;++a)for(;o>i;++i)t=e.inputBuffer.getChannelData(i)[a],n+=t*t/o;else for(a=0;s>a;++a)t=e.inputBuffer.getChannelData(0)[a],n+=t*t;n=Math.sqrt(n),n>this._envelope?(this._envelope*=this._attackC,this._envelope+=(1-this._attackC)*n):(this._envelope*=this._releaseC,this._envelope+=(1-this._releaseC)*n),this._callback(this._target,this._envelope)}}}),r.Equalizer=function(){function t(t){this._defaults=e.Settings.descriptors.type.audioNode.equalizer,this.nbands=t.bands.length;for(var i=0,n=this._nbands;n>i;i++);this.input=e.context.createGainNode(),this.output=e.context.createGainNode(),this.activateNode=e.context.createGainNode()}return t}(),r.Equalizer.prototype=Object.create(u,{name:{value:\"Equalizer\"},propertySearch:{value:/:bypass|:type|:frequency|:gain|:q/i}}),r.LFO=function(){function t(t){this.output=e.context.createJavaScriptNode(256,1,1),this.activateNode=e.context.destination,this.defaults=e.Settings.descriptors.type.audioNode.lfo,this.type=t.type,this.frequency=t.frequency,this.offset=t.offset,this.oscillation=t.oscillation,this.phase=t.phase,this.target=t.target,this.output.onaudioprocess=this.callback(t.callback)}return t.prototype=Object.create(u,{name:{value:\"LFO\"},bufferSize:{value:256},sampleRate:{value:44100},type:{enumerable:!0,get:function(){return this._type},set:function(e){this._type=e}},frequency:{get:function(){return this._frequency},set:function(e){this._frequency=e,this._phaseInc=2*Math.PI*this._frequency*this.bufferSize/this.sampleRate}},offset:{get:function(){return this._offset},set:function(e){this._offset=e}},oscillation:{get:function(){return this._oscillation},set:function(e){this._oscillation=e}},phase:{get:function(){return this._phase},set:function(e){this._phase=e}},target:{get:function(){return this._target},set:function(e){this._target=e}},activate:{value:function(t){this._activated=t,t?this.output.connect(e.context.destination):this.output.disconnect(e.context.destination)}},callback:{value:function(e){var t=this;return function(){t._phase+=t._phaseInc,t._phase>2*Math.PI&&(t._phase=0),e(t._target,t._offset+t._oscillation*Math.sin(t._phase))}}}}),t}(),r.Overdrive=function(t){this.input=e.context.createGainNode(),this.activateNode=e.context.createGainNode(),this.inputDrive=e.context.createGainNode(),this.waveshaper=e.context.createWaveShaper(),this.outputDrive=e.context.createGainNode(),this.output=e.context.createGainNode(),this.activateNode.connect(this.inputDrive),this.inputDrive.connect(this.waveshaper),this.waveshaper.connect(this.outputDrive),this.outputDrive.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.overdrive,this.ws_table=new Float32Array(this.k_nSamples),this.drive=t.drive,this.outputGain=t.outputGain,this.curveAmount=t.curveAmount,this.algorithm=t.algorithmIndex},r.Overdrive.prototype=Object.create(u,{name:{value:\"Overdrive\"},k_nSamples:{value:8192},drive:{get:function(){return this.inputDrive.gain},set:function(e){this._drive=e}},curveAmount:{get:function(){return this._curveAmount},set:function(e){this._curveAmount=e,void 0===this._algorithmIndex&&(this._algorithmIndex=0),this.waveshaperAlgorithms[this._algorithmIndex](this._curveAmount,this.k_nSamples,this.ws_table),this.waveshaper.curve=this.ws_table}},outputGain:{get:function(){return this.outputDrive.gain},set:function(e){var i=e;this._outputGain=t.dbToWAVolume(i)}},algorithm:{get:function(){return this._algorithmIndex},set:function(e){this._algorithmIndex=e,this.curveAmount=this._curveAmount}},waveshaperAlgorithms:{value:[function(e,t,i){var n,a,s=2*e/(1-e);for(n=0;t>n;n++)a=2*n/t-1,i[n]=(1+s)*a/(1+s*Math.abs(a))},function(e,t,i){var n,s,o;for(n=0;t>n;n++)s=2*n/t-1,o=(.5*Math.pow(s+1.4,2)-1)*o>=0?5.8:1.2,i[n]=a(o)},function(e,t,i){var n,s,o,r=1-e;for(n=0;t>n;n++)s=2*n/t-1,o=0>s?-Math.pow(Math.abs(s),r+.04):Math.pow(s,r),i[n]=a(2*o)},function(e,t,i){var n,a,o,r,l=1-e>.99?.99:1-e;for(n=0;t>n;n++)a=2*n/t-1,r=Math.abs(a),l>r?o=r:r>l?o=l+(r-l)/(1+Math.pow((r-l)/(1-l),2)):r>1&&(o=r),i[n]=s(a)*o*(1/((l+1)/2))},function(e,t,i){var n,a;for(n=0;t>n;n++)a=2*n/t-1,i[n]=-.08905>a?-3/4*(1-Math.pow(1-(Math.abs(a)-.032857),12)+1/3*(Math.abs(a)-.032847))+.01:a>=-.08905&&.320018>a?-6.153*a*a+3.9375*a:.630035},function(e,t,i){var n,a,s=2+Math.round(14*e),o=Math.round(Math.pow(2,s-1));for(n=0;t>n;n++)a=2*n/t-1,i[n]=Math.round(a*o)/o}]}}),r.Panner=function(t){this.input=e.context.createGainNode(),this.splitter=e.context.createChannelSplitter(2),this.lGain=e.context.createGainNode(),this.rGain=e.context.createGainNode(),this.merger=e.context.createChannelMerger(2),this.output=e.context.createGainNode(),this.input.connect(this.splitter),this.splitter.connect(this.lGain,0),this.splitter.connect(this.rGain,1),this.lGain.connect(this.merger,0,0),this.rGain.connect(this.merger,0,1),this.merger.connect(this.output),this.pan=t.value},r.Panner.prototype=Object.create(u,{pan:{get:function(){return this._value},set:function(e){var t=(e+100)/200;this._value=e,this.lGain.gain.value=Math.cos(t*Math.PI/2),this.rGain.gain.value=Math.sin(t*Math.PI/2)}}}),r.PingPongDelay=function(t){this.input=e.context.createGainNode(),this.activateNode=e.context.createGainNode(),this.dry=e.context.createGainNode(),this.splitter=e.context.createChannelSplitter(2),this.toMono=e.context.createGainNode(),this.wet=e.context.createGainNode(),this.feedbackNode=e.context.createGainNode(),this.delayL=new r.Delay(t),this.delayR=new r.Delay(t),this.merger=e.context.createChannelMerger(),this.output=e.context.createGainNode(),this.activateNode.connect(this.dry),this.activateNode.connect(this.splitter),this.splitter.connect(this.toMono,0,0),this.splitter.connect(this.toMono,1,0),this.toMono.connect(this.wet),this.wet.connect(this.delayL.delay),this.feedbackNode.connect(this.delayL.delay),this.delayL.delay.connect(this.delayR.delay),this.delayR.delay.connect(this.feedbackNode),this.delayL.delay.connect(this.merger,0,0),this.delayR.delay.connect(this.merger,0,1),this.dry.connect(this.output),this.merger.connect(this.output),this.delayL.feedback=0,this.delayR.feedback=0,this.delayL.wetLevel=1,this.delayR.wetLevel=1,this.delayL.dryLevel=0,this.delayR.dryLevel=0,this.defaults=e.Settings.descriptors.type.audioNode.pingPongDelay,this.cutoff=t.cutoff,this.tempoSync=t.tempoSync,this.tempoSync&&(this.subdivision=t.subdivision),this.delayTime=t.delayTime,this.feedback=t.feedback,this.wetLevel=t.wetLevel,this.dryLevel=t.dryLevel},r.PingPongDelay.prototype=Object.create(u,{name:{value:\"PingPongDelay\"},tempoSync:{get:function(){return this._tempoSync},set:function(t){var i=t?e.getInstance(\"player\",t):null;this.tempo=i?i.tempo:120,this._tempoSync=t,this.delayL.tempoSync=this._tempoSync,this.delayR.tempoSync=this._tempoSync}},tempo:{get:function(){return this._tempo},set:function(e){this._tempo=e,this.delayL.tempo=e,this.delayR.tempo=e}},subdivision:{get:function(){return this._subdivision},set:function(e){this._subdivision=e,this.delayL.subdivision=this._subdivision,this.delayR.subdivision=this._subdivision}},delayTime:{enumerable:!0,get:function(){return this._delayTime},set:function(e){this._tempoSync?(this._delayTime=60*c[this.subdivision]/this.tempo,this.delayL.delayTime=this._delayTime,this.delayR.delayTime=this._delayTime):(this._delayTime=e/1e3,this.delayL.delayTime=e,this.delayR.delayTime=e)}},wetLevel:{enumerable:!0,get:function(){return this.wet.gain},set:function(e){this.wet.gain.value=e}},dryLevel:{enumerable:!0,get:function(){return this.dry.gain},set:function(e){this.dry.gain.value=e}},feedback:{enumerable:!0,get:function(){return this.feedbackNode.gain},set:function(e){this.feedbackNode.gain.value=e}},cutoff:{enumerable:!0,get:function(){return this.delayL.filter.frequency},set:function(e){this.delayL.filter.frequency.value=e,this.delayR.filter.frequency.value=e}}}),r.Phaser=function(t){this.input=e.context.createGainNode(),this.splitter=this.activateNode=e.context.createChannelSplitter(2),this.filtersL=[],this.filtersR=[],this.feedbackGainNodeL=e.context.createGainNode(),this.feedbackGainNodeR=e.context.createGainNode(),this.merger=e.context.createChannelMerger(2),this.filteredSignal=e.context.createGainNode(),this.output=e.context.createGainNode(),this.lfoL=new r.LFO({target:this.filtersL,callback:this.callback}),this.lfoR=new r.LFO({target:this.filtersR,callback:this.callback});for(var i=this.stage;i--;)this.filtersL[i]=e.context.createBiquadFilter(),this.filtersR[i]=e.context.createBiquadFilter(),this.filtersL[i].type=7,this.filtersR[i].type=7;this.input.connect(this.splitter),this.input.connect(this.output),this.splitter.connect(this.filtersL[0],0,0),this.splitter.connect(this.filtersR[0],1,0),this.connectInOrder(this.filtersL),this.connectInOrder(this.filtersR),this.filtersL[this.stage-1].connect(this.feedbackGainNodeL),this.filtersL[this.stage-1].connect(this.merger,0,0),this.filtersR[this.stage-1].connect(this.feedbackGainNodeR),this.filtersR[this.stage-1].connect(this.merger,0,1),this.feedbackGainNodeL.connect(this.filtersL[0]),this.feedbackGainNodeR.connect(this.filtersR[0]),this.merger.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.phaser,this.rate=t.rate,this.baseModulationFrequency=t.baseModulationFrequency,this.depth=t.depth,this.feedback=t.feedback,this.stereoPhase=t.stereoPhase,this.lfoL.activate(!0),this.lfoR.activate(!0)},r.Phaser.prototype=Object.create(u,{name:{value:\"Phaser\"},stage:{value:4},callback:{value:function(e,t){for(var i=0;4>i;i++)e[i].frequency.value=t}},depth:{enumerable:!0,get:function(){return this._depth},set:function(e){this._depth=e,this.lfoL.oscillation=this._baseModulationFrequency*this._depth,this.lfoR.oscillation=this._baseModulationFrequency*this._depth}},rate:{enumerable:!0,get:function(){return this._rate},set:function(e){this._rate=e,this.lfoL.frequency=this._rate,this.lfoR.frequency=this._rate}},baseModulationFrequency:{enumerable:!0,get:function(){return this._baseModulationFrequency},set:function(e){this._baseModulationFrequency=e,this.lfoL.offset=this._baseModulationFrequency,this.lfoR.offset=this._baseModulationFrequency}},feedback:{get:function(){return this._feedback},set:function(e){this._feedback=e,this.feedbackGainNodeL.gain.value=this._feedback,this.feedbackGainNodeR.gain.value=this._feedback}},stereoPhase:{get:function(){return this._stereoPhase},set:function(e){this._stereoPhase=e;var t=this.lfoL._phase+this._stereoPhase*Math.PI/180;t=o(t,2*Math.PI),this.lfoR._phase=t}}}),r.Tremolo=function(t){this.input=e.context.createGainNode(),this.splitter=this.activateNode=e.context.createChannelSplitter(2),this.amplitudeL=e.context.createGainNode(),this.amplitudeR=e.context.createGainNode(),this.merger=e.context.createChannelMerger(2),this.output=e.context.createGainNode(),this.lfoL=new r.LFO({target:this.amplitudeL.gain,callback:d}),this.lfoR=new r.LFO({target:this.amplitudeR.gain,callback:d}),this.input.connect(this.splitter),this.splitter.connect(this.amplitudeL,0),this.splitter.connect(this.amplitudeR,1),this.amplitudeL.connect(this.merger,0,0),this.amplitudeR.connect(this.merger,0,1),this.merger.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.tremolo,this.rate=t.rate,this.intensity=t.intensity,this.stereoPhase=t.stereoPhase,this.lfoL.offset=1-this.intensity/2,this.lfoR.offset=1-this.intensity/2,this.lfoL.phase=this.stereoPhase*Math.PI/180,this.lfoL.activate(!0),this.lfoR.activate(!0)},r.Tremolo.prototype=Object.create(u,{name:{value:\"Tremolo\"},intensity:{enumerable:!0,get:function(){return this._intensity},set:function(e){this._intensity=e,this.lfoL.offset=this._intensity/2,this.lfoR.offset=this._intensity/2,this.lfoL.oscillation=this._intensity,this.lfoR.oscillation=this._intensity}},rate:{enumerable:!0,get:function(){return this._rate},set:function(e){this._rate=e,this.lfoL.frequency=this._rate,this.lfoR.frequency=this._rate}},steroPhase:{enumerable:!0,get:function(){return this._rate},set:function(e){this._stereoPhase=e;var t=this.lfoL._phase+this._stereoPhase*Math.PI/180;t=o(t,2*Math.PI),this.lfoR.phase=t}}}),r.WahWah=function(t){this.input=e.context.createGainNode(),this.activateNode=e.context.createGainNode(),this.envelopeFollower=new r.EnvelopeFollower({target:this,callback:function(e,t){e.sweep=t}}),this.filterBp=e.context.createBiquadFilter(),this.filterPeaking=e.context.createBiquadFilter(),this.output=e.context.createGainNode(),this.activateNode.connect(this.filterBp),this.filterBp.connect(this.filterPeaking),this.filterPeaking.connect(this.output),this.defaults=e.Settings.descriptors.type.audioNode.wahWah,this.init(),this.automode=t.enableAutoMode,this.resonance=t.resonance,this.sensitivity=t.sensitivity,this.baseFrequency=t.baseModulationFrequency,this.excursionOctaves=t.excursionOctaves,this.sweep=t.sweep,this.envelopeFollower.activate(!0)},r.WahWah.prototype=Object.create(u,{name:{value:\"WahWah\"},activateCallback:{value:function(e){this.automode=e}},automode:{get:function(){return this._automode},set:function(e){this._automode=e,e?(this.activateNode.connect(this.envelopeFollower.input),this.envelopeFollower.activate(!0)):(this.envelopeFollower.activate(!1),this.activateNode.disconnect(),this.activateNode.connect(this.filterBp))}},sweep:{enumerable:!0,get:function(){return this._sweep.value},set:function(e){this._sweep=Math.pow(e>1?1:0>e?0:e,this._sensitivity),this.filterBp.frequency.value=this._baseFrequency+this._excursionFrequency*this._sweep,this.filterPeaking.frequency.value=this._baseFrequency+this._excursionFrequency*this._sweep}},baseFrequency:{enumerable:!0,get:function(){return this._baseFrequency},set:function(e){this._baseFrequency=50*Math.pow(10,2*e),this._excursionFrequency=Math.min(this.sampleRate/2,this.baseFrequency*Math.pow(2,this._excursionOctaves)),this.filterBp.frequency.value=this._baseFrequency+this._excursionFrequency*this._sweep,this.filterPeaking.frequency.value=this._baseFrequency+this._excursionFrequency*this._sweep}},excursionOctaves:{enumerable:!0,get:function(){return this._excursionOctaves},set:function(e){this._excursionOctaves=e,this._excursionFrequency=Math.min(this.sampleRate/2,this.baseFrequency*Math.pow(2,this._excursionOctaves)),this.filterBp.frequency.value=this._baseFrequency+this._excursionFrequency*this._sweep,this.filterPeaking.frequency.value=this._baseFrequency+this._excursionFrequency*this._sweep}},sensitivity:{enumerable:!0,get:function(){return this._sensitivity},set:function(e){this._sensitivity=e,this._sensitivity=Math.pow(10,this._sensitivity)}},resonance:{enumerable:!0,get:function(){return this._resonance},set:function(e){this._resonance=e,this.filterPeaking.Q=this._resonance}},init:{value:function(){var t,i,n=Object.keys(this.defaults);for(this.output.gain.value=5,this.filterPeaking.type=5,this.filterBp.type=2,this.filterPeaking.frequency.value=100,this.filterPeaking.gain.value=20,this.filterPeaking.Q.value=5,this.filterBp.frequency.value=100,this.filterBp.Q.value=1,this.sampleRate=e.context.sampleRate,t=0,i=n.length;i>t;t++)this[n[t]]=this.defaults[n[t]].value}}}),r}),dmaf(\"Action\",[\"DMAF\",\"Utils\",\"events\"],function(e,t,i){function n(n){function s(s,o,r){var l,c,d;o=o||1e3*e.context.currentTime,c=n.multi?s:n.instanceId,n.multiSuffix&&(c=c.replace(n.multiSuffix,\"\")),l=e.getInstance(n.type,c||\"no_instance_id\"),l?l._dynamicValues&&a(l):(d=t.clone(n),l=e.createInstance(c,d),l._dynamicValues&&a(l),l.init(d)),dmaf.log&&i.dispatch(\"log:action\",s),l?l.onAction(s,o+n.delay,r,n):i.dispatch(\"log:error\",\"Action was unable to create a new instance\")}return s}function a(i){t.each(i._dynamicValues,function(n,a){i[a.key]=t.verify(i.defaults[a.key],e.getInstanceProperty(a.string))})}return n}),dmaf(\"Instance\",[\"Utils\"],function(e){var t,i,n=/\\:/;dmaf.hasContext&&(i=window.webkitAudioContext||window.AudioContext,t=Object.getPrototypeOf((new i).createGainNode().gain.constructor.prototype));var a={isDMAFInstance:!0,setInitProperties:function(e){for(var t,i=Object.keys(e),n=0,a=i.length;a>n;n++)t=i[n],this[t]=e[t];return this},init:function(){return this},onAction:function(){return this},returnChildInstance:function(e){var t,i,s,o,r;if(n.test(e)&&(t=e.split(n),t.length&&t.length>1))for(r=this,s=0,o=t.length;o>s;s++){if(i=t[s],r=r[i],\"object\"!=typeof r)return{instance:this,ref:e};if(a.isPrototypeOf(r))return t=t.slice(s+1).join(\":\"),r.returnChildInstance(t)}return{instance:this,ref:e}},setProperty:function(i,a,s,o){var r,l=this.returnChildInstance(i);return l.instance!==this?l.instance.setProperty(l.ref,a,s,o):n.test(i)?(events.dispatch(\"log:instance\",\"DMAF Does not support colon syntax for properties within arrays.\",i),void 0):void 0===this[i]?(events.dispatch(\"log:instance\",i,\"is not a valid property for instance type\",this.id),void 0):(a=e.verify(this.defaults[i],a),\"volume\"===i&&(a=Math.max(0,Math.floor(100*Math.pow(2,a/6))/100)),t.isPrototypeOf(this[i])?(o=o?o/1e3:0,s=s=s?s/1e3:0,r=s?\"linearRampToValueAtTime\":\"setValueAtTime\",this[i].cancelScheduledValues(o),this[i].setValueAtTime(this[i].value,o),this[i][r](a,s+o)):this[i]=a,void 0)}};return a}),dmaf(\"Property\",[\"DMAF\"],function(e){function t(t,i,a,s){var o=1e3*e.context.currentTime;this.time=t,this.value=i,this.parent=s,this.type=a,this.execute=(\"linear\"===a?n:this.done).bind(this),\"linear\"===a&&(t=this.parent._previous),this.id=setTimeout(this.execute,t>o?t-o:0)}function i(){this.startTime=this.parent._previous,this.startValue=this.parent.value}function n(){var t;void 0===this.startTime&&i.call(this),t=(1e3*e.context.currentTime-this.startTime)/(this.time-this.startTime),this.parent.value=this.startValue+(this.value-this.startValue)*t,t>.999?this.done():this.id=setTimeout(this.execute,20)}function a(e){this.value=e,this._previous=0,this._actions=[]}return t.prototype.done=function(){this.parent._previous=this.time,this.parent.value=this.value,this.parent._actions.splice(this.parent._actions.indexOf(this),1)},a.prototype.cancelScheduledValues=function(e){for(var t=this._actions.length;t--;)this._actions[t].time>=e&&this._actions.splice(t,1)},a.prototype.setValueAtTime=function(e,i){this._actions.push(new t(i,e,\"set\",this))},a.prototype.linearRampToValueAtTime=function(e,i){this._actions.push(new t(i,e,\"linear\",this))},a}),dmaf(\"context\",[],function(){function e(){return(new Date).getTime()/1e3}function t(){return n.currentTime=e(),setTimeout(t,40),context.currentTime}function i(){var e=n.createBufferSource();e.buffer=n.createBuffer(1,100,44100),e.noteOn(0),document.removeEventListener(a,i,!1)}var n;if(dmaf.hasContext){var a=\"createTouch\"in document?\"touchstart\":\"mousedown\",s=window.webkitAudioContext||window.AudioContext||null;return document.addEventListener(a,i,!1),n=new s}return Object.create?Object.create(null,{currentTime:{get:e}}):{currentTime:t()}}),dmaf(\"DMAF\",[\"InstanceManager\",\"Instance\",\"context\",\"events\"],function(e,t,i,n){function a(e){return function(t){var i,a;return d.test(t)?(i=t.split(d),i.length>2&&(a=i.slice(2),i.length=2,i.push(a))):i=arguments,i[0]?u[i[0]]?e.apply(u,i):(n.dispatch(\"log:core\",\"Invalid type!\",i[0]),null):(n.dispatch(\"log:core\",\"verifyQueryPartial, Missing arguments!\"),null)}}function s(t,i,n,a){this[t]=this[t]||Object.create(null),this[t].ids=this[t].ids||[],this[t].ids.push(i),n.prototype.defaults=this.Settings.descriptors.action[t][i]||{},this[t][i]=new e(n,a)}function o(e,t){for(var i,n,a=this[e].ids,s=0,o=a.length;o>s;s++)if(n=a[s],i=this[e][n].getInstance(t))return i;return null}function r(e,t,i){var a=this.getInstance(e,t);if(!a)return n.dispatch(\"log:core\",\"Missing instance\",e,t),null;for(var s=0,o=i.length;o>s&&void 0!==a&&(\"object\"==typeof a||\"function\"==typeof a);s++)a=a[i[s]];\nreturn s!==o?(n.dispatch(\"log:core\",\"Could not find property:\",i.join(\",\")),null):a}function l(e,t){var i;return t.instanceId=e,this[t.type]&&this[t.type][t.id]?i=this[t.type][t.id].createInstance(t):n.dispatch(\"log:core\",i.type,i.id,\"was not registered with dmaf.\"),i||{}}function c(e,t){var i=this.getInstance(e,t);return i?this[i.type][i.id].removeInstance(t):(n.dispatch(\"log:core\",\"DMAF.remove: Could not find instance\",e,t),!1)}var d=/[:]/,u={registeredObjects:{}};return Array.prototype.slice,console.log||function(){},u.getInstanceProperty=a(r),u.getInstance=a(o),u.registerInstance=s,u.removeInstance=c,u.createInstance=l,u.context=i,u}),dmaf(\"init\",[\"DMAF\",\"Utils\",\"Parse\",\"events\",\"Action\",\"log\"],function(e,t,i,n,a,s){return function(o,r,l,c,d,u){if(e.require=r,dmaf.isBrowser){if(!dmaf.hasContext)return e.require(\"public\"),n.dispatch(\"_internal:resolve_listeners\"),n.dispatch(\"_external:dmaf_fail\"),void 0;e.Settings={},dmaf.dev?(dmaf.log=!0,s(u),window.DMAF=e,e.Settings.descriptors=i(\"descriptors\",c),e.Settings.actions=i(\"actions\",d)):e.require(\"settings\"),o&&(e.Settings.assetsPath=o),t.each(l,function(t){switch(t){case\"init\":break;case\"settings\":break;default:e.require(t)}}),t.each(e.Settings.actions,function(i,s){e[s.type]&&e[s.type][s.id]?t.each(s.triggers,function(e,t){n.add(t,a(s))}):n.dispatch(\"log:core\",\"DMAF: Requested unregistered module!\",s)}),n.dispatch(\"preload_assets\"),n.once(\"_internal:preloads_complete\",function(){n.dispatch(\"log:core\",\"preloads_complete\"),n.dispatch(\"_internal:resolve_listeners\"),n.dispatch(\"init_routing\"),n.dispatch(\"dmaf_ready\"),n.dispatch(\"_internal:resolve_input\"),n.dispatch(\"log:core\",\"Dispatching external dmaf_ready\"),n.dispatch(\"_external:dmaf_ready\"),n.dispatch(\"log:core\",\"dmaf is now ready\")})}else dmaf.Parse=i}}),dmaf(\"public\",[\"DMAF\",\"events\"],function(e,t){function i(i,n,a){t.dispatch(\"log:public:tell\",i,n),dmaf.log&&console.log(\"dmaf.tell:\",i),a||(a=1e3*e.context.currentTime),t.dispatch(i,a,n)}function n(e,i){return t.add(\"_external:\"+e,i)}function a(e,i){return t.remove(\"_external:\"+e,i)}function s(e,i){return t.once(\"_external:\"+e,i)}function o(i,n){return\"string\"!=typeof i?(console.error(\"dmaf: You must provide a valid id for the object you wish to register.\"),2):i?n&&n instanceof Object?(n.instanceId||(n.instanceId=i),e.registeredObjects[i]?(console.log(\"You've already registered an object with id\",i),void 0):(t.dispatch(\"log:public:registerObject\",i,n),e.registeredObjects[i]=n,t.dispatch(i+\".CREATE\"),void 0)):(console.log(\"dmaf: You've tried to register an object not of type 'object'\"),3):(console.error(\"dmaf: You must provide a valid id for the object you wish to register.\"),1)}function r(i){t.dispatch(\"log:public:unregisterObject\",i);var n=e.registeredObjects[i],a=!1;return n&&(a=delete e.registeredObjects[i]),n=e.getInstance(\"customCode:\"+i),n&&(a=e.removeInstance(\"customCode:\"+i)),n=e.getInstance(\"mediaElement:\"+i),n&&(a=e.removeInstance(\"mediaElement:\"+i),t.dispatch(\"log:public:unregisterObject\",i)),a&&t.dispatch(i+\".REMOVE\"),delete e.registeredObjects[i]}function l(){t.dispatch(\"log:core\",\"resolving pending addListeners and registerObject calls.\"),dmaf.once.resolve(s),dmaf.addEventListener.resolve(n),dmaf.removeEventListener.resolve(a),dmaf.unregisterObject.resolve(r)}function c(){dmaf.tell.resolve?(t.dispatch(\"log:core\",\"resolving pending tells.\"),dmaf.tell.resolve(i)):(dmaf.tell=i,console.warn(\"dmaf: dmaf.tell has been overwritten. Unexpected behavior may occur.\")),dmaf.registerObject.resolve(o)}t.once(\"_internal:resolve_listeners\",l),t.once(\"_internal:resolve_input\",c)}),dmaf(\"events\",[],function(){function e(e){var n,a=o,s=Array.prototype.slice.call(arguments,0),r=t(e),l=[];i=0;for(var c=0,d=r.length;d>c&&(n=r[c],l.push(n.apply(null,s)),!i);c++);return i=a,l.length?l:null}function t(e){var t,i,n,a=e.split(l),s=r,o=[];for(i=0,n=a.length;n>i&&(t=s.names&&s.names[a[i]],t);i++)o=o.concat(t.listeners||[]),s=s.names[a[i]];return o}function i(){o=1}function n(e,t){for(var i=e.split(l),n=r,a=0,s=i.length;s>a;a++)n=n.names,n=n[c](i[a])&&n[i[a]]||(n[i[a]]={names:{}});for(n.listeners=n.listeners||[],a=0,s=n.listeners.length;s>a;a++)if(n.listeners[a]===t)return;n.listeners.push(t)}function a(e,t){var i=function(){return s(e,i),t.apply(this,arguments)};return n(e,i)}function s(e,t){var i,n,a,s,o,d,u,p=e.split(l),h=[r];for(s=0,o=p.length;o>s;s++)for(d=0;h.length>d;d++)a=[d,1],i=h[d].names,i[p[s]]&&a.push(i[p[s]]),h.splice.apply(h,a);for(s=0,o=h.length;o>s;s++)for(i=h[s];i.names;){if(t){if(i.listeners){for(d=0,u=i.listeners.length;u>d;d++)if(i.listeners[d]===t){i.listeners.splice(d,1);break}i.listeners.length||delete i.listeners}for(n in i.names)if(i.names[c](n)&&i.names[n].listeners){var m=i.names[n].listeners;for(d=0,u=m.length;u>d;d++)if(m[d]===t){m.splice(d,1);break}m.length||delete i.names[n].listeners}}else{delete i.listeners;for(n in i.names)i.names[c](n)&&i.names[n].listeners&&delete i.names[n].listeners}i=i.names}}var o,r={names:{}},l=/[\\:]/,c=\"hasOwnProperty\",d={add:n,remove:s,_events:r,listeners:t,stop:i,once:a,dispatch:e};return d}),dmaf(\"assetController\",[\"DMAF\",\"Utils\",\"Instance\",\"Assets\",\"Parse\",\"events\"],function(e,t,i,n,a,s){function o(e){return!(!f.canPlayType||!f.canPlayType(g[e]).replace(/no/,\"\"))}function r(){}function l(){}function c(){}function d(){}var u,p=\"assetController\",h={loadSampleMap:\"xml/\",loadMIDI:\"midi/\",loadSound:\"audio/\",loadCustomCode:\"js/\"},m=[\"ogg\",\"aac\",\"mp3\",\"wav\"],f=dmaf.isBrowser?document.createElement(\"audio\"):{},g={wav:'audio/wav; codecs=\"1\"',mp3:\"audio/mpeg;\",aac:'audio/mp4; codecs=\"mp4a.40.2\"',ogg:'audio/ogg; codecs=\"vorbis\"'},y=Object.create(i,{init:{value:function(){this.loadCount=0,-1!==this.triggers.indexOf(\"preload_assets\")&&(n.preloads+=this.files.length,this.preload=!0)}},onload:{value:function(){this.returnEvent&&s.dispatch(this.returnEvent),e.removeInstance(this.type,this.instanceId)}},onstep:{value:function(){s.dispatch(\"_internal:asset_loaded\",this.preload),++this.loadCount===this.fileNames.length&&this.onload()}},onAction:{value:function(){if(!this.inProgress){var i=e.Settings.assetsPath+h[this.id];this.fileNames=this.files.map(t.prop(\"name\")),this.inProgress=!0;for(var n=0,a=this.fileNames.length;a>n;n++)this.loadFile(i+this.fileNames[n]+this.format,this.fileNames[n],n);a||(s.dispatch(\"log:assets\",this.type,this.id,\"There are no files for this loader\"),this.onstep(),this.onload())}}}});if(f.canPlayType!==void 0)for(var _=0,v=m.length;v>_;_++)if(o(m[_])){u=\".\"+m[_];break}return void 0===u?s.dispatch(\"_external:dmaf_fail\"):(r.prototype=Object.create(y,{format:{value:\".js\"},loadFile:{value:function(e){var t=this,i=document.createElement(\"script\");i.type=\"text/javascript\",i.src=e,i.addEventListener(\"load\",function(){t.onstep(),void 0!==i.remove&&i.remove()}),document.body.appendChild(i)}}}),e.registerInstance(p,\"loadCustomCode\",r),l.prototype=Object.create(y,{format:{value:\".xml\"},loadFile:{value:function(e){function i(e){a(\"samplemap\",e)}var n={chain:[this.onstep],context:this,responseXML:!0,fail:function(){s.dispatch(\"log:assets\",\"Problem parsing samplemap file\"),this.onstep()}.bind(this)};t.ajax(e,i,n)}}}),e.registerInstance(p,\"loadSampleMap\",l),c.prototype=Object.create(y,{format:{value:\".mid\"},loadFile:{value:function(e,i,n){function o(e){a(\"midi\",e,this.files[n].type,i),this.onstep()}var r={override:\"text/plain; charset=x-user-defined\",expectType:\"string\",context:this,fail:function(){s.dispatch(\"log:assets\",\"Problem parsing midi file\",e),this.onstep()}.bind(this)};t.ajax(e,o,r)}}}),e.registerInstance(p,\"loadMIDI\",c),d.prototype=Object.create(y,{loadFile:{value:function(i,a){function o(t){u>0&&s.dispatch(\"log:assets\",\"Retry success\",a),e.context.decodeAudioData(t,c,d)}function r(){3>++u?(s.dispatch(\"log:assets\",\"Could not load audio file\",a,\"trying again.\"),t.ajax(i,o,l,\"buffer\")):(s.dispatch(\"log:assets\",\"Could not load audio file\",a),this.onstep())}var l={responseType:\"arraybuffer\",fail:r.bind(this)},c=function(e){n.buffer[a]=e,this.onstep()}.bind(this),d=function(e){s.dispatch(\"log:assets\",\"Could not decode file\",a,e),this.onstep()}.bind(this),u=0;t.ajax(i,o,l,\"buffer\")}},format:{value:u}}),e.registerInstance(p,\"loadSound\",d),void 0)}),dmaf(\"audioRouter\",[\"DMAF\",\"Utils\",\"InstanceManager\",\"Instance\",\"AudioNodes\"],function(e,t,i,n,a){function s(){this.input=e.context.createGainNode(),this.output=e.context.createGainNode()}var o=\"audioRouter\";s.prototype=Object.create(n,{init:{value:function(i){var n,s=this.input;this.effects=a.createRecursive(this.input,i.audioNodes),this.effects.length>0&&(s=this.effects[this.effects.length-1]),s.connect(this.output),t.each(this.out,function(t,i){n=e.getInstance(o,i),this.output.connect(n?n.input:e.context.destination)},this)}},volume:{get:function(){return this.output.gain},set:function(e){this.output.gain.value=t.dbToWAVolume(e)}},getAutomatableProperties:{value:function(e){return\"fx\"==e.substring(0,2)?this.effects[parseInt(e.substring(2),10)]:void 0}},setAutomatableProperty:{value:function(t,i,n,a){var s=n>0?\"linearRampToValueAtTime\":\"setValueAtAtTime\";switch(t){case\"volume\":i=parseFloat(i),t=\"gain\";break;case\"pan\":break;default:return}this.output[t].cancelScheduledValues(e.context.currentTime),this.output[t].setValueAtTime(this.output[t].value,e.context.currentTime),this.output[t][s](i,(a+n)/1e3)}},onAction:{value:function(){}}}),e.registerInstance(o,\"audioBus\",s)}),dmaf(\"beatPatternPlayer\",[\"DMAF\",\"TimeManager\",\"InstanceManager\",\"Instance\",\"beatPattern\",\"beatPosition\",\"beatPatternInstance\",\"Assets\",\"events\",\"Utils\"],function(e,t,i,n,a,s,o,r,l,c){function d(){this.state=this.STOPPED,this.pendingPatterns=[],this.activePatterns=[],this.pendingEvents=[],this.tempo=120,this.songPosition=new s(0,16,16),this.currentPattern=new o(this,{beatPattern:new a(\"master\",1),channel:\"master\",addAtSongPosition:new s(1,1,16),patternStartPosition:1,clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:16,clearPosition:new s(1,1,16)})}function u(){var t,i,n=(new Date).getTime(),a=1e3*e.context.currentTime;return p&&(u.lastDifference=t,p=!1),t=n-a,i=t-u.lastDifference,Math.abs(i)>5?(l.dispatch(\"log:instance:player:beatPatternPlayer\",\"DMAF: Adjusting next beat Time. Difference was \"+i+\"ms\"),u.lastDifference=t,i):0}var p=!0;d.prototype=Object.create(n,{STOPPED:{value:0},RUNNING:{value:1},tempo:{get:function(){return this._tempo},set:function(e){this._tempo=e,this.beatLength=250*(60/e)}},onAction:{value:function(i,n,a,s){if(s.flowItems){var o,r,l,d,u,p,h,m=s.flowItems;for(l=0,d=m.length;d>l;l++){if(o=c.clone(m[l]),\"trigger\"===o.patternId&&(o.patternId=i),o._dynamicValues)for(u=0,p=o._dynamicValues.length;p>u;u++)r=o._dynamicValues[u],o[r.key]=e.getInstanceProperty(r.string);switch(o.id){case\"start\":if(this.state===this.RUNNING)break;if(o.delay){var f=o.delay?n+o.delay:n;t.checkFunctionTime(f,this.start,[],this,o,f)}else this.start(o,n);break;case\"add\":for(u=0;o.patternId.length>u;u++)h=c.clone(o),h.patternId=o.patternId[u],l&&(h.replaceActive=!1,h.clearPending=!1,h.setAsCurrent=!1),this.addPattern(h);break;case\"stop\":if(this.state===this.STOPPED)break;this.stop(o);break;case\"beatEvent\":this.beatEvent(o)}}}}},addPattern:{value:function(e){if(this.state===this.RUNNING){e.beatPattern=r.getAsset(\"beatPattern\",e.patternId),e.addAtSongPosition=this.getSongPosition(e.songPosition),e.startPatternAtBeat=this.getStartAtBeat(e.patternPosition),e.clearPosition=this.getSongPosition(e.clearPosition);var t=new o(this,e);if(e.clearPending)if(\"main\"===e.channel)this.pendingPatterns.length=0;else for(var i=this.pendingPatterns.length;i--;)this.pendingPatterns[i].channel===e.channel&&this.pendingPatterns.splice(i,1);t.ERROR||this.pendingPatterns.push(t)}else l.dispatch(\"log:instance:player:beatPatternPlayer\",\"Cannot add pattern while player is not running.\",e.patternId)}},checkBeat:{value:function(){for(var t=1e3*e.context.currentTime;t-this.nextBeatTime-e.preListen>this.beatLength;)this.skipBeat(this.nextBeatTime);for(;t>=this.nextBeatTime-e.preListen;)this.updateBeat(this.nextBeatTime)}},skipBeat:{value:function(e){this.songPosition.gotoNextBeat(),this.nextBeatTime=e+this.beatLength;for(var t=0,i=this.activePatterns.length;i>t;t++)this.activePatterns[t].gotoNextBeat();this.updateActivePatterns()}},updateBeat:{value:function(e){this.nextBeatTime=e+this.beatLength-u(),this.songPosition.gotoNextBeat();for(var t=0,i=this.activePatterns.length;i>t;t++)this.activePatterns[t].gotoNextBeat();for(this.updateActivePatterns(),t=0,i=this.activePatterns.length;i>t;t++)this.activePatterns[t].executeEvents(e,this.beatLength);this.dispatchBeat()}},dispatchBeat:{value:function(){1===this.songPosition.beat%4&&l.dispatch(\"metronome\",0,{bar:this.songPosition.bar,beat:Math.floor(this.songPosition.beat/4)+1})}},updateActivePatterns:{value:function(){for(var e,t,i,n,a,s=0;this.pendingPatterns.length>s;s++)if(i=this.pendingPatterns[s].addAtSongPosition,i.bar===this.songPosition.bar&&i.beat===this.songPosition.beat){if(e=this.pendingPatterns[s],this.pendingPatterns.splice(s--,1),e.replaceActive)for(n=0,a=this.activePatterns.length;a>n;n++)(\"main\"===e.channel||e.channel===this.activePatterns[n].channel)&&(this.activePatterns[n].removeAtSongPosition=e.clearPosition);e.setAsCurrent&&(this.currentPattern=e),this.activePatterns.push(e)}for(s=0;this.activePatterns.length>s;s++){if(t=this.activePatterns[s].removeAtSongPosition,isNaN(t.beat))throw this.stop({songPosition:\"ASAP\"}),Error(\"NaN! beat\",this);t.bar===this.songPosition.bar&&t.beat===this.songPosition.beat?this.activePatterns.splice(s--,1):t.bar<this.songPosition.bar&&this.activePatterns.splice(s--,1)}}},start:{value:function(e,i){this.tempo=e.tempo||120,this.nextBeatTime=i,this.beatsPerBar=e.beatsPerBar,this.state=this.RUNNING,t.addFrameListener(\"checkBeat\",this.checkBeat,this)}},stop:{value:function(i){var n=this.getSongPosition(i.songPosition).getInBeats(),a=this.songPosition.getInBeats(),s=(n-a)*this.beatLength;s+=1e3*e.context.currentTime,s=Math.max(1e3*e.context.currentTime,s),t.checkFunctionTime(s,this.proceedStop,[],this,i)}},proceedStop:{value:function(){this.state=this.STOPPED,this.pendingPatterns.length=0,this.activePatterns.length=0,t.removeFrameListener(\"checkBeat\"),this.songPosition=new s(0,this.beatsPerBar,this.beatsPerBar),this.currentPattern=new o(this,{beatPattern:new a(\"MASTER\",1),channel:\"MASTER\",addAtSongPosition:new s(1,1,16),patternStartPosition:1,clearPending:!0,replaceActive:!0,setAsCurrent:!0,loop:!0,loopLength:16,clearPosition:new s(1,1,16)})}},beatEvent:{value:function(i){var n=this.getSongPosition(i.songPosition).getInBeats(),a=this.songPosition.getInBeats(),s=(n-a)*this.beatLength;switch(s+=1e3*e.context.currentTime,i.output){case\"onEvent\":t.checkFunctionTime(s,l.dispatch,this.pendingEvents,l,i.returnEvent);break;case\"dispatch\":t.checkFunctionTime(s,e.dispatch,this.pendingEvents,e,i.returnEvent)}}},getSongPosition:{value:function(e){var t,i=e,n=0,a=0,o=new s(this.songPosition.bar,this.songPosition.beat,this.beatsPerBar);switch(/\\+/.test(i)&&(t=i.split(\"+\"),i=t[0],t=t[1].split(\".\"),a=parseInt(t[0],10)||0,n=parseInt(t[1],10)||0),i){case\"NEXT_BEAT\":o.addOffset({bar:0,beat:1});break;case\"NEXT_BAR\":o.beat=1,o.bar++;break;case\"ASAP\":return o;default:l.dispatch(\"log:instance:player:beatPatternPlayer\",\"BeatPatternPlayer getSongPosition: Unrecognized songPosition \",i)}return o.bar+=a,o.beat+=n,o}},getStartAtBeat:{value:function(e){var t,i=e,n=0,a=0,s=this.currentPattern&&this.currentPattern.currentBeat||1;if(!i)return 1;switch(/\\+/.test(i)&&(t=i.split(\"+\"),i=t[0],t=t[1].split(\".\"),a=parseInt(t[0],10)||0,n=parseInt(t[1],10)||0),i){case\"FIRST_BEAT\":s=1;break;case\"SYNC\":s++;break;default:l.dispatch(\"log:instance:player:beatPatternPlayer\",\"BeatPatternPlayer: Unrecognized patternPosition \"+i)}return s+=a*(this.currentPattern&&this.currentPattern.beatsPerBar||16),s+=n}}}),e.registerInstance(\"player\",\"beatPatternPlayer\",d)}),dmaf(\"customCode\",[\"DMAF\",\"InstanceManager\",\"Instance\",\"events\"],function(e,t,i,n){function a(){}function s(){}a.prototype=Object.create(i),e.registerInstance(\"customCode\",\"customCode\",a),e.customCode.customCode.createInstance=function(t){if(e.customCode[t.instanceId]){var i=e.customCode[t.instanceId].createInstance(t);return i}n.dispatch(\"log:error\",t.instanceId,\"was not registered with DMAF\")},s.prototype=Object.create(i,{onAction:{value:function(){var t=e.registeredObjects[this.instanceId];t&&(this.obj=t)}}}),e.registerInstance(\"customCode\",\"userObject\",s)}),dmaf(\"eventProcessor\",[\"DMAF\",\"events\",\"TimeManager\",\"InstanceManager\",\"Instance\",\"Utils\"],function(e,t,i,n,a,s){function o(){}function r(){}var l=\"eventProcessor\",c=s.prop(\"in\");o.prototype=Object.create(a,{init:{value:function(){this.lastActionTime=this.reTrig,this.pending=[]}},send:{value:function(e,n,a,s){return e===a?(t.dispatch(\"log:error:eventMapper\",e,\"is the same in event as output. Ignoring...\"),void 0):(t.dispatch(\"log:instance:eventProcessor:eventMapper\",\"sending\",a),i.checkFunctionTime(n,t.dispatch,this.pending,t,a,n,s),void 0)}},onAction:{value:function(e,t,n){var a,o,r,l,d=this;t-this.lastActionTime<this.reTrig||(this.clearPending&&this.pending.length&&i.dropPendingArray(this.pending),s.each(this.eventMaps,function(i,s){a=(s.delay||0)+t,o=s.out,r=c(s),l=\"multi\"===r[0]||-1!==r.indexOf(e),l&&d.send(e,a,o,n)}),this.lastActionTime=t)}}}),e.registerInstance(l,\"eventMapper\",o),r.prototype=Object.create(a,{init:{value:function(){for(var e=0,i=this.eventMaps.length;i>e;e++)this.eventMaps[e][\"in\"]=parseInt(this.eventMaps[e][\"in\"],10),isNaN(this.eventMaps[e][\"in\"])&&t.dispatch(\"log:error\",\"In value for MidiNoteMapper is NaN!\")}},onAction:{value:function(e,i,n){if(n&&n.midiNote)for(var a=0,s=this.eventMaps.length;s>a;a++)this.eventMaps[a][\"in\"]===n.midiNote&&t.dispatch(this.eventMaps[a].out,i,n)}}}),e.registerInstance(l,\"midiNoteMapper\",r)}),dmaf(\"mediaElement\",[\"DMAF\",\"events\",\"TimeManager\",\"InstanceManager\",\"Instance\"],function(e,t,i,n,a){function s(){}function o(){}var r=\"mediaElement\";s.prototype=Object.create(a,{currentTime:{get:function(){return this.element?this.element.currentTime:void 0}},onAction:{value:function(){if(this.element)return null;var n=this.instanceId,a=e.registeredObjects[n];a?a instanceof HTMLElement&&(\"VIDEO\"===a.tagName||\"AUDIO\"===a.tagName?(this.element=a,this.playing=!1,this.lastPlayTime=a.currentTime,i.addFrameListener(this.type+\":\"+this.instanceId,this.poll,this)):t.dispatch(\"log:instance:mediaElement\",\"DMAF does not support registering HTML elements other than <video> and <audio>\")):t.dispatch(\"log:instance:mediaElement\",\"DMAF Could not locate mediaElement with id\",this.instanceId)}},poll:{value:function(){this.lastPlayTime===this.element.currentTime?this.playing&&(t.dispatch(this.instanceId+\".STOP\",1e3*e.context.currentTime),this.playing=!1):this.lastPlayTime-this.element.currentTime>.25?t.dispatch(this.instanceId+\".START\",1e3*(e.context.currentTime-this.currentTime)):this.element.currentTime-this.lastPlayTime>.25?t.dispatch(this.instanceId+\".START\",1e3*(e.context.currentTime-this.currentTime)):this.playing||(t.dispatch(this.instanceId+\".START\",1e3*(e.context.currentTime-this.currentTime)),this.playing=!0),this.lastPlayTime=this.element.currentTime}}}),e.registerInstance(r,\"mediaElement\",s),e.mediaElement.mediaElement.removeInstance=function(t){var n=e.getInstance(\"mediaElement:\"+t);return n&&i.removeFrameListener(r+\":\"+t),delete this.activeInstances[t]},o.prototype=Object.create(a,{onAction:{value:function(e,t){var i,n=/CREATE|REMOVE/.exec(e);n.length&&(n=n[0].toLowerCase(),i=e.split(\".\")[0],this[n](t,i))}},create:{value:function(t,n){var a=e.mediaElement.mediaElement.createInstance({instanceId:n,type:r,id:\"mediaElement\"});i.checkFunctionTime(t,a.onAction,[],a)}},remove:{value:function(t,i){return e.mediaElement.mediaElement.removeInstance(i)}}}),e.registerInstance(\"control\",\"mediaController\",o,!0)}),dmaf(\"midiProcessor\",[\"DMAF\",\"events\",\"Utils\",\"InstanceManager\",\"Instance\"],function(e,t,i,n,a){function s(){}function o(){}var r=\"midiProcessor\",l={OFF:[0,0,0,0,0,0,0,0,0,0,0,0],major:[0,-1,0,-1,0,0,-1,0,-1,0,-1,0],harmonicMinor:[0,1,0,0,-1,0,1,0,0,-1,1,0],naturalMinor:[0,-1,0,0,-1,0,-1,0,0,-1,0,-1],majorPentatonic:[0,1,0,1,0,-1,1,0,1,0,-1,1],minorPentatonic:[0,-1,1,0,-1,0,1,0,-1,1,0,-1],dorian:[0,1,0,0,-1,0,1,0,1,0,0,-1],phrygian:[0,0,-1,0,-1,0,1,0,0,-1,0,-1],lydian:[0,1,0,1,0,1,0,0,1,0,1,0],mixolydian:[0,1,0,1,0,0,-1,0,-1,0,-1],locrian:[0,0,-1,0,-1,0,0,-1,0,-1,0,-1],doubleHarmonic:[0,0,-1,1,0,0,1,0,0,-1,1,0],halfDim:[0,1,0,0,-1,0,0,-1,0,-1,0,-1],pentatonic:[0,-1,-2,0,-1,0,-1,0,-1,-2,0,-1]},c={C:0,\"C#\":1,D:2,\"D#\":3,E:4,F:5,\"F#\":6,G:7,\"G#\":8,A:9,\"A#\":10,B:11};s.prototype=Object.create(a,{updateValues:{value:[\"transpose\",\"scale\",\"root\"]},scale:{get:function(){return this._scale},set:function(e){this._scale=l[e]}},root:{get:function(){return this._root},set:function(e){this._root=c[e]}},onAction:{value:function(e,i,n){return n?n.midiNote?(this.transpose&&(this.transpose=parseInt(this.transpose,10),n.midiNote+=this.transpose),this.scale&&this.quantizeToScale(n),void 0):(t.dispatch(\"log:error\",\"no midiNote for\",e),void 0):(t.dispatch(\"log:error\",\"no eventProperties for\",e),void 0)}},quantizeToScale:{value:function(e){var t;return e.midiNote&&(t=e.midiNote%12,t-=this._root,0>t&&(t=12+t),e.midiNote+=this.scale[t]),e}}}),e.registerInstance(r,\"midiProcessor\",s),o.prototype=Object.create(a,{init:{value:function(){this.lastActionTime=this.reTrig;for(var e=0,t=this.noteMaps.length;t>e;e++)this.noteMaps[e].midiNote=i.toMIDINote(this.noteMaps[e].note)}},onAction:{value:function(e,i){var n;if(!(i-this.lastActionTime<this.reTrig)){for(var a=0,s=this.noteMaps.length;s>a;a++)e===this.noteMaps[a].triggerIn&&(n={type:\"noteOn\",midiNote:this.noteMaps[a].midiNote,velocity:this.noteMaps[a].velocity,duration:this.noteMaps[a].duration},t.dispatch(this.noteMaps[a].triggerOut,i,n));this.lastActionTime=i}}}}),e.registerInstance(r,\"makeNote\",o)}),dmaf(\"parameterProcessor\",[\"DMAF\",\"TimeManager\",\"InstanceManager\",\"Instance\",\"events\"],function(e,t,i,n,a){function s(){this.timeoutContainer=[]}function o(){}var r=\"parameterProcessor\";s.prototype=Object.create(n,{onAction:{value:function(e,i){this.targets.length&&(\"multi\"===this.targets[0]&&(this.targets=[e.replace(this.multiSuffix,\"\")]),t.checkFunctionTime(i,this.execute,this.timeoutContainer,this,i))}},execute:{value:function(t){for(var i,n=this.targets.slice(0);n.length;)i=e.getInstance(this.targetType,n.shift()),i&&(a.dispatch(\"log:instance:parameterProcessor:transform\",\"Transforming\",this.targetParameter,\"of\",i.instanceId),i.setProperty(this.targetParameter,this.value,this.duration,t))}}}),e.registerInstance(r,\"transform\",s),o.prototype=Object.create(n,{onAction:{value:function(t,i,n){var a,s,o;if(n&&void 0!==n.value)for(var r=0,l=this.macroTargets.length;l>r;r++)if(a=this.macroTargets[r],o=e.getInstance(a.targetInstance)){switch(s=n.value,a.curve){case\"EXP\":s=Math.pow(s,2);break;case\"LOG\":s=Math.log(0!==s?s:s+1e-16)}s=a.min+(a.max-a.min)*s,o.setProperty(a.targetParameter,s,n.duration||0,i)}}}}),e.registerInstance(r,\"macro\",o)}),dmaf(\"sound\",[\"DMAF\",\"Utils\",\"TimeManager\",\"events\",\"InstanceManager\",\"Instance\",\"Iterator\",\"Assets\"],function(e,t,i,n,a,s,o,r){function l(){this.output=e.context.createGainNode()}function c(t){this.iterator=new o(t.soundFiles,t.generator),this.output=e.context.createGainNode()}function d(){}function u(t,i){e.context.currentTime>i&&(i=e.context.currentTime+this.delay);var n=t.replace(this.multiSuffix,\"\"),a=e.getInstance(\"sound\",n);a&&a.stop(i)}function p(t,i){var n;1e3*e.context.currentTime>i&&(i=1e3*e.context.currentTime+this.delay);for(var a=0,s=this.targets.length;s>a;a++)n=e.getInstance(\"sound\",this.targets[a]),n&&n.stop(i)}var h=\"sound\",m=0,f=Object.create(s,{init:{value:function(t){if(this.pendingPlays=[],this.pendingStops=[],this.pendingEvents=[],this.pendingSoftLoop=[],this.sounds=[],this.playing=!1,this.previousActionTime=0,t.bus&&\"master\"!==t.bus){var i=e.getInstance(\"audioRouter\",t.bus);this.targetBus=i?i.input:e.context.destination}else this.targetBus=e.context.destination;this.output.connect(this.targetBus)}},checkFinished:{value:function(){this.sounds=this.sounds.filter(function(e){return 3!==e.playbackState})}},clearAll:{value:function(){for(var e=this.sounds,t=e.length;t--;)this.sounds[t].noteOff(0);this.sounds.length=0,this.playing=!1}},createSound:{value:function(){var t=e.context.createBufferSource(),i=r.getAsset(\"buffer\",this.getSoundFile());return i?(t.id=m++,t.buffer=i,t.connect(this.output),-2===this.loop&&(t.loop=!0),t):(n.dispatch(\"log:instance:sound:genericPlay\",\"Buffer is missing. Check soundFile property.\"),{buffer:{duration:-1},noteOn:function(){},noteGrainOn:function(){}})}},dispose:{value:function(e){for(var t=this.sounds.length;t--;)this.sounds[t].id===e&&this.sounds.splice(t,1);this.playing=!!this.sounds.length}},play:{value:function(e){this.checkFinished(),i.dropPendingArray(this.pendingStops),this.playing?(this.reTrig>-1&&(i.dropPendingArray(this.pendingPlays),i.dropPendingArray(this.pendingEvents)),0===this.reTrig||\"RESYNC\"===this.timingCorrection?(n.dispatch(\"log:instance:sound\",\"scheduling\",this.instanceId,\"for\",e),i.checkFunctionTime(e,this.proceedPlay,this.pendingPlays,this,e)):this.reTrig>0&&e-this.previousActionTime>this.reTrig&&(this.previousActionTime=e,n.dispatch(\"log:instance:sound\",\"scheduling\",this.instanceId,\"for\",e),i.checkFunctionTime(e,this.proceedPlay,this.pendingPlays,this,e))):(this.previousActionTime=e,n.dispatch(\"log:instance:sound\",\"scheduling\",this.instanceId,\"for\",e),i.checkFunctionTime(e,this.proceedPlay,this.pendingPlays,this,e))}},proceedPlay:{value:function(t){n.dispatch(\"log:instance:sound\",\"playing\",this.instanceId,\"at\",Math.floor(1e3*e.context.currentTime));var a=this.createSound(),s=Math.abs(t-1e3*e.context.currentTime),o=1e3*a.buffer.duration,r=o-s,l=t+(this.loop||o);switch(this.timingCorrection){case\"PLAY\":a.noteOn(t/1e3);break;case\"SYNC\":if(0>=r)return;a.noteGrainOn(Math.max(0,t/1e3),s/1e3,r/1e3);break;case\"RESYNC\":if(0>=r)return;this.clearAll(),a.noteGrainOn(Math.max(0,t/1e3),s/1e3,r/1e3)}i.dropPendingArray(this.pendingEvents),this.returnEvent&&i.checkFunctionTime(t+o+this.returnEventTime,n.dispatch,this.pendingEvents,n,this.returnEvent,t+o+this.returnEventTime),this.loop>-1&&(i.checkFunctionTime(l,this.proceedPlay,this.pendingSoftLoop,this,l),i.checkFunctionTime(l,this.dispose,[],this,a.id),a.noteOff(t/1e3+a.buffer.duration)),-2===this.loop||i.checkFunctionTime(t+o,this.dispose,[],this,a.id),this.playing=!0,this.sounds.push(a)}},stop:{value:function(t){n.dispatch(\"log:instance:sound\",\"scheduling stop\",this.instanceId,\"at\",Math.floor(1e3*e.context.currentTime)),i.dropPendingArray(this.pendingPlays),i.dropPendingArray(this.pendingStops),i.checkFunctionTime(t,this.proceedStop,this.pendingStops,this)}},proceedStop:{value:function(){n.dispatch(\"log:instance:sound\",\"Stopping\",this.instanceId,\"at\",Math.floor(1e3*e.context.currentTime)),this.sounds.length,i.dropPendingArray(this.pendingEvents),i.dropPendingArray(this.pendingSoftLoop),this.clearAll(),e.sound[this.id].removeInstance(this.instanceId)}},volume:{get:function(){return this.output.gain},set:function(e){this._volume=e,this.waVolume=t.dbToWAVolume(this._volume),this.output.gain.value=this.waVolume}},onAction:{value:function(e,t){\"multi\"===this.soundFile&&(this.soundFile=e.replace(this.multiSuffix,\"\")),this.play(t)}}});l.prototype=Object.create(f,{getSoundFile:{value:function(){return this.soundFile}}}),e.registerInstance(h,\"genericPlay\",l),c.prototype=Object.create(f,{getSoundFile:{value:function(){return this.iterator.getNext()}}}),e.registerInstance(h,\"stepPlay\",c),d.prototype=Object.create(s,{init:{value:function(){this.onAction=\"multi\"===this.targets[0]?u:p}}}),e.registerInstance(h,\"soundStop\",d,!0)}),dmaf(\"stateProcessor\",[\"DMAF\",\"InstanceManager\",\"Instance\",\"events\"],function(e,t,i,n){function a(){this.value=void 0,this.previous=void 0}var s=\"stateProcessor\",o=\"in\";a.prototype=Object.create(i,{onAction:{value:function(t){var i,a,s,r,l;for(a=0,s=this.stateMaps.length;s>a;a++)for(r=0,l=this.stateMaps[a][o].length;l>r;r++)this.stateMaps[a][o][r]===t&&(i=this.stateMaps[a].state,this.stateMaps[a]._dynamicValues&&(i=e.getInstanceProperty(this.stateMaps[a]._dynamicValues[0].string)),a=s,r=l);if(!i)return n.dispatch(\"log:instance:stateProcessor\",\"No state found for\",t),!1;switch(this.update){case\"always\":this.previous=this.value,this.value=i;break;case\"onChange\":i!==this.value&&(this.previous=this.value,this.value=i)}}}}),e.registerInstance(s,\"state\",a)}),dmaf(\"synth\",[\"DMAF\",\"Utils\",\"InstanceManager\",\"TimeManager\",\"Instance\",\"Assets\",\"AudioNodes\",\"events\"],function(e,t,i,n,a,s,o,r){function l(t){this.input=e.context.createGainNode(),this.output=e.context.createGainNode(),this.Note=p.call(this,t)}function c(t,i,n){if(t)this.input.connect(this.output),this.output.connect(t);else{var a=this.input;if(this.effects=o.createRecursive(a,i),this.effects.length>0&&(a=this.effects[this.effects.length-1]),a.connect(this.output),n&&\"master\"!==n){var s=e.getInstance(\"audioRouter\",n);s?this.output.connect(s.input):this.output.connect(e.context.destination)}else this.output.connect(e.context.destination)}}function d(){for(var t,i,n=e.context.currentTime,a=this.samples.active,s=this.samples.sustained,o=Object.keys(a),r=o.length;r--;)for(i=o[r],t=a[i].length;t--;)n>a[i][t].disposeTime&&a[i].splice(t,1);for(r=s.length;r--;)n>s[r].disposeTime&&s.splice(r,1)}function u(t,i,n){var a=this._loop&&this._sustain,s=this._loop?1/0:1e3*t.bufferLength-t.ampRelease,o=this.ignoreNoteOff?s:n?n:s,r=i+(a?1/0:o);isFinite(r)&&t._noteOff(r),this.sustained||!n?(this.samples.sustained.push(t),this.samples.sustained.length>this.numberOfVoices&&this.samples.sustained[0]._noteOff(1e3*e.context.currentTime)):this.samples.active[t.midiNote].push(t)}function p(){function t(t){this.bufferSource=e.context.createBufferSource(),this.amp=e.context.createGainNode(),this.filter=this.filterOn&&e.context.createBiquadFilter(),this.bufferSource.connect(this.filter||this.amp),this.filter&&this.filter.connect(this.amp),this.amp.connect(this.output),this.parent=t.parent,this.midiNote=t.midiNote,this.bufferSource.gain.value=void 0!==t.sampleGain?g(parseInt(t.sampleGain,10)):1,this.bufferSource.playbackRate.value=m(this.midiNote)/m(f(t.baseNote)),this.bufferSource.buffer=s.getAsset(\"buffer\",t.buffer),this.bufferLength=this.bufferSource.buffer.length/e.context.sampleRate,this.velocity=Math.pow(t.velocity/127,1.2),this.bufferSource.loop=this.parent.loop,this.filterOn&&(this.filter.Q.value=this.filterQ,this.filter.gain=this.filterGain)}return t.prototype=Object.create(this),t.prototype.output=this.input,t.prototype._noteOn=y.noteOn,t.prototype._noteOff=y.noteOff,t}var h=\"synth\",m=t.MIDIToFrequency,f=t.toMIDINote,g=t.dbToWAVolume;l.prototype=Object.create(a,{init:{value:function(e){c.apply(this,[e.output,e.audioNodes,e.bus]),this._sustain=!1,this.samples={meta:Object.create(null),maps:Object.create(null),used:Object.create(null),active:Object.create(null),sustained:[]};for(var t,i=0,a=e.sampleMapGroups[0].sampleMaps.length;a>i;i++)t=e.sampleMapGroups[0].sampleMaps[i].name,t=\"multi\"===t?this.instanceId:t,this.samples.meta[t]=e.sampleMapGroups[0].sampleMaps[i];for(var o in this.samples.meta)this.samples.maps[o]=s.getAsset(\"sampleMap\",o),this.samples.used[o]=Object.create(null);n.addFrameListener(this.instanceId,d,this)}},numberOfVoices:{value:16},volume:{get:function(){return this.output.gain.value},set:function(e){this.output.gain.value=t.dbToWAVolume(e)}},sustain:{get:function(){return this._sustain},set:function(t){if(t)this._sustain=!0;else{this._sustain=!1;for(var i=0,n=this.samples.sustained.length;n>i;i++)this.samples.sustained[i]._noteOff(1e3*e.context.currentTime)}}},filterSustain:{get:function(){return this._filterSustain},set:function(e){this._filterSustain=Math.pow(e,4)}},controller:{value:function(e,t){switch(t.controllerType){case 64:this.sustain=!!t.value;break;case 123:t.value&&this.stopAll();break;\ndefault:r.dispatch(\"log:instance:synth\",\"Unrecognized controller number for\",this.instanceId,\":\",t.controllerType)}}},onAction:{value:function(e,t,i){i&&(this[i.type]?this[i.type](t,i):r.dispatch(\"log:instance:synth\",\"Sampler does not recognize message \",i))}},getRange:{value:function(e,t){var i,n,a,s,o=this.samples.meta,r=this.samples.maps,l=this.samples.used,c=0,d=[];for(n in o)if(t>=o[n].velocityLow&&o[n].velocityHigh>=t){i=r[n];for(a in i)s=i[a],e>=f(s.low)&&f(s.hi)>=e&&d.push(s)}return 1!==d.length&&(void 0!==l[n][e]&&(c=(l[n][e]+1)%d.length),l[n][e]=c),d[c]}},noteOn:{value:function(e,t){var i,n=this.samples.active,a=t.midiNote,o=t.velocity,l=t.duration||t.endTime,c=this.getRange(a,o);return c&&c.sound?s.getAsset(\"buffer\",c.sound)?(i=new this.Note({parent:this,sampleGain:c.vol,baseNote:c.root,buffer:c.sound,midiNote:a,velocity:o}),n[a]?n[a].length&&!this.ignoreNoteOff&&this.noteOff(e,t):n[a]=[],this.loop&&this.ignoreNoteOff&&(r.dispatch(\"log:instance:synth\",\"Sampler Configuration Error: You cannot use looped samples with ignoreNoteOff.\"),t.duration?this.ignoreNoteOff=!1:this.loop=!1),i._noteOn(e),u.apply(this,[i,e,l]),void 0):(r.dispatch(\"log:instance:synth\",\"Missing Buffer!\"),void 0):(r.dispatch(\"log:instance:synth\",\"missing range for\",this.instanceId,\"midiNote\",a),void 0)}},noteOff:{value:function(t,i){var n,a,s=this.samples.active,o=this.samples.sustained,r=i.midiNote;if(r&&!this.ignoreNoteOff){if(s[r])for(n=0,a=s[r].length;a>n;n++)s[r][n]._noteOff(t||1e3*e.context.currentTime);if(!this.sustain)for(n=0,a=o.length;a>n;n++)o[n].midiNote===r&&o[n]._noteOff(t||1e3*e.context.currentTime)}}},stopAll:{value:function(){var t,i=this.samples.active,n=this.samples.sustained;for(var a in i){for(t=i[a].length;t--;)i[a][t]._noteOff(1e3*e.context.currentTime);for(t=n.length;t--;)n[t]._noteOff(1e3*e.context.currentTime)}}}});var y={noteOn:function(e){var t=e+this.ampAttack,i=t+this.ampDecay,n=1-this.ampVelocityRatio+this.velocity*this.ampVelocityRatio,a=Math.pow(this.ampSustain*n,2);if(this.noteOnTime=e,this.ampPeakValue=n,this.ampSustainValue=a,this.amp.gain.setValueAtTime(0,e/1e3),this.amp.gain.linearRampToValueAtTime(n,t/1e3),this.amp.gain.linearRampToValueAtTime(a,i/1e3),this.filterOn){var s=e+this.filterAttack,o=s+this.filterDecay,r=1-this.filterVelocityRatio+this.velocity*this.filterVelocityRatio,l=this.filterADSRAmount*r,c=this.filterFrequency+l,d=this.filterFrequency+this.filterSustain*l;c=m(12*c+this.midiNote),d=m(12*d+this.midiNote),c=20>c?20:c>2e4?2e4:c,d=20>d?20:d>2e4?2e4:d,this.filterFrequency=m(12*this.filterFrequency+this.midiNote),this.filter.frequency.setValueAtTime(this.filterFrequency,e/1e3),this.filter.frequency.linearRampToValueAtTime(c,s/1e3),this.filter.frequency.linearRampToValueAtTime(d,o/1e3)}this.bufferSource.noteOn(this.noteOnTime/1e3)},noteOff:function(e){var t,i;t=e+this.ampRelease,i=e+this.filterRelease,this.amp.gain.cancelScheduledValues(e/1e3),this.amp.gain.setValueAtTime(this.ampSustainValue,e/1e3),this.amp.gain.linearRampToValueAtTime(0,t/1e3),this.filter&&(this.filter.frequency.cancelScheduledValues(e/1e3),this.filter.frequency.setValueAtTime(this.filter.frequency.value,e/1e3),this.filter.frequency.linearRampToValueAtTime(this.filterFrequency,i/1e3)),this.bufferSource.noteOff(t/1e3),this.disposeTime=t/1e3,this.noteOffSent=!0}};e.registerInstance(h,\"sampler\",l)}),dmaf(\"timePatternPlayer\",[\"DMAF\",\"TimeManager\",\"InstanceManager\",\"Instance\",\"Assets\",\"Utils\",\"events\"],function(e,t,i,n,a,s,o){function r(){this.activePatterns=[],this.running=!1}r.prototype=Object.create(n,{init:{value:function(){}},onAction:{value:function(e,i){var n=e.split(\".\"),a=n[1].toLowerCase(),s=n[0];o.dispatch(\"instance:player:timePatternPlayer\",e),this[a]&&this[a](s,i),this.running||(this.running=!0,t.addFrameListener(this.instanceId,this.checkPatterns,this))}},start:{value:function(e,t){var i=a.getAsset(\"timePattern\",e);i?(-1===this.activePatterns.indexOf(i)?this.activePatterns.push(i):o.dispatch(\"log:instance:player:timePatternPlayer\",\"Time Pattern\",e,\"is already active!\"),i.startTime=t):o.dispatch(\"log:error\",\"No time pattern with id \",e,\"exists.\")}},stop:{value:function(e){var t,i=a.getAsset(\"timePattern\",e);i?(\"DEFAULT\"===this.behavior&&i.reset(),t=this.activePatterns.indexOf(i),-1!==t&&this.activePatterns.splice(t,1)):o.dispatch(\"log:instance:player:timePatternPlayer\",\"No time pattern with id \",e,\"exists.\")}},checkPatterns:{value:function(){if(!this.activePatterns.length)return this.running=!1,t.removeFrameListener(this.instanceId);for(var e=0;this.activePatterns.length>e;e++)this.activePatterns[e].executeEvents(this.behavior)&&this.activePatterns.splice(e--,1)[0].reset()}}}),e.registerInstance(\"player\",\"timePatternPlayer\",r)}),dmaf(\"log\",[\"DMAF\",\"events\"],function(e,t){function i(){if(dmaf.log){var t=[].slice.call(arguments);t.splice(1,0,Math.floor(1e3*e.context.currentTime)),t.unshift(\"DMAF:\"),console.log.apply(console,t)}}return function(e){e=e||[];for(var n=0;e.length>n;n++)t.add(\"log:\"+e[n],i);t.add(\"log:error\",i)}}),dmaf(\"Assets\",[\"DMAF\",\"events\"],function(e,t){function i(e){t.dispatch(\"_external:progress\",{}),e&&n.preloads--,0===n.preloads&&(t.remove(\"_internal:asset_loaded\",i),t.dispatch(\"log:assets\",\"Assets have completed loading.\"),t.dispatch(\"_internal:preloads_complete\")),n.loaded++}var n=e.Assets={loaded:0,preloads:0,beatPattern:{},timePattern:{},sampleMap:{},buffer:{},getAsset:function(e,i){return this[e]&&this[e][i]?this[e][i]:(t.dispatch(\"log:error\",\"DMAF couldn't find asset\",e,i),null)},setAsset:function(e,t,i){this[e][t]=i}};return t.add(\"_internal:asset_loaded\",i),n}),dmaf(\"InstanceManager\",[],function(){function e(e){this.activeInstances={},this.constructor=e}return e.prototype.getInstance=function(e){return this.activeInstances[e]},e.prototype.removeInstance=function(e){return delete this.activeInstances[e]},e.prototype.addInstance=function(e){this.activeInstances[e.instanceId]=e},e.prototype.createInstance=function(e){var t=new this.constructor(e);return t.isDMAFInstance?(t.setInitProperties(e),this.addInstance(t),t):console.log(t)},e}),dmaf(\"TimeManager\",[\"DMAF\",\"events\"],function(e,t){function i(){if(!r.length)return l=!1,void 0;for(a=1e3*c.currentTime,s=0;r.length>s;s++)r[s].callback.call(r[s].context,a);e.lastTime=e.currentTime,e.currentTime=e.context.currentTime,e.lastTime===e.currentTime,setTimeout(i,30)}function n(e){for(var t=r.length;t--;)if(r[t].id===e)return!0;return!1}var a,s,o=Array.prototype.slice,r=[],l=!1,c=e.context;return e.preListen=30,e.lastTime=0,e.currentTime=-1,{checkFunctionTime:function(t,i,n,a){var s,r,l,c=o.call(arguments,4);a=a||e,t>=1e3*e.context.currentTime+e.preListen?(s=function s(){n.splice(n.indexOf(r),1),i.apply(a,c)},l=t-Math.floor(1e3*e.context.currentTime)-e.preListen,r=setTimeout(s,l),n.push(r)):i.apply(a,c)},dropPendingArray:function(e){for(;e.length;)clearTimeout(e.pop())},addFrameListener:function(a,s,o){return n(a)?(t.dispatch(\"log:manager:timeManager\",\"That frame listener is already running!\",a),void 0):(r.push({callback:s,context:o||e,id:a}),l||(l=!0,i()),void 0)},removeFrameListener:function(e){for(var t=r.length;t--;)if(r[t].id===e)return r.splice(t,1),!0;return!1}}}),dmaf(\"parseActions\",[\"DMAF\",\"Utils\"],function(e,t){function i(e){var i=[];return t.each(e,function(e,t){\"array\"===t.type&&i.push(t)}),i}function n(e,i){return t.each(i,function(n){t.isType(\"undefined\",e[n])&&(e[n]=u(i[n]))}),e}function a(e){var i;return t.each(c.action,function(n,a){return t.each(a,function(t,n){return t===e?i=n:void 0}),i}),i||console.error(\"Could not find action with Id of\",e)}function s(e){return Object.keys(c.type[e]).filter(function(e){return\"type\"!==e})}function o(e,a,s){var o=t.tag(e,\"properties\"),c=i(a),u={};return t.each(o,function(e,t){t.localName&&r(u,t,a)}),t.each(c,function(i,n){if(d(e)){var a=t.tag(e,n.name)[0]||[];u[n.name]=a?l(a,n.valueType):[]}else u[n.name]=[]}),n(u,a,s)}function r(e,i,n){for(var a=i.attributes,s=0,o=a.length;o>s;s++)if(void 0===n[a[s].localName]&&\"triggers\"!==a[s].localName&&\"delay\"!==a[s].localName)return console.error(\"Invalid attribute\",a[s].localName,\"check spelling in descriptors\");t.each(n,function(n,a){var s;i.hasAttribute(n)&&(s=t.attr(i,n),!/\\:/.test(s)||/target/.test(n)||/_external/.test(s)?(s=t.fromString(a.type,s,a),e[n]=t.verify(a,s)):(e._dynamicValues=e._dynamicValues||[],e._dynamicValues.push({key:n,string:s}),e[n]=u(a)))})}function l(e,n){if(d(e)){var a=s(n),o=[],u=[],p=c.type[n];return t.each(e.childNodes,function(t,i){i&&d(i)&&(i.parentElement===e||i.parentNode===e)&&i.localName&&-1!==a.indexOf(i.localName)&&o.push(i)}),t.each(o,function(n,a){if(a.localName&&p[a.localName]){var s={id:a.localName},o=i(p[s.id]);r(s,a,p[s.id]),t.each(o,function(i,n){var a=t.tag(e,n.name)[0];s[n.name]=a&&d(a)?l(a,n.valueType):[]}),u.push(s)}}),u}return[]}var c,d=t.prop(\"getElementsByTagName\"),u=t.prop(\"default\");return function(i){var n=t.tag(i,\"actions\")[0].childNodes,s=[],r=[];return c=e.Settings.descriptors,t.each(n,function(e,t){t&&t.localName&&d(t)&&(-1!==c.validActions.indexOf(t.localName)?s.push(t):console.error(\"Unrecognized action!\",t.localName,\"check spelling.\"))}),t.each(s,function(e,i){if(i.localName&&d(i)){var n=i.localName,s=a(n),l=o(i,s,i.localName),c=s.type,u=t.attr(i,\"triggers\"),p=t.attr(i,\"delay\")||0,h=t.attr(i,\"instanceId\")||l.instanceId||\"\",m={};if(!u)return console.error(\"Action\",c,n,l.instanceId,\"has no triggers!\"),!0;u=t.removeWhiteSpace(u).split(\",\"),t.extend(l,m),m.id=n,m.type=c,m.triggers=u,m.delay=parseInt(m.delay||p,10),m.instanceId=h||\"\",m.multi=\"multi\"===h,r.push(m)}}),r}}),dmaf(\"parseDescriptors\",[\"Utils\",\"DMAF\"],function(e,t){function i(t){for(var i,n=t.attributes,a={},s=0,o=n.length;o>s;s++)i=n[s].nodeName,e.propertyModel[i]&&(a[i]=e.fromString(e.propertyModel[i],n[s].value,t));return a}var n=\"getElementsByTagName\",a=\"getAttribute\";return function(s){var o,r,l,c,d,u=s[n](\"descriptor\"),p={validActions:[],validTypes:[]};return e.each(u,function(t,s){s[a]&&(d=s[a](\"id\"),c=s[a](\"type\"),l=s[a](\"class\"),p[l]=p[l]||{},p[l][c]=p[l][c]||{},p[l][c][d]=r=p[l][c][d]||{},p[l][c][d].type=c,p[l][c][d].id=d,p[l][c].type=c,\"action\"===l&&p.validActions.push(d),\"type\"===l&&p.validTypes.push(d),o=s[n](\"property\"),e.each(o,function(e,t){t[a]&&(r[t[a](\"name\")]=i(t))}))}),t.Settings||(t.Settings={}),t.Settings.descriptors=p,p}}),dmaf(\"parseMidi\",[\"Assets\",\"timePattern\",\"beatPattern\",\"events\"],function(e,t,i,n){function a(e,t,i){this.absoluteTime=t+e.readVariableLengthInt();var n=e.read8BitInt();240==(240&n)?this.getMetaEvent(e,n):this.getChannelEvent(e,n,i)}function s(e){this.pointer=0,this.midiString=e}function o(e){s.call(this,e.split(\"\").map(d).join(\"\")),this.tracks=[],this.chunk={},this.lastEventType=0,this.getNextChunk(\"MThd\").readHeader().getTracks()}function r(i,n){var a,s,o,r,l,d,u,p,h,m,f;for(d=0,u=i.trackCount;u>d;d++){for(r=i.tracks[d],a=r[0].text||n+d+\"\",trigger=r[1].text||n+d+\"\",o=[],p=0,h=r.length;h>p;p++)if(\"setTempo\"===r[p].subtype){f=6e7/r[p].microsecondsPerBeat;break}for(p=0,h=r.length;h>p;p++)if(\"noteOn\"===r[p].subtype){for(l=r[p],l.type=l.subtype,l.trigger=trigger,m=p;h>m&&!c(r[m],l);m++);l.absoluteTime=6e4*l.absoluteTime/(i.ticksPerBeat*f)+1,l.duration=6e4*l.duration/(i.ticksPerBeat*f),o.push(l)}s=new t(a,o),e.setAsset(\"timePattern\",a,s)}}function l(t,n){var a,s,o,r,l,d,u,p,h,m,f,g;for(d=1,u=t.trackCount;u>d;d++){for(r=t.tracks[d],a=r[0].text||n+d+\"\",s=r[1].text||n+d+\"\",o=new i(a,1),p=2,h=r.length;h>p;p++)if(\"noteOn\"===r[p].subtype||\"controller\"===r[p].subtype){for(l=r[p],l.type=l.subtype,m=Math.floor(l.absoluteTime/t.beatLengthInTicks),f=Math.floor(l.absoluteTime-m*t.beatLengthInTicks),g=p;h>g&&!c(r[g],l);g++);o.addEvent(s,m+1,f+1,l)}else\"controller\"===r[p].subtype&&(l=r[p],l.type=l.subtype,m=Math.floor(l.absoluteTime/t.beatLengthInTicks),f=Math.floor(l.absoluteTime-m*t.beatLengthInTicks),o.addEvent(s,m+1,f+1,l));e.setAsset(\"beatPattern\",a,o)}}function c(e,t){var i=(\"noteOn\"===e.subtype||\"noteOff\"===e.subtype)&&e.subtype;return i&&e.midiNote===t.midiNote?\"noteOn\"===i&&!e.velocity||\"noteOff\"===i?(t.duration=e.absoluteTime-t.absoluteTime,t.duration):void 0:!1}function d(e){return String.fromCharCode(255&e.charCodeAt(0))}return a.prototype={getMetaEvent:function(e,t){var i,a;if(255==t){switch(this.type=\"meta\",a=e.read8BitInt(),i=e.readVariableLengthInt(),a){case 0:if(this.subtype=\"sequenceNumber\",2!=i)return;return this.number=e.read16BitInt(),void 0;case 1:return this.subtype=\"text\",this.text=e.readTo(i),void 0;case 2:return this.subtype=\"copyrightNotice\",this.text=e.readTo(i),void 0;case 3:return this.subtype=\"trackName\",this.text=e.readTo(i),void 0;case 4:return this.subtype=\"instrumentName\",this.text=e.readTo(i),void 0;case 5:return this.subtype=\"lyrics\",this.text=e.readTo(i),void 0;case 6:return this.subtype=\"marker\",this.text=e.readTo(i),void 0;case 7:return this.subtype=\"cuePoint\",this.text=e.readTo(i),void 0;case 32:if(this.subtype=\"midiChannelPrefix\",1!==i)return;return this.channel=e.read8BitInt(),void 0;case 47:return this.subtype=\"endOfTrack\",void 0;case 81:if(this.subtype=\"setTempo\",3!=i)return;return this.microsecondsPerBeat=(e.read8BitInt()<<16)+(e.read8BitInt()<<8)+e.read8BitInt(),void 0;case 84:if(this.subtype=\"smpteOffset\",5!=i)return;var s=e.read8BitInt();return this.frameRate={0:24,32:25,64:29,96:30}[96&s],this.hour=31&s,this.min=e.read8BitInt(),this.sec=e.read8BitInt(),this.frame=e.read8BitInt(),this.subframe=e.read8BitInt(),void 0;case 88:if(this.subtype=\"timeSignature\",4!==i)return;return this.numerator=e.read8BitInt(),this.denominator=Math.pow(2,e.read8BitInt()),this.metronome=e.read8BitInt(),this.thirtyseconds=e.read8BitInt(),void 0;case 89:if(this.subtype=\"keySignature\",2!==i)return;return this.key=e.read8BitInt(),this.scale=e.read8BitInt(),void 0;case 127:return this.subtype=\"sequencerSpecific\",this.data=e.readTo(i),void 0;default:return this.subtype=\"unknown\",this.data=e.readTo(i),void 0}return this.data=e.readTo(i),void 0}return 240==t?(this.type=\"sysEx\",i=e.readVariableLengthInt(),this.data=e.readTo(i),void 0):247==t?(this.type=\"dividedSysEx\",i=e.readVariableLengthInt(),this.data=e.readTo(i),void 0):(this.type=\"unknown\",i=e.readVariableLengthInt(),this.data=e.readTo(i),n.dispatch(\"log:parsing:midi\",\"unknown MIDI event type byte of length\"+i),void 0)},getChannelEvent:function(e,t,i){var a,s;switch(0===(128&t)?(s=t,t=i.lastEventType):(s=e.read8BitInt(),i.lastEventType=t),a=t>>4,this.channel=15&t,this.type=\"channel\",a){case 8:this.subtype=\"noteOff\",this.midiNote=s,this.velocity=e.read8BitInt();break;case 9:this.midiNote=s,this.velocity=e.read8BitInt(),this.subtype=0===this.velocity?\"noteOff\":\"noteOn\";break;case 10:this.subtype=\"noteAftertouch\",this.midiNote=s,this.amount=e.read8BitInt();break;case 11:this.subtype=\"controller\",this.controllerType=s,this.value=e.read8BitInt();break;case 12:this.subtype=\"programChange\",this.programNumber=s;break;case 13:this.subtype=\"channelAftertouch\",this.amount=s;break;case 14:this.subtype=\"pitchBend\",this.value=s+(e.read8BitInt()<<7);break;default:this.subtype=\"unknown\",n.dispatch(\"log:parsing:midi\",\"Unrecognised MIDI event type: \"+a)}}},s.prototype={read32BitInt:function(){var e=(this.midiString.charCodeAt(this.pointer)<<24)+(this.midiString.charCodeAt(this.pointer+1)<<16)+(this.midiString.charCodeAt(this.pointer+2)<<8)+this.midiString.charCodeAt(this.pointer+3);return this.pointer+=4,e},read16BitInt:function(){var e=(this.midiString.charCodeAt(this.pointer)<<8)+this.midiString.charCodeAt(this.pointer+1);return this.pointer+=2,e},read8BitInt:function(){var e=this.midiString.charCodeAt(this.pointer);return this.pointer+=1,e},readTo:function(e){var t=this.midiString.substr(this.pointer,e);return this.pointer+=e,t},endOfFile:function(){return this.pointer>=this.midiString.length},readVariableLengthInt:function(){for(var e=0;;){var t=this.read8BitInt();if(!(128&t))return e+t;e+=127&t,e<<=7}}},o.prototype=Object.create(s.prototype,{readHeader:{value:function(){var e=new s(this.chunk.data);return this.formatType=e.read16BitInt(),this.trackCount=e.read16BitInt(),this.ticksPerBeat=e.read16BitInt(),32768&this.ticksPerBeat&&(this.ticksPerBeat=480,n.dispatch(\"log:parsing:midi\",\"Time division in SMPTE, defaulting to 480 ticks per beat\")),this.beatLengthInTicks=this.ticksPerBeat/4,this}},getTracks:{value:function(){for(var e,t,i,n=0,o=this.trackCount;o>n;n++)for(this.tracks[n]=[],t=0,this.getNextChunk(\"MTrk\"),e=new s(this.chunk.data);!e.endOfFile();)i=new a(e,t,this),this.tracks[n].push(i),t=i.absoluteTime;return this}},getNextChunk:{value:function(e){return this.chunk.id=this.readTo(4),this.chunk.id!==e?(n.dispatch(\"log:parsing:midi\",e,\"but found\",this.chunk.id),this):(this.chunk.length=this.read32BitInt(),this.chunk.data=this.readTo(this.chunk.length),this)}}}),function(e,t,i){var n=new o(e);switch(t){case\"beatPattern\":l(n,i);break;case\"timePattern\":r(n,i);break;default:l(n,i)}}}),dmaf(\"Parse\",[\"DMAF\",\"Assets\",\"parseSampleMap\",\"parseMidi\",\"parseDescriptors\",\"parseActions\",\"events\"],function(e,t,i,n,a,s,o){var r={midi:n,samplemap:i,descriptors:a,actions:s};return function(t){var i=Array.prototype.slice.call(arguments,1);return r[t]?r[t].apply(e,i):(o.dispatch(\"log:parsing\",\"DMAF.parse: invalid type\",t),null)}}),dmaf(\"parseSampleMap\",[\"Assets\",\"Utils\",\"events\"],function(e,t,i){function n(e){i.dispatch(\"log:error\",\"Malformed Samplemap!\",e||\"No information about this error!\")}function a(e,i){return t.attr(i,e)||n(\"Could not find required property \"+e,i)}return function(i){var s,o,r,l=t.tag(i,\"samplemap\"),c=[\"sound\",\"root\",\"low\",\"hi\",\"vol\"];t.each(l,function(i,l){return o=t.attr(l,\"name\"),s=t.tag(l,\"range\"),r={},\"string\"!=typeof o?n(\"name is undefined\"):s&&s.length?(t.each(s,function(e,i){var n=r[\"range_\"+e]={};t.each(c,function(e,t){n[t]=a(t,i)})}),e.setAsset(\"sampleMap\",o,r),void 0):n(\"Couldn't find ranges for \"+o)})}}),dmaf(\"beatPattern\",[\"DMAF\",\"Assets\",\"events\"],function(e,t,i){function n(e,t,i,n){this.eventName=e,this.beat=t,this.tick=i||1,this.data=n}function a(e,t){this.events={},this.patternId=e,this.startPosition=t||1,this.endPosition=0}return n.prototype.execute=function(e,t){var n=Object.create(this.data);e=Math.floor(e+(this.tick-1)*(t/120)),n.duration=e+n.duration*(t/120)/1e3-e,n.duration*=1e3,i.dispatch(this.eventName,e,n)},a.prototype.addEvent=function(e,t,i,a){this.events[t]=this.events[t]||[],this.events[t].push(new n(e,t,i,a)),t+1>this.endPosition&&(this.endPosition=t+1)},t.setAsset(\"beatPattern\",\"empty_pattern\",new a(\"empty_pattern\",1)),a}),dmaf(\"beatPatternInstance\",[\"beatPosition\",\"events\"],function(e,t){function i(i,n){if(!n.beatPattern)return t.dispatch(\"log:error:beatPatternInstance\",\"Found no BeatPattern for channel\",n.channel,\". Please check MIDI file.\"),this.ERROR=!0,void 0;if(this.addAtSongPosition=n.addAtSongPosition,this.currentBeat=n.startPatternAtBeat,this.replaceActive=n.replaceActive,this.clearPosition=n.clearPosition,this.setAsCurrent=n.setAsCurrent,this.beatPattern=n.beatPattern,this.patternId=n.patternId,this.channel=n.channel,this.loop=n.loop,this.player=i,this.loop)n.loopLength?(this.loopLength=n.loopLength,this.removeAtSongPosition=new e(1/0,1,this.player.beatsPerBar)):t.dispatch(\"log:error:beatPatternInstance\",\"You must specify a loopLength for pattern \"+this.patternId+\" if loop is set to true.\"),this.currentBeat===this.loopLength&&(this.currentBeat=1);else{var a=this.beatPattern.endPosition-this.currentBeat;this.removeAtSongPosition=this.addAtSongPosition.clone(),this.removeAtSongPosition.addOffset({bar:0,beat:a})}}return i.prototype.gotoNextBeat=function(){this.currentBeat++,this.loop&&this.currentBeat>this.loopLength&&(this.currentBeat=1)},i.prototype.executeEvents=function(e,t){var i=this.beatPattern.events[this.currentBeat];if(i)for(var n=0,a=i.length;a>n;n++)i[n].execute(e,t)},i}),dmaf(\"beatPosition\",[],function(){function e(e,t,i){this.bar=void 0===e?1:e,this.beat=void 0===t?1:t,this.beatsPerBar=void 0===i?16:i}return e.prototype.getInBeats=function(){return(this.bar-1)*this.beatsPerBar+this.beat},e.prototype.gotoNextBeat=function(){this.beat===this.beatsPerBar?(this.bar++,this.beat=1):this.beat++},e.prototype.addOffset=function(e){for(this.beat+=e.beat;this.beat>this.beatsPerBar;)this.bar++,this.beat-=this.beatsPerBar;this.bar+=e.bar},e.prototype.clone=function(){return new e(this.bar,this.beat,this.beatsPerBar)},e}),dmaf(\"timePattern\",[\"DMAF\",\"events\",\"Utils\"],function(e,t,i){function n(e,t){this.patternId=e,this.events=t,this.startTime=-1,this.lastExecutedEventTime=-1,this.remove=!1}return n.prototype={reset:function(){this.startTime=-1,this.lastExecutedEventTime=-1,this.remove=!1},executeEvents:function(t){var i=1e3*e.context.currentTime-this.startTime,n=-1;switch(t){case\"LINEAR\":this.executeLinear(i,n);break;case\"DEFAULT\":this.executeDefault(i,n)}return this.remove},executeLinear:function(n){var a,s;for(a=0,s=this.events.length;s>a;a++)this.events[a].absoluteTime>this.lastExecutedEventTime&&n>this.events[a].absoluteTime-e.preListen&&(dmaf.log&&t.dispatch(\"log:pattern:timePattern\",\"dispatching\",this.events[a].trigger),t.dispatch(this.events[a].trigger,this.startTime+this.events[a].absoluteTime,i.clone(this.events[a])),this.lastExecutedEventTime=this.events[a].absoluteTime);n>this.events[s-1].absoluteTime+300&&(this.remove=!0)},executeDefault:function(n,a){var s,o;if(-1===this.lastExecutedEventTime){for(s=0,o=this.events.length;o>s;s++)n>this.events[s].absoluteTime-e.preListen&&(dmaf.log&&t.dispatch(\"log:pattern:timePattern\",\"dispatching\",this.events[s].trigger),t.dispatch(this.events[s].trigger,this.startTime+this.events[s].absoluteTime,i.clone(this.events[s])),a=this.events[s].absoluteTime);this.lastExecutedEventTime=a,n>this.events[o-1].absoluteTime+300&&(this.remove=!0)}else this.executeLinear(n,a)}},n}),dmaf(\"Iterator\",[],function(){function e(e,i){this.index=-1,this.array=e,this.getNext=t[i],this.A=e.slice(0),this.B=[]}var t={ROUND_ROBIN:function(){return this.index++,this.index%=this.array.length,this.array[this.index]},RANDOM_FIRST:function(){return-1===this.index?this.array[Math.floor(Math.random()*this.array.length)]:this.array[++this.index]},RANDOM:function(){return this.array[Math.floor(Math.random()*this.array.length)]},SHUFFLE:function(){var e;this.A.length||(this.A=this.array.slice(0),this.B=[]);do e=Math.floor(Math.random()*this.A.length);while(this.A[e]===this.previous);return this.B.push(this.A.splice(e,1)[0]),this.previous=this.B[this.B.length-1],this.previous}};return e}),dmaf(\"Utils\",[\"events\"],function(e){function t(e,t,i,n,a,s){var o=t-e,r=n-i;return function(e){var t=e/o;return a&&(t=Math.pow(t,a)),t*=r,s&&(t=parseInt(t,10)),t}}function i(e){return function(t){return t[e]}}function n(t,i,n){var s,o,r,l=0;if(n=a(m,n)&&n||null,a(f,t))for(l=0,r=t.length;r>l&&!i.call(n,l,t[l]);l++);else if(\"object\"==typeof t)for(s=Object.keys(t),l=0,r=s.length;r>l&&(o=s[l],\"length\"===o||!i.call(n,o,t[o]));l++);else e.dispatch(\"log:error\",\"Not array or object\",typeof t,t),console.log(t,i,n)}function a(e,t){switch(e){case d:return t===+t&&0===t%1;case u:return t===+t;case g:return t===void 0||\"undefined\"===t;case h:return\"boolean\"==typeof t;case p:return\"string\"==typeof t;case f:return\"[object Array]\"===N.call(t);case y:return\"[object Function]\"===N.call(t);case m:return\"[object Object]\"===N.call(t);default:return!1}}function s(e){var t;return n(_,function(i,n){return a(n,e)?(t=n,!0):void 0}),t}function o(e,t){return n(e,function(e,i){a(m,i)?(t[e]={},o(i,t[e])):a(f,i)?(t[e]=[],o(i,t[e])):t[e]=i}),t}function r(t){var i;if(a(m,t))i={};else{if(!a(f,t))return e.dispatch(\"log:error\",\"cannot clone non object\",t),void 0;i=[]}return o(t,i)}function l(t,i){return t>i.max&&(e.dispatch(\"log:error\",t,\"is out of range. constraining\",i.name,\"to:\",i.max),t=i.max),i.min>t&&(e.dispatch(\"log:error\",t,\"is out of range. constraining\",i.name,\"to:\",i.min),t=i.min),t}function c(t,i){var n;if(a(\"undefined\",t)||!t.type)return console.error(\"log:error\",\"DMAF Verification Error: Malformed descriptor!\"),void 0;if(a(\"undefined\",i))return I(t);switch(t.type){case\"int\":if(i=parseInt(i,10),!P.test(i)){n=!0;break}i=l(i,t);break;case\"float\":if(i=parseFloat(i),!a(u,i)&&!a(d,i)){n=!0;break}i=l(i,t);break;case\"string\":\"undefined\"===i&&(i=void 0),\"string\"!=typeof i&&(n=!0);break;case\"list\":n=!(i instanceof Array);break;case\"enum\":a(\"array\",t.values)?-1===t.values.indexOf(i)&&(e.dispatch(\"log:error\",i,\"is not valid enum for\",t.name),n=!0):(e.dispatch(\"log:error\",\"Malformed descriptors object\",t.name),n=!0);break;case\"boolean\":n=!a(\"boolean\",i);break;default:e.dispatch(\"log:error\",\"Malformed defaults object. Please check the descriptors.xml\")}return n?(e.dispatch(\"log:error\",i,\"is not valid for\",t.name),e.dispatch(\"log:error\",\"Defaulting\",t.name,\"to\",I(t)),I(t)):i}var d=\"int\",u=\"float\",p=\"string\",h=\"boolean\",m=\"object\",f=\"array\",g=\"undefined\",y=\"function\",_=[d,u,p,h,m,f,g,y],v={cflat:-1,c:0,csharp:1,dflat:1,d:2,dsharp:3,eflat:3,e:4,esharp:5,fflat:4,f:5,fsharp:6,gflat:6,g:7,gsharp:8,aflat:8,a:9,asharp:10,bflat:10,b:11,bsharp:12},b={automatable:\"boolean\",\"default\":\"fromType\",valueType:\"string\",value:\"fromType\",min:\"fromType\",max:\"fromType\",name:\"string\",type:\"string\",values:\"list\",unit:\"string\",src:\"string\"},T=\"getAttribute\",A=\"getElementsByTagName\",P=/^\\s*-?[0-9]{1,10}\\s*$/,E=Object.prototype,N=E.toString,I=i(\"default\");return{ajax:function(t,i,n){function a(){if(4===this.readyState){var i,a=n&&n.context||null,c=this.status>=200&&300>this.status||304===this.status;if(!c||!this.response)return o.onerror=function(){},s();if(n&&n.expectType&&typeof this.response!==n.expectType)return s();if(i=n.responseXML?this.responseXML:this.response,n.responseXML&&!this.responseXML)return e.dispatch(\"log:error\",\"Problem with XMLHttpRequest: XML is missing or malformed.\",t),s();for(var d=0,u=l.length;u>d;d++)r.unshift(i),i=l[d].apply(a,r)}}var s,o=new XMLHttpRequest,r=[],l=[i];n?(n.override&&o.overrideMimeType(n.override),n.chain&&(l=l.concat(n.chain)),n.args&&(r=r.concat(n.args))):n={},s=n.fail?n.fail:function(){e.dispatch(\"log:error\",\"DMAF ajax: Problem with request\",t)},o.onerror=s,o.onreadystatechange=a,o.open(\"GET\",t,!0),n&&n.responseType&&(o.responseType=n.responseType),o.send()},clone:r,constrain:l,attr:function(e,t){return e&&t&&e[T]?e[T](t):null},average:function(e){return sum(e)/e.length},dbToJSVolume:function(e){var t=Math.max(0,Math.round(100*Math.pow(2,e/6))/100);return Math.min(1,t)},dbToWAVolume:function(e){return Math.max(0,Math.floor(100*Math.pow(2,e/6))/100)},capitalize:function(e){return e.charAt(0).toUpperCase()+e.slice(1)},each:n,extend:o,fromString:function(t,i,n){if(i===void 0||\"undefined\"===i)return void 0;switch(t){case\"string\":return i;case\"boolean\":return\"true\"===i;case\"int\":return parseInt(i,10);case\"float\":return parseFloat(i);case\"list\":return i.split(\",\");case\"enum\":return i;case\"fromType\":return this.fromString(n[T](\"type\"),i,n);default:e.dispatch(\"log:error\",\"DMAF convert string to value\",t,i,n)}},getType:s,add:function(e,t){return e+t},subtract:function(e,t){return e-t},sum:function(e){return e.reduce(add)},prop:i,isType:a,MIDIToFrequency:function(e){return 8.1757989156*Math.pow(2,e/12)},parseProperty:function(e){for(var t,i=e.attributes,n={},a=0,s=i.length;s>a;a++)t=i[a].nodeName,b[t]&&(n[t]=fromString(b[t],i[a].value,e));return n},propertyModel:b,removeWhiteSpace:function(e){return e.replace(/\\s+/g,\"\")},scaler:t,tag:function(e,t){return e&&t&&e[A]?e[A](t):null},toMIDINote:function(e){var t,i,n,a;return\"#\"===e[1]||\"s\"===e[1].toLowerCase()?(i=e[0].toLowerCase()+\"sharp\",a=2):\"b\"===e[1]?(i=e[0].toLowerCase()+\"flat\",a=2):(i=e[0].toLowerCase(),a=1),i=v[i],n=\"-\"===e[a]?12*(0-parseInt(e[a+1],10)+2):12*(parseInt(e[a],10)+2),t=n+i},verify:c}}),dmaf(\"CheckMobile\",[\"DMAF\",\"Instance\",\"events\"],function(e,t,i){function n(){}var a=!1,s={Android:function(){return navigator.userAgent.match(/Android/i)},BlackBerry:function(){return navigator.userAgent.match(/BlackBerry/i)},iOS:function(){return navigator.userAgent.match(/iPhone|iPad|iPod/i)},Opera:function(){return navigator.userAgent.match(/Opera Mini/i)},Windows:function(){return navigator.userAgent.match(/IEMobile/i)},any:function(){return s.Android()||s.BlackBerry()||s.iOS()||s.Opera()||s.Windows()}};n.prototype=Object.create(t,{onAction:{value:function(e){switch(e){case\"splash_screen\":null===s.any()?(i.dispatch(\"init_beatpatternplayer\"),i.dispatch(\"splash_screen_music\")):a===!0&&i.dispatch(\"splash_screen_music\");break;case\"info_screen\":null===s.any()?i.dispatch(\"info_screen_music\"):a===!0?i.dispatch(\"info_screen_music\"):(i.dispatch(\"init_beatpatternplayer\"),i.dispatch(\"info_screen_music\"),a=!0)}}}}),e.registerInstance(\"customCode\",\"CheckMobile\",n)}),dmaf(\"LevelTransposer\",[\"DMAF\",\"Instance\"],function(e,t){function i(){this.transposeValue=0,this.lastActionTime=-5e3}i.prototype=Object.create(t,{onAction:{value:function(e,t){var i=5e3>t-this.lastActionTime;switch(e){case\"transpose_midi\":if(i)return;this.transposeValue++;break;case\"transpose_midi_reset\":this.transposeValue=0}this.lastActionTime=t}}}),e.registerInstance(\"customCode\",\"LevelTransposer\",i)});//@ sourceURL=slam/lib/dmaf.min.js"
));
require.register("slam/lib/sound.js", Function("exports, require, module",
"var dmaf = require('./dmaf.min')\n  , cookie = require('cookie')\n  , $ = require('jquery')\n\n// sound('on') / sound('off') / sound()\n\nmodule.exports = function sound(toggle,skipTrackGA,skipCookie){\n  var el = $('.sound-switch');\n  if( typeof toggle == 'undefined' ){\n    toggle = el.hasClass('on') ? 'off' : 'on';\n  } else if( toggle == 'on' || toggle == 'off' ){\n    toggle = toggle\n  } else {\n    toggle = toggle ? 'on' : 'off';\n  }\n\n  switch(toggle){\n    case 'on':\n\n      if( !skipTrackGA) _gaq.push(['_trackEvent', 'sound', 'on']);\n      el.removeClass('off').addClass('on');\n      if( dmaf.tell ) dmaf.tell('sound_on');\n      if(!skipCookie) cookie('sound', 'on');\n      break;\n\n    case 'off':\n      if( !skipTrackGA) _gaq.push(['_trackEvent', 'sound', 'off']);\n      el.removeClass('on').addClass('off');\n      if( dmaf.tell ) dmaf.tell('sound_off');\n      if(!skipCookie) cookie('sound', 'off');\n      break;\n\n    default:\n      throw new Error('you\\'re doing it wrong.');\n  }\n}//@ sourceURL=slam/lib/sound.js"
));
require.register("slam/lib/themes.js", Function("exports, require, module",
"var settings = require('./settings')\n    , $ = require('jquery');\n\nfunction Themes() {\n\n    this.white = 0xedecd6\n    //this.white = 0xf9f9db\n\n    this.currentThemeIndex = 0;\n    this.list = [\n\n        //only used as initiator in settings\n        new Theme({}),\n\n        //level 1\n        new Theme({name:\"default\"}),\n\n        //green\n        new Theme({\n            name:\"green\",\n            puckColor: 0xffda00,\n            arenaColor: 0xcdb380,\n            terrainColor1: 0x036564,\n            terrainColor2: 0x033649,\n            terrainColor3: 0x033649,\n            treeBranchColor: 0x031634,\n            iconColor: 0xffda00,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n\n            countdown1:'#ef0505',\n            countdown2:'#19b9b7',\n        }),\n\n        //purple\n        new Theme({\n            name:\"purple\",\n            puckColor: 0xffda00,\n            arenaColor: 0xb38184,\n            terrainColor1: 0x73626e,\n            terrainColor2: 0x413e4a,\n            terrainColor3: 0x413e4a,\n            treeBranchColor: 0x413e4a,\n            iconColor: 0xffda00,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n\n            countdown1:'#b38184',\n            countdown2:'#413e4a',\n        }),\n\n        //pastell\n        new Theme({\n            name:\"pastell\",\n            puckColor: 0xffda00,\n            arenaColor: 0xcc2a41,\n            terrainColor1: 0x64908a,\n            terrainColor2: 0x424254,\n            terrainColor3: 0x351330,\n            treeBranchColor: 0x424254,\n            iconColor: 0x04c4c7f,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n\n            countdown1:'#cc2a41',\n            countdown2:'#015c50',\n        }),\n\n\n        //pink\n        new Theme({\n            name:\"pink\",\n            puckColor: 0xffda00,\n            arenaColor: 0x5e9fa3,\n            terrainColor1: 0xdcd1b4,\n            terrainColor2: 0xb05574,\n            terrainColor3: 0xb6ac90,\n            treeBranchColor: 0xb65957,\n            iconColor: 0xffda00,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n            darken: true,\n\n            countdown1:'#b05574',\n            countdown2:'#5e9fa3',\n\n        }),\n\n        //light\n        new Theme({\n            name:\"light\",\n            puckColor: 0xffda00,\n            arenaColor: 0xab526b,\n            terrainColor1: 0xf4ebc3,\n            terrainColor2: 0xbca297,\n            terrainColor3: 0xbca297,\n            treeBranchColor: 0xc5ceae,\n            iconColor: 0x4c4c7f,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n            darken: true,\n\n            countdown1:'#bca297',\n            countdown2:'#c5ceae',\n        }),\n\n        //pastell green\n        new Theme({\n            name:\"pastell green\",\n            puckColor: 0xffda00,\n            arenaColor: 0x3c3251,\n            terrainColor1: 0xa8d46f,\n            terrainColor2: 0x3c3251,\n            terrainColor3: 0x341139,\n            treeBranchColor: 0x359668,\n            iconColor: 0x4c4c7f,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n\n            countdown1:'#cc2a41',\n            countdown2:'#359668',\n        }),\n\n\n        //orange\n        new Theme({\n            name:\"orange\",\n            puckColor: 0xffda00,\n            arenaColor: 0x3b8183,\n            terrainColor1: 0xff9c5b,\n            terrainColor2: 0xf5634a,\n            terrainColor3: 0xed303c,\n            treeBranchColor: 0xed303c,\n            iconColor: 0xffda00,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n\n            countdown1:'#911921',\n            countdown2:'#3b8183',\n        }),\n\n\n        //forrest green\n        new Theme({\n            name:\"forrest\",\n            puckColor: 0xffda00,\n            arenaColor: 0xa32c28,\n            terrainColor1: 0x384030,\n            terrainColor2: 0x2b3124,\n            terrainColor3: 0x1d2217,\n            treeBranchColor: 0x7b8055,\n            iconColor: 0xffda00,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n            countdown1:'#a32c28',\n            countdown2:'#7b8055',\n\n        }),\n\n        //black horizon\n        new Theme({\n            name:\"black horizon\",\n            puckColor: 0xffda00,\n            arenaColor: 0xe32f21,\n            terrainColor1: 0xabccbd,\n            terrainColor2: 0x181619,\n            terrainColor3: 0x181619,\n            treeBranchColor: 0x7dbeb8,\n            iconColor: 0xffda00,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n            darken: true,\n            countdown1:'#e32f21',\n            countdown2:'#7dbeb8',\n\n        }),\n\n        //red horizon\n        new Theme({\n            name:\"red horizon\",\n            puckColor: 0xffda00,\n            arenaColor: 0xc84648,\n            terrainColor1: 0xd3c8b4,\n            terrainColor2: 0x703e3b,\n            terrainColor3: 0x703e3b,\n            treeBranchColor: 0x703e3b,\n            iconColor: 0xffda00,\n            cpuBackdropColor:0x000000,\n            gridBrightness: 0.12,\n            darken:true,\n            countdown1:'#703e3b',\n            countdown2:'#456942',\n\n        })\n\n    ]\n\n    this.current = this.list[this.currentThemeIndex];\n\n}\n\nThemes.prototype = {\n    next: function(){\n        this.currentThemeIndex++\n\n        this.goto(this.currentThemeIndex)\n    },\n\n    goto: function(index) {\n\n        if( index >= this.list.length-1 ) {\n            //rewind until index in range. Might be good if there are hundreds of levels and a few themes\n            while( index >= this.list.length-1 ) index -= this.list.length;\n\n            if( index < 0 ) index = 0;\n        }\n\n        this.current = this.list[index+1];\n\n        var scores = $(\"#scores\");\n        var extras = $(\"#extras ul\");\n\n        if(this.current.darken) {\n           scores.find(\"h1,h2,h3,p\").addClass(\"ui-darken\")\n           scores.find(\"li,li:before\").addClass(\"ui-darken\")\n           extras.addClass(\"ui-darken\")\n\n        }\n        else {\n           scores.find(\"h1,h2,h3,p\").removeClass(\"ui-darken\")\n           scores.find(\"li\").removeClass(\"ui-darken\")\n           extras.removeClass(\"ui-darken\")\n\n        }\n\n        settings.changeTheme(this.current);\n\n    }\n}\n\nmodule.exports = new Themes();\n\nfunction Theme( mixin ) {\n\n    this.name = \"\";\n    this.treeTrunkColor =  0x206cc3;\n    this.shieldColor =  0xffffff;\n    this.puckColor =  0xefce06;\n    this.arenaColor =  0xeb2020;\n    this.terrainColor1 =  0x146ccf;\n    this.terrainColor2 =  0x0a71b9;\n    this.terrainColor3 =  0x196189;\n    this.treeBranchColor =  0x206cc3;\n    this.iconColor =  0xefce06;\n    this.cpuBackdropColor =  0x0e0e0d;\n    this.gridBrightness = 0.1\n    this.darken = false\n    this.countdown1 = '#e83129'\n    this.countdown2 = '#40a040'\n\n    if( mixin ) {\n        for( var key in mixin ) {\n            if( this.hasOwnProperty(key) ){\n                this[key] = mixin[key];\n            }\n        }\n    }\n}\n\n//@ sourceURL=slam/lib/themes.js"
));
require.register("slam/lib/puppeteer.js", Function("exports, require, module",
"var debug = require('debug')('puppeteer')\n  , settings = require('./settings')\n  , actions = require('./actions')\n  , copy = require('copy')\n  , sets = require('./levels/sets')\n  , levels = require('./levels');\n\nvar namespace = null;\n\nexports.namespace = function(id){\n  debug('namespace',id)\n  namespace = id;\n  return exports;\n}\n\n// convenience method to go to the next level\nexports.up = function(world){\n  debug('up %s',world.name)\n  var index = world.level.index + 1;\n  //if( index < levels[namespace].length ){\n    return exports.goto(world,index);\n  //} else {\n  //  return exports.goto(world,world.level.index);\n  //}\n}\n\nexports.goto = function(world,index){\n  if( !levels[namespace] ){\n    throw new Error('namespace \"'+namespace+'\" not found. call .namespace() first.');\n  }\n\n  // default to the same index\n  index = index || (world.level && world.level.index) || 0;\n  debug('goto %s',world.name,index)\n\n  var level = (index < levels[namespace].length)? levels[namespace][index]:levels[namespace][levels[namespace].length-1];\n\n  // exists?\n  if( !level ){\n    throw new Error('level \"'+index+'\" not found.');\n  }\n\n  // prepare & set level on world\n  world.level = prepare(world,level,index);\n  return exports;\n}\n\nexports.update = function(world){\n  // don't run if game over or paused\n  if( world.state !== 'playing' )\n    return;\n\n  var level = world.level;\n\n  // generate the nextSpawn\n  if( level.nextSpawn < 0 ){\n    // plan for the future\n    // TODO move to settings?\n    var min = settings.data.framerate*(level.minSpawnTime||5)\n    var max = settings.data.framerate*(level.maxSpawnTime||10)\n    level.nextSpawn = world.frame + world.rand.range(min,max);\n\n  }\n\n  // check if it's time to create an extra\n  if( world.frame > level.nextSpawn ){\n    //console.log(world.extras.length,level.maxExtras)\n    if( world.extras.length >= level.maxExtras ){\n      actions.destroyFirstExtra(world);\n    }\n\n    actions.createRandomExtra(world);\n\n    // Reset next spawn frame\n    // (will be regenerated next update())\n    level.nextSpawn = -1;\n  }\n\n  // check if there's room for obstacles\n  // (and there's still obstacles not in the arena)\n  if( world.frame > 0 ){\n    for(var i=world.obstacles.length; i<level.obstacles.length;i++){\n      // TODO this .used property is probably not a good idea.\n      //      maybe keep two arrays instead?\n      if(!level.obstacles[i].used) {\n        var added = actions.createNextObstacle(world)\n        if(added) level.obstacles[i].used = true;\n      }\n    }\n\n    for(var i=world.forces.length; i<level.forces.length;i++){\n      actions.createNextForce(world)\n    }\n  }\n}\n\nfunction prepare(world,level,index){\n  debug('prepare %s',world.name,index)\n\n  // TODO Pool?\n  var lvl = copy(level);\n\n  // set the index of the level\n  // (might be good to know for .goto())\n  lvl.index = index;\n\n  // special \"random\" case\n  if( lvl.set === 'random' ){\n    debug('set random')\n    lvl.set = sets.random;\n  }\n\n  if( index > levels[namespace].length-1 ){\n    //add more difficulty\n    var gain = Math.max(0,(index-(levels[namespace].length-1))*0.3);\n    console.log(gain);\n    lvl.puck.speed += gain;\n    lvl.puck.maxspeed += gain;\n  }\n\n  // pick a random set\n  if( Array.isArray(lvl.set) ){\n    lvl.set = world.rand.choice(lvl.set);\n    debug('set from array',lvl.set)\n  }\n\n  // find obstacles and forces in sets\n  if( sets[lvl.set] ){\n    copy(sets[lvl.set],lvl)\n  } else if(lvl.set){\n    throw new Error('set \"'+lvl.set+'\" was not found')\n  }\n\n  // in case the level defines positions\n  // overwrite with those\n  if( level.positions ){\n    lvl.positions = copy(level.positions,lvl.positions);\n  }\n\n  // optional extras, obstacles and forces\n  lvl.extras = lvl.extras || []\n  lvl.obstacles = lvl.obstacles || []\n  lvl.forces = lvl.forces || []\n  lvl.positions = lvl.positions || []\n\n\n  // make available if destroyed\n  for(var i=0; i < lvl.obstacles.length; i++){\n    lvl.obstacles[i].used = false;\n  }\n\n  // TODO validate the extra ids so they exist\n\n  // TODO validate the existence of AI?\n\n  // When next extra should be added\n  // set to -1 and reset on first update()\n  lvl.nextSpawn = -1;\n\n\n  // make sure the number of extras positions\n  // must be more than `maxExtras` (3) or\n  // available extras.\n  // TODO maybe a setting?\n  lvl.maxExtras = lvl.maxExtras || 3;//Math.min(3,lvl.extras.length);\n\n  return lvl;\n}//@ sourceURL=slam/lib/puppeteer.js"
));
require.register("slam/lib/inputs/index.js", Function("exports, require, module",
"var debug = require('debug')('inputs:core')\n  , Emitter = require('emitter')\n  , network = require('./network')\n  , types = require('./types')\n  , buf = require('./buffer')\n  , str = types.toString;\n\nvar buffer = [] // keeps the recorded inputs\n  , slice = [].slice\n  , hasPING = false\n  , hasHIT = false;\n\nEmitter(exports);\n\nexports.types = types;\nexports.network = network;\n\nexports.reset = function(){\n  buffer.length = 0;\n  buf.reset()\n  network.reset()\n}\n\nexports.record = function(type){\n  debug('record',str(arguments))\n\n  // validate input\n  if( types.validate(arguments) ){\n\n    // avoid multiple PINGs in buffer so we don't\n    // get unnecessary 'message too long'-like\n    // errors when being inactive.\n    if( type === types.PING ){\n      if( hasPING ){\n        return;\n      } else {\n        hasPING = true;\n      }\n    }\n\n    if( type === types.HIT ){\n      if( hasHIT ){\n        return;\n      } else {\n        hasHIT = true;\n      }\n    }\n\n\n    // push the input into a temporary buffer\n    buffer.push(slice.call(arguments))\n  } else {\n    console.warn('recorded invalid input:',arguments);\n  }\n}\n\nexports.process = function(world){\n  // send to network\n  world.multiplayer && network.send(world.frame,buffer)\n\n  // execute and enqueue the inputs\n  for(var i=0; i<buffer.length; i++){\n    var type = buffer[i][0];\n\n    // skip PING/PONG/HIT/MISS, they should\n    // only be sent over the network\n    if( type === types.PING ) continue;\n    if( type === types.PONG ) continue;\n    if( type === types.MISS ) continue;\n    if( type === types.HIT  ) continue;\n\n    // enqueue for network replay\n    // (do this first in case execute clears the buffer)\n    world.multiplayer && network.enqueue(world.frame,buffer[i])\n\n    // execute inputs locally\n    types.execute(world,buffer[i]);\n  }\n\n  // reset buffer\n  buffer.length = 0;\n  hasPING = false;\n  hasHIT = false;\n}\n\nexports.info = function(ctx){\n  var info = network.info();\n  info.recorded = buffer.length;\n  return info;\n}\n\n//@ sourceURL=slam/lib/inputs/index.js"
));
require.register("slam/lib/inputs/network.js", Function("exports, require, module",
"var debug = require('debug')('inputs:network')\n  , Emitter = require('emitter')\n  , now = require('now')\n  , buf = require('./buffer')\n  , types = require('./types')\n  , unhide = require('./util').unhide\n  , qstr = require('./util').qstr\n  , str = types.toString\n  , diff = require('../support/diff')\n  , physics = require('../sim/physics')\n  , interpolate = require('../sim/interpolate')\n  , World = require('../world')\n  , settings = require('../settings');\n\nEmitter(exports);\n\nvar buffered = []\n  , messages = []\n  , length = 0\n  , net = []\n  , loc = [];\n\n// ack is the last acknowledged frame\n// it's as far as we can forward and\n// know that we'll stay in sync\n// TODO what about on new game when the\n// world resets it's frame?\nvar ack = -1;\n\n// used to skip enqueing input during the replay\nvar replaying = false;\n\nexports.reset = function(all){\n  debug('reset %s',all ? '(all)' : '')\n  ack = -1;\n  if( all ){\n    net.length = 0;\n    loc.length = 0;\n    buffered.length = 0;\n    length = 0;\n  }\n}\n\nexports.info = function(){\n  return {\n    ack: ack,\n    replaying: replaying,\n    buffered: buffered.length,\n    length: length,\n    net: qstr(net),\n    loc: qstr(loc),\n  }\n}\n\nexports.send = function(frame,inputs){\n  // skip empty inputs\n  if( !inputs.length ){\n    return;\n  }\n\n  debug('send %s',frame, inputs)\n  var msg = buf.build(frame,inputs)\n\n  // 255 byte limit because of 8bit length header\n  if( msg.byteLength > 255 ){\n    // TODO split into more messages\n    throw new Error('invalid msg length: '+buf.byteLength);\n  }\n\n  buffered.push(msg);\n  length += msg.byteLength;\n}\n\nexports.flush = function(){\n  if( length ){\n    var msg = buf.wrap(buffered,length)\n    exports.emit('message',msg)\n    buffered.length = 0;\n    length = 0;\n    return true;\n\n  }\n  return false;\n}\n\nexports.onmessage = function(buffer){\n  // unwrap the arraybuffer into its messages\n  if( buf.unwrap(buffer,messages) ){\n    debug('onmessage %s messages',messages.length)\n    for(var i=0; i<messages.length; i++){\n      var inputs = buf.parse(messages[i]);\n      var frame = inputs[0];\n\n      // skip if frame is before ack\n      if( frame < ack ){\n        console.warn('got input in the wrong order (%s < %s). something wrong with netchan? or game has restarted? or frame > 16bit?',frame,ack,str(inputs.slice(1)))\n        continue;\n      }\n\n      for(var j=1; j<inputs.length; j++){\n        var inp = inputs[j];\n        if( types.validate(inp) ){\n          switch(inp[0]){\n            case types.MOVE: enqueue(net,frame,inp); break;\n            case types.DIED: enqueue(net,frame,inp); break;\n            case types.HIT:  exports.emit('hit',inp[1],inp[2],frame); break;\n            case types.MISS: exports.emit('miss',inp[1],0,frame); break;\n            case types.PING: exports.emit('ping',inp[1],frame); break;\n            case types.PONG: exports.emit('pong',inp[1],frame); break;\n          }\n        } else {\n          console.warn('received invalid input',inp)\n        }\n      }\n\n      // update ack\n      ack = frame;\n    }\n    debug('onmessage end ack: %s',ack)\n\n    // emit ack in case the game\n    // needs to fast forward a bit\n    exports.emit('ack',ack)\n\n    // reset messages when done\n    messages.length = 0;\n  }\n}\n\nexports.enqueue = function(frame,input){\n  replaying || enqueue(loc,frame,input)\n}\n\nexports.forward = function(sync,max,locFirst){\n  var a = sync.world.frame\n    , b = Math.min(max,ack);\n\n  // did we even start yet?\n  if( b === -1 ){\n    return;\n  }\n\n  // debug('forward %s -> %s (max: %s ack: %s)',a,b,max,ack);\n  if( locFirst ){\n    dequeue(loc,sync.world)\n    dequeue(net,sync.world)\n    for(var i=a; i<b; i++){\n      sync.update()\n      dequeue(loc,sync.world)\n      dequeue(net,sync.world)\n    }\n  } else {\n    dequeue(net,sync.world)\n    dequeue(loc,sync.world)\n    for(var i=a; i<b; i++){\n      sync.update()\n      dequeue(net,sync.world)\n      dequeue(loc,sync.world)\n    }\n  }\n}\n\n// used for replay, keeps the\n// \"before\" states of puck and paddles\nvar temp = new World('temp');\n\n// from = sync.world\n// to = game.world\n// frames = number of frames to interpolate over\nexports.replay = function(from,to,frames){\n  var a = from.frame\n    , b = to.frame;\n\n  if( replaying ){\n    return console.warn('attempted to do a replay during a replay. skipping.')\n  }\n\n  // debug('replay %s -> %s',a,b);\n\n  // keep a copy of the pucks for interpolation\n  temp.pucks.copy(to.pucks);\n\n  // copy to revert the state\n  to.copy(from);\n\n  // verify that they match after copy()\n  // verify(from,to) // NOTE: very heavy\n\n  // extrapolate to match the previous state\n  replaying = true;\n  extrapolate(to,b-a)\n  replaying = false;\n\n  // add interpolation between the temp\n  // and the post-replay-world.\n  interpolate(temp,to,frames)\n}\n\nfunction enqueue(queue,frame,input){\n  debug('enqueue %s %s %s',queue === loc ? '(loc)' : '(net)', frame, str(input))\n\n  // verify that the queue is in order (frame > last frame in queue)\n  var last = queue[queue.length-2];\n  if( frame < last ){\n    console.error('enqueue received an input too early. %s < %s', frame, last)\n    console.log('  in queue %s:',queue === loc ? '(loc)' : '(net)',qstr(queue))\n    return;\n  }\n  queue.push(frame,input)\n}\n\nfunction dequeue(queue,world){\n  // verify that the frame has not passed the first frame in queue\n  if( queue[0] < world.frame ){\n    console.error('dequeue cannot pass the first frame in queue. %s < %s', queue[0], world.frame)\n    console.log('  in queue %s:',queue === loc ? '(loc)' : '(net)',qstr(queue))\n    throw new Error()\n    return;\n  }\n\n  // execute inputs in queue matching the frame\n  while(queue[0]===world.frame){\n    var frame = queue.shift()\n      , input = queue.shift();\n    types.execute(world,input)\n\n    if( input[0] == types.MOVE ){\n      exports.emit('move',input);\n    }\n\n    exports.emit('dequeue',input,frame)\n  }\n}\n\n\n// to be used by replay() to avoid making copies of\n// the queues\nfunction peek(queue,world,start){\n  for(var i=start||0; i<queue.length; i+=2){\n    var frame = queue[i]\n      , input = queue[i+1];\n\n    // stop if frame doesn't match\n    if( frame !== world.frame ){\n      return i;\n    }\n\n    types.execute(world,input)\n  }\n  return i;\n}\n\nfunction extrapolate(world,steps){\n  var timestep = settings.data.timestep;\n  var l = 0;\n  var n = 0;\n  for(var i=0; i<steps; i++){\n    // apply inputs from queue\n    l = peek(loc,world,l)\n    n = peek(net,world,n)\n\n    // apply the physics only\n    physics.update(world,timestep)\n  }\n}\n\n// a, b = world\nfunction verify(a,b){\n  debug('verify')\n  if( a.code() !== b.code() ){\n\n    var ja = JSON.stringify(a,unhide,2);\n    var jb = JSON.stringify(b,unhide,2);\n    console.log(diff.createPatch('diff for frame '+a.frame,ja,jb,'game','sync'))\n\n    // alertOnce('hash codes does not match after copy. determinism is not guaranteed.')\n    // err(1301,'hash codes does not match')\n  }\n}\n//@ sourceURL=slam/lib/inputs/network.js"
));
require.register("slam/lib/inputs/buffer.js", Function("exports, require, module",
"var debug = require('debug')('inputs:buffer')\n  , Writer = require('../support/buffer').Writer\n  , Reader = require('../support/buffer').Reader\n  , types = require('./types')\n  , str = types.toString\n  , ab2s = require('./util').ab2s;\n\nvar buildBuf = new ArrayBuffer(1024); // pre-allocated buffer\nvar sendSeq = -1;\nvar recvSeq = -1;\n\n// for reconnects\nexports.reset = function(){\n  sendSeq = -1;\n  recvSeq = -1;\n}\n\nexports.build = function(frame,inputs){\n  debug('build',frame,str(inputs))\n  var dat = new Writer(buildBuf);\n\n  // write the frame\n  dat.setUint16(frame);\n\n  for(var i=0; i<inputs.length; i++) {\n    var input = inputs[i];\n    switch(input[0]){\n      case types.MOVE: // type, id, x\n      case types.DIED: // type, id, x\n        dat.setInt8(input[0])\n        dat.setUint8(input[1])\n        dat.setFloat64(input[2])\n        break;\n      case types.PING: // type, id\n      case types.PONG: // type, id\n        dat.setInt8(input[0])\n        dat.setUint16(input[1])\n        break;\n      case types.HIT:  // type, x, v\n        dat.setInt8(input[0])\n        dat.setFloat32(input[1])\n        dat.setFloat32(input[2])\n        break;\n      case types.MISS: // type, x\n        dat.setInt8(input[0])\n        dat.setFloat32(input[1])\n        break;\n    }\n  }\n\n  // return the written part of the buildBuf.\n  return new Uint8Array(buildBuf.slice(0,dat.offset));\n}\n\n// make an Array [frame,inputs...]\nexports.parse = function(buf){\n  debug('parse',ab2s(buf.buffer || buf))\n\n  // TODO will these allocations be an issue?\n  var arr = [];\n  var dat = new Reader(buf);\n\n  // frame\n  arr.push(dat.getUint16())\n\n  while(dat.offset < buf.byteLength){\n    var input = []\n      , type = dat.getInt8();\n    switch(type){\n      case types.MOVE: // type, id, x\n      case types.DIED: // type, id, x\n        input.push(type,dat.getUint8(),dat.getFloat64())\n        break;\n      case types.PING: // type, id\n      case types.PONG: // type, id\n        input.push(type,dat.getUint16())\n        break;\n      case types.HIT:  // type, x, v\n        input.push(type,dat.getFloat32(),dat.getFloat32())\n        break;\n      case types.MISS: // type, x\n        input.push(type,dat.getFloat32())\n        break;\n    }\n    arr.push(input);\n  }\n  return arr;\n}\n\nexports.wrap = function(messages,length){\n  // 2 = 16bit sequence\n  // length = total length of messages\n  // messages.length = 8bit length of each message\n  var buf = new Uint8Array(2+length+messages.length)\n    , off = 0\n    , seq = ++sendSeq;\n\n  // write sequence (manual 16bit > 2*8bit)\n  buf[off++] = (seq >> 8) & 0xff\n  buf[off++] = (seq >> 0) & 0xff\n\n  while(messages.length){\n    var msg = messages.shift();\n    buf[off++] = msg.byteLength;\n    buf.set(msg,off);\n    off += msg.byteLength;\n  }\n  return buf;\n}\n\nexports.unwrap = function(buf,messages){\n  debug('unwrap',buf.byteLength) // ab2s(buf)\n\n  // check for empty messages\n  if( !buf.byteLength ){\n    return false;\n  }\n\n  // expect multiple frames in one buf\n  // buf: [len,msg...]\n  var arr = new Uint8Array(buf);\n\n  // extract 16bit sequence\n  // (see envelop() for the other end)\n  var seq = (arr[0] << 8) + arr[1];\n\n  // verify sequence\n  if( !verifySequence(seq) ){\n    return false;\n  }\n\n  // get each input and add them to the\n  // messages array\n  for(var offset=2; offset<arr.byteLength;){\n    var len = arr[offset++];\n    messages.push(arr.buffer.slice(offset,offset+len));\n    offset += len;\n  }\n\n  return messages.length > 0;\n}\n\n\n// checks if last message sequence was\n// more than 1 frame away = DROPPED!\nfunction verifySequence(seq){\n  if( Math.abs(recvSeq - seq) > 1 ){\n    throw new Error('dropped packets. determinism is not guaranteed.')\n  } else if( recvSeq === seq ){\n    console.warn('packet %s received twice. skipping.',seq)\n    return false;\n  }\n  recvSeq = seq;\n  return true;\n}\n//@ sourceURL=slam/lib/inputs/buffer.js"
));
require.register("slam/lib/inputs/types.js", Function("exports, require, module",
"var debug = require('debug')('inputs:types');\n\nexports.PONG = -2;\nexports.PING = -1;\nexports.MOVE = 1;\nexports.DIED = 2; // player has been hit\nexports.HIT  = 3; // paddle has been hit\nexports.MISS = 4; // shield has been hit\n\nexports.execute = execute;\nexports.validate = validate;\nexports.toString = str;\n\nfunction str(input){\n  switch(input[0]){\n    case exports.PING: return 'PING('+input[1]+')';\n    case exports.PONG: return 'PONG('+input[1]+')';\n    case exports.MOVE: return 'MOVE('+input[1]+','+input[2]+')';\n    case exports.DIED: return 'DIED('+input[1]+','+input[2]+')';\n    case exports.MISS: return 'MISS('+input[1]+')';\n    case exports.HIT:  return  'HIT('+input[1]+','+input[2]+')';\n    default:\n      // assumes the input is an array of inputs\n      if( Array.isArray(input) ){\n        return input.map(str).join(' | ')\n      } else {\n        return 'invalid input!'\n      }\n  }\n}\n\nfunction validate(input){\n  switch(input && input[0]){\n    case exports.HIT:  // paddle position, paddle velocity\n    case exports.MOVE: // id, movement\n    case exports.DIED: // id, puck position\n      return input.length == 3;\n\n    case exports.MISS: // paddle position\n    case exports.PING: // id\n    case exports.PONG: // id\n      return input.length == 2;\n\n  }\n  return false;\n}\n\nfunction execute(world,input){\n  debug('execute %s %s',world.name,world.frame,world.state,str(input))\n  switch(input[0]){\n    case exports.MOVE:  return require('../actions').movePaddle(world,input[1],input[2])\n    case exports.DIED:  return require('../actions').roundOver(world,input[1],input[2])\n    case exports.HIT:   throw new Error('cannot execute HIT');\n    case exports.MISS:  throw new Error('cannot execute MISS');\n    case exports.PING:  throw new Error('cannot execute PING');\n    case exports.PONG:  throw new Error('cannot execute PONG');\n  }\n}//@ sourceURL=slam/lib/inputs/types.js"
));
require.register("slam/lib/inputs/util.js", Function("exports, require, module",
"var str = require('./types').toString\n  , join = [].join;\n\n// converts an ArrayBuffer to a string\nexports.ab2s = function(buf){\n  return join.call(new Uint8Array(buf));\n}\n\n\n// used as JSON replacer to\n// find undefined values and\n// remove excluded keys\nexports.unhide = function(k,v){\n  if( ~require('../world').EXCLUDED.indexOf(k) )\n    return undefined;\n  if( typeof v == 'undefined' )\n    return 'undefined'\n  return v;\n}\n\n\n// [frame,input...]\nexports.qstr = function(queue){\n  var s = [];\n  for(var i=0; i<queue.length; i+=2){\n    var frame = queue[i]\n      , input = queue[i+1];\n    s.push(frame + ': ' + str(input));\n  }\n  return 'Queue ('+queue.length+')\\n\\t'+s.join('\\n\\t');\n}\n\n//@ sourceURL=slam/lib/inputs/util.js"
));
require.register("slam/lib/rtc/index.js", Function("exports, require, module",
"// based on https://github.com/webRTC/webrtc.io-client\n\nvar Emitter = require('emitter')\n  , WebSocketSignal = require('./web-socket-signal')\n  , AppChannelSignal = require('./app-channel-signal')\n  , debug = { connection: require('debug')('rtc:connection'),\n              channel: require('debug')('rtc:channel') };\n\n// Fallbacks for vendor-specific variables until the spec is finalized.\nvar PeerConnection = window.webkitRTCPeerConnection\n                  || window.mozRTCPeerConnection\n                  || window.RTCPeerConnection;\n\nexports.servers = { iceServers: [\n  {url: 'stun:stun.l.google.com:19302'}\n]}\n\nexports.available = (function(){\n  if( typeof PeerConnection == 'function'\n      && PeerConnection.prototype // stupid mozilla\n      && typeof PeerConnection.prototype.createDataChannel == 'function' ){\n    try {\n      var pc = new PeerConnection(null,{optional: [{RtpDataChannels: true}]});\n      pc.createDataChannel('feat',{reliable:false})\n      return true;\n    } catch(e){\n      return false;\n    }\n  } else {\n    return false;\n  }\n})();\n\nexports.connect = function(opts){\n  opts = opts || {};\n  opts.dataChannels = opts.dataChannels || false;\n  opts.connectionTimeout = opts.connectionTimeout || 30000;\n\n  var rtc = Emitter({})\n    , channels = rtc.channels = {}\n    , connection\n    , signal\n    , timeout;\n\n  // default to appchannel signal\n  if( opts.signal == 'ws' ){\n    signal = rtc.signal = new WebSocketSignal(opts)\n  } else {\n    signal = rtc.signal = new AppChannelSignal(opts)\n  }\n\n  // Get TURN server configuration:\n  (function() {\n    var xhr = new XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState == 4 && xhr.status == 200) {\n        try {\n          data = JSON.parse(xhr.responseText);\n        } catch(e) {\n          // some error. use defaults.\n          debug.connection('got bad data from turn ajax service.');\n          return\n        }\n        if (data.uris && data.uris[0] && data.username && data.password) {\n          exports.servers.iceServers.push({\n            url: data.uris[0].replace(':', ':' + data.username + '@'),\n            credential: data.password\n          });\n          if (connection) { // Reinit connection if it has been inited already.\n            connection = createConnection();\n            createDataChannels();\n          }\n        }\n      }\n    };\n    xhr.open('GET', 'https://computeengineondemand.appspot.com/turn?username=apa&key=1329412323', true);\n    xhr.send();\n  })();\n\n  signal.on('open',function(){\n    if( connection ) rtc.close()\n    connection = createConnection();\n    createDataChannels();\n  })\n  signal.on('offer',function(desc){\n    connection.setRemoteDescription(rewriteSDP(desc));\n    connection.createAnswer(onLocalDescriptionAndSend);\n  })\n  signal.on('answer',function(desc){\n    connection.setRemoteDescription(rewriteSDP(desc));\n  })\n  signal.on('candidate',function(candidate){\n    if (!connection.remoteDescription) {\n      console.warn('ICE candidate: too soon?')\n    } else {\n      try {\n        debug.connection('signal icecandidate',arguments)\n        connection.addIceCandidate(candidate);\n      } catch(e){\n        console.warn('ICE candidate: too soon?',e)\n      }\n    }\n  })\n  signal.on('connected',function(){\n    // A peer has arrived\n    rtc.emit('connected')\n  })\n  signal.on('disconnected',function(){\n    // A peer has left\n    rtc.emit('disconnected')\n  })\n  signal.on('event',function(evt){\n    var type = evt.type;\n    delete evt.type;\n    rtc.emit(type,evt);\n  })\n  signal.on('error',function(evt){\n    rtc.emit('error',evt)\n  })\n\n  function createConnection(){\n    debug.connection('create')\n\n    // clear any previous timeouts\n    if( connection ){\n      stopTimeout('create');\n    }\n\n    var config = {optional: [{RtpDataChannels: !!opts.dataChannels}]};\n    var connection = new PeerConnection(exports.servers,config)\n    connection.onconnecting = function(e){\n      debug.connection('connecting',arguments)\n      rtc.emit('connecting',e)\n    }\n    connection.onopen = function(e){\n      debug.connection('open',arguments)\n      rtc.emit('open',e)\n      stopTimeout('onopen');\n    }\n    connection.onclose = function(e){\n      debug.connection('close',arguments)\n      rtc.emit('close',e)\n      stopTimeout('onclose');\n    }\n    connection.onaddstream = function(e){\n      debug.connection('addstream',arguments)\n      rtc.emit('addstream',e)\n    }\n    connection.onremovestream = function(e){\n      debug.connection('removestream',arguments)\n      rtc.emit('removestream',e)\n    }\n    connection.ondatachannel = function(e){\n      debug.connection('datachannel',arguments)\n      channels[e.channel.label] = setDataChannelListeners(e.channel);\n      rtc.emit('datachannel',e)\n    }\n    connection.ongatheringchange = function(e){\n      debug.connection('gatheringchange -> %s',connection.iceGatheringState,arguments)\n      rtc.emit('gatheringchange',e)\n      if( connection.iceGatheringState == 'complete' ){\n        stopTimeout('ongatheringchange');\n      } else {\n        // timeout if peer connection hasn't been established\n        // in 30s after the last candidate\n        startTimeout('ongatheringchange')\n      }\n    }\n    connection.onicecandidate = function(e){\n      debug.connection('icecandidate %s',opts.bufferCandidates ? '(buffered)' : '',arguments)\n      if( e.candidate ){\n        signal.send(e.candidate)\n      } else {\n        debug.connection('icecandidate end %s',opts.bufferCandidates ? '(buffered)' : '')\n        signal.send({candidate:null})\n      }\n      rtc.emit('icecandidate',e)\n    }\n    connection.oniceconnectionstatechange =\n    connection.onicechange = function(e){\n      debug.connection('icechange -> %s',connection.iceConnectionState,arguments)\n      rtc.emit('icechange',e)\n      if( connection.iceConnectionState == 'connected' ){\n        stopTimeout('onicechange');\n      } else if( connection.iceConnectionState != 'closed' ){\n        startTimeout('onicechange')\n      }\n    }\n    connection.onnegotiationneeded = function(e){\n      debug.connection('negotiationneeded',arguments)\n      rtc.emit('negotiationneeded',e)\n    }\n    connection.onsignalingstatechange =\n    connection.onstatechange = function(e){\n      debug.connection('statechange -> %s',connection.signalingState,arguments)\n      rtc.emit('statechange',e)\n      if( connection.signalingState == 'stable' ){\n        stopTimeout('onstatechange');\n      }\n    }\n\n    return rtc.connection = connection;\n  }\n\n  function createDataChannels() {\n    if( opts.dataChannels ){\n      var labels = typeof opts.dataChannels == 'string'\n        ? [opts.dataChannels]\n        : opts.dataChannels;\n      for(var i=0; i<labels.length; i++){\n        var label = labels[i];\n        channels[label] = createDataChannel(label);\n      }\n    }\n  }\n\n  function createDataChannel(label){\n    debug.channel('create',label);\n    var channel;\n    try {\n      // Reliable Data Channels not yet supported in Chrome\n      // Data Channel api supported from Chrome M25.\n      // You need to start chrome with  --enable-data-channels flag.\n      channel = connection.createDataChannel(label,{reliable: false});\n    } catch (e) {\n      alert('Failed to create data channel. ' +\n            'You need Chrome M25 or later with --enable-data-channels flag');\n      console.error('Create Data channel failed with exception: ' + e.message);\n    }\n    return setDataChannelListeners(channel);\n  }\n\n  function closeDataChannel(label){\n    var channel = channels[label];\n    if( channel.readyState != 'closed' )\n      channel.close();\n    channel.onmessage = null;\n    channel.onopen = null;\n    channel.onclose = null;\n    channel.onerror = null;\n    delete channels[label];\n  }\n\n  function setDataChannelListeners(channel){\n    if( channel ){\n      debug.channel('adding listeners',channel.label)\n      channel.onmessage = function(e){\n        debug.channel('message %s',channel.label,e)\n        rtc.emit('channel message',e)\n        rtc.emit('channel '+channel.label+' message',e)\n      }\n      channel.onopen = function(e){\n        debug.channel('open %s',channel.label)\n        rtc.emit('channel open',e)\n        rtc.emit('channel '+channel.label+' open',e)\n      }\n      channel.onclose = function(e){\n        debug.channel('close %s',channel.label)\n        rtc.emit('channel close',e)\n        rtc.emit('channel '+channel.label+' close',e)\n      }\n      channel.onerror = function(e){\n        debug.channel('error %s',channel.label,e)\n        rtc.emit('error',e)\n        rtc.emit('channel error',e)\n        rtc.emit('channel '+channel.label+' error',e)\n      }\n    }\n    return channel;\n  }\n\n  var startTimeout = function(from){\n    debug.connection('timeout started',from)\n    clearTimeout(timeout);\n    timeout = setTimeout(function(){\n      var err = new Error('connection timed out after all candidates has been sent');\n      err.code = 408;\n      rtc.emit('error',err);\n    },opts.connectionTimeout)\n  }\n\n  var stopTimeout = function(from){\n    if( timeout ){\n      debug.connection('timeout stopped',from)\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  }\n\n  var sendOffer = function(){\n    debug.connection('send offer')\n    connection.createOffer(onLocalDescriptionAndSend);\n  }\n\n  var onDescError = function(src){\n    return function(err){ console.warn('could not set %s description',src,err) }\n  }\n\n  var onLocalDescriptionAndSend = function(desc){\n    debug.connection('local description',desc)\n    connection.setLocalDescription(desc)\n    signal.send(desc)\n  }\n\n  rtc.addStream = function(stream){\n    debug.connection('adding local stream')\n    connection.addStream(stream);\n    return this;\n  }\n\n  rtc.reconnect = function(){\n    debug.connection('reconnect')\n    if( connection ) rtc.close(true)\n    connection = createConnection();\n    createDataChannels();\n    return this;\n  }\n\n  rtc.close = function(keepSignal){\n    debug.connection('close')\n\n    var labels = Object.keys(channels);\n    labels.forEach(closeDataChannel)\n\n    if( connection ){\n      stopTimeout('close')\n      if( connection.readyState != 'closed' )\n        connection.close()\n      connection.onconnecting = null;\n      connection.onopen = null;\n      connection.onclose = null;\n      connection.onaddstream = null;\n      connection.onremovestream = null;\n      connection.ondatachannel = null;\n      connection.ongatheringchange = null;\n      connection.onicecandidate = null;\n      connection.onicechange = null;\n      connection.onidentityresult = null;\n      connection.onnegotiationneeded = null;\n      connection.oniceconnectionstatechange = null;\n      connection.onsignalingstatechange = null;\n      connection.onstatechange = null;\n      connection = null;\n      rtc.connection = null;\n    }\n    keepSignal || signal.send('close')\n  }\n\n  rtc.send = function(label,data){\n    debug.channel('send',label,data)\n    var channel = channels[label];\n    if( channel ){\n      if( channel.readyState == 'open' ){\n        channel.send(data);\n      } else {\n        console.warn('tried to send data on a not open channel %s',label)\n      }\n    } else {\n      console.error('tried to send to non-existing channel %s',label);\n    }\n  }\n\n  rtc.start = function(){\n    debug.connection('start')\n    sendOffer()\n  }\n\n  return rtc;\n}\n\n\nfunction rewriteSDP(desc){\n  // adjust the bandwidth to 64kbps instead of default 30kbps\n  desc.sdp = desc.sdp.replace('b=AS:30','b=AS:64')\n  return desc;\n}\n//@ sourceURL=slam/lib/rtc/index.js"
));
require.register("slam/lib/rtc/web-socket-signal.js", Function("exports, require, module",
"var Emitter = require('emitter')\n  , debug = require('debug')('rtc:signal:ws');\n\n\nmodule.exports = WebSocketSignal;\n\n/**\n * The WebSocketSignal expects to connect\n * to a simple relay server.\n *\n * ex: https://gist.github.com/4547040#file-relay-js\n */\nfunction WebSocketSignal(opts){\n  opts = opts || {};\n  opts.url = opts.url || 'ws://localhost:8080/test';\n  opts.timeout = opts.timeout || 5000;\n  opts.retryTimeout = opts.retryTimeout || 500;\n  opts.maxAttempts = opts.maxAttempts || 5;\n\n  var retryTimeout = opts.retryTimeout;\n  var retryAttempts = 0;\n  var signal = Emitter({});\n\n  function create(){\n    debug('create')\n\n    retryTimeout *= 2;\n    retryAttempts++;\n    if( retryAttempts >= opts.maxAttempts )\n      return console.error('tried to connect to %s %s times without success. giving up.',opts.url,retryAttempts)\n\n    var ws = new WebSocket(opts.url)\n      , connected = null;\n\n    ws.onopen = function(){\n      debug('open')\n      signal.emit('open') // create the peer connection here\n      clearTimeout(ws.timeout)\n    }\n\n    ws.onmessage = function(m){\n      // reset retry timeout on first message\n      retryTimeout = opts.retryTimeout;\n      retryAttempts = 0;\n\n      var json = JSON.parse(m.data);\n      if( json && json.type == 'offer' ){\n        debug('offer',json)\n        signal.emit('offer',new RTCSessionDescription(json))\n\n      } else if( json && json.type == 'answer' ){\n        debug('answer',json)\n        signal.emit('answer',new RTCSessionDescription(json))\n\n      } else if( json && json.type == 'close' ){\n        debug('close')\n        signal.emit('close');\n\n      } else if( json && json.candidate ){\n        debug('candidate',[json])\n        signal.emit('candidate',new RTCIceCandidate(json))\n\n      } else if( json && json.a && json.b ){\n        if( !connected ){\n          connected = true;\n          debug('connected')\n          signal.emit('connected') // from peer\n        }\n\n      } else if( json && ((json.a && !json.b) || (json.b && !json.a)) ){\n        if( connected === true ){\n          connected = false;\n          debug('disconnected')\n          signal.emit('disconnected') // from peer\n        }\n\n      } else if( json ){\n        debug('message',m.data)\n        if( json.type ){\n          signal.emit('event',json)\n        }\n      } else {\n        console.warn('invalid json',json)\n      }\n    }\n\n    ws.onerror = function(e){\n      console.error('WS error: ',e)\n      clearTimeout(ws.timeout)\n      signal.emit('close')\n      signal.emit('error', e)\n    }\n\n    ws.onclose = function(){\n      // if we weren't connected the room is most likely\n      // full. in which case we let rtc know...\n      if( !connected ){\n        debug('closed (probably full)')\n        signal.emit('event',{type:'full'})\n\n      // if not it's probably a network error and\n      // we should retry a few times.\n      } else {\n        // TODO emit \"close\" only after a few attempts\n        //      and possible \"reconnected\" if retries\n        //      work...\n        debug('closed (retrying in %sms)',retryTimeout)\n        signal.emit('close')\n        clearTimeout(ws.timeout)\n        ws.timeout = setTimeout(create,retryTimeout)\n      }\n    }\n\n    clearTimeout(ws.timeout)\n    ws.timeout = setTimeout(function(e){\n      debug('timed out (retrying in %sms)',retryTimeout)\n      clearTimeout(ws.timeout)\n      ws.timeout = setTimeout(create,retryTimeout)\n    },opts.timeout)\n\n    signal.send = function(msg){\n      debug('send',msg)\n      if( ws.readyState == ws.OPEN ){\n        if( typeof msg == 'string' )\n          msg = JSON.stringify({type:msg});\n        else\n          msg = JSON.stringify(msg)\n        ws.send(msg)\n      } else {\n        console.error('attempted to send a message too early, waiting for open')\n        signal.on('open',signal.send.bind(signal,msg))\n      }\n    }\n\n    return signal;\n  }\n  return create();\n}//@ sourceURL=slam/lib/rtc/web-socket-signal.js"
));
require.register("slam/lib/rtc/app-channel-signal.js", Function("exports, require, module",
"var Emitter = require('emitter')\n  , debug = require('debug')('rtc:signal:appchan');\n\n\nmodule.exports = AppChannelSignal;\n\n/**\n * The AppChannelSignal uses an App Engine channel.\n */\nfunction AppChannelSignal(opts){\n  opts = opts || {};\n  opts.token = opts.token || '';\n  opts.room = opts.room || '';\n  opts.user = opts.user || '';\n  opts.timeout = opts.timeout || 15000;\n  opts.retryTimeout = opts.retryTimeout || 5000;\n  opts.maxAttempts = opts.maxAttempts || 5;\n  opts.bufferCandidates = opts.bufferCandidates || false;\n\n  var retryTimeout = opts.retryTimeout;\n  var retryAttempts = 0;\n  var signal = Emitter({});\n\n  // token is required and will be empty\n  // when room is full\n  if( !opts.token )\n    return signal;\n\n  if( typeof goog == 'undefined' )\n    return signal;\n\n  var channel = new goog.appengine.Channel(opts.token)\n\n  function create(){\n    debug('create',opts.token,opts.room,opts.user)\n\n    retryTimeout *= 2;\n    retryAttempts++;\n    if( retryAttempts >= opts.maxAttempts )\n      return console.error('tried to connect to %s %s times without success. giving up.',opts.url,retryAttempts)\n\n    var socket = channel.open()\n      , connected = null\n      , opened = false\n      , candidates = [];\n\n    socket.onopen = function(){\n      debug('open')\n      opened = true;\n\n      // Make sure server knows we connected. (Work-around for unreliable (and sometimes totally non-functioning) presence service @ google appengine.)\n      var req = new XMLHttpRequest()\n      req.open('POST', '/connect?from='+opts.user+'-'+opts.room, false)\n      req.send()\n\n      signal.emit('open') // create the peer connection here\n      clearTimeout(socket.timeout)\n    }\n\n    socket.onmessage = function(m){\n\n      // reset retry timeout on first message\n      retryTimeout = opts.retryTimeout;\n      retryAttempts = 0;\n\n      if( m.data == 'connected' ){\n        if( !connected ){\n          connected = true;\n          debug('connected')\n          signal.emit('connected') // from peer\n        }\n\n      } else if( m.data == 'disconnected' ){\n        if( connected === true ){\n          connected = false;\n          debug('disconnected')\n          signal.emit('disconnected') // from peer\n        }\n\n      } else {\n        var json = JSON.parse(m.data);\n        if( json && json.type == 'offer' ){\n          debug('offer',json)\n          signal.emit('offer',new RTCSessionDescription(json))\n\n        } else if( json && json.type == 'answer' ){\n          debug('answer',json)\n          signal.emit('answer',new RTCSessionDescription(json))\n\n        } else if( json && json.type == 'close' ){\n          close()\n\n        } else if( json && json.candidates ){\n          debug('candidates',[json])\n          for( var i=0; i<json.candidates.length; i++ ){\n            signal.emit('candidate',new RTCIceCandidate(json.candidates[i]))\n          }\n\n        } else if( json && json.candidate ){\n          debug('candidate',[json])\n          signal.emit('candidate',new RTCIceCandidate(json))\n\n        } else if( json ){\n          debug('message',m.data)\n          if( json.type ){\n            signal.emit('event',json)\n          }\n        } else {\n          console.warn('invalid json',json)\n        }\n      }\n    }\n\n    function close(){\n      debug('close')\n\n      clearTimeout(socket.timeout)\n      socket.close(); // will this throw?\n      signal.emit('close')\n\n      // re-connect if were connected\n      if( connected ){\n        connected = false;\n        signal.emit('disconnected')\n        socket.timeout = setTimeout(create,retryTimeout)\n      }\n    }\n\n    socket.onerror = function(e){\n      console.error('Socket error: ',e)\n      signal.emit('error', e)\n      close()\n    }\n\n    socket.onclose = function(){\n      // if we weren't connected the room is most likely\n      // full. in which case we let rtc know...\n      if( !connected ){\n        debug('closed (probably full)')\n        signal.emit('event',{type:'full'})\n\n      // if not it's probably a network error and\n      // we should retry a few times.\n      } else {\n        // TODO emit \"close\" only after a few attempts\n        //      and possible \"reconnected\" if retries\n        //      work...\n        debug('closed (retrying in %sms)',retryTimeout)\n        signal.emit('close')\n        clearTimeout(socket.timeout)\n        socket.timeout = setTimeout(create,retryTimeout)\n      }\n    }\n\n    clearTimeout(socket.timeout)\n    socket.timeout = setTimeout(function(e){\n      debug('timed out (retrying in %sms)',retryTimeout)\n      clearTimeout(socket.timeout)\n      socket.timeout = setTimeout(create,retryTimeout)\n    },opts.timeout)\n\n    signal.send = function(msg){\n      debug('send',msg)\n      if( opened ){\n        // an event\n        if( typeof msg == 'string' ){\n          msg = JSON.stringify({type:msg});\n\n        // received a candidate (to buffer)\n        } else if( 'candidate' in msg && opts.bufferCandidates ){\n          if( msg.candidate ){\n            candidates.push(msg);\n            return;\n\n          // end of candidates (= null)\n          } else {\n            msg = JSON.stringify({candidates:candidates})\n          }\n\n        // any other object to send\n        } else {\n          msg = JSON.stringify(msg)\n        }\n        var req = new XMLHttpRequest()\n        req.onerror = socket.onerror.bind(socket)\n        req.open('POST', '/message?from='+opts.user+'-'+opts.room, true)\n        req.setRequestHeader('Content-Type','application/json')\n        req.send(msg)\n      } else {\n        console.error('attempted to send a message too early, waiting for open')\n        signal.on('open',signal.send.bind(signal,msg))\n      }\n    }\n\n    // ensure the room is disconnect on leave\n    window.onbeforeunload = function() {\n      var req = new XMLHttpRequest()\n      req.open('POST', '/disconnect?from='+opts.user+'-'+opts.room, false)\n      req.send()\n    }\n\n    return signal;\n  }\n  return create();\n}\n//@ sourceURL=slam/lib/rtc/app-channel-signal.js"
));
require.register("slam/lib/sim/body.js", Function("exports, require, module",
"var debug = require('debug')('sim:body')\n  , BodyFlags = require('./body-flags')\n  , Pool = require('../support/pool')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec;\n\nmodule.exports = Body;\n\nfunction Body(){\n    this.aabb = [0,0,0,0]  //poly.aabb(this.shape)\n}\n\nBody.prototype = {\n\n  alloc: function(){\n    debug('alloc')\n    this.shape = null //poly.make() (assigned in world.createBody())\n    this.current = vec.make()\n    this.previous = vec.make()\n    this.velocity = vec.make()\n    this.offset = vec.make()\n    this.acceleration = vec.make()\n    this.target = null\n    this.removed = false      // mark as removed upon destroy\n\n    // used in broadphase and should always be\n    // the squared distance to the outermost vertex\n    // (updated in integration.js)\n    this.radiusSq = 0;\n\n    // used by puck to keep track of its active effects\n    // and by extras to keep a reference to their\n    // options (duration etc.)\n    this.data = {}\n\n    // used after a replay to interpolate between the\n    // before and after states of the puck and paddle\n    //\n    //  ex.\n    //\n    //    {\n    //      offset: vec.sub(before.current,after.current),\n    //      step: 1/f, // ex 1/10 = .1\n    //      frames: f   // ex 10 so\n    //    }\n    //\n    //  this will then be used in integration to set a\n    //  body.offset using:\n    //\n    //      vec.lerp(i.offset,z,i.step*i.frames--,body.offset)\n    //\n    //  during integration and body.offset will then be added\n    //  while rendering. This way the simulation will be jumping\n    //  and accurate but the rendering will be smooth and nice.\n    //\n    this.interpolate = {}\n\n    this.mass = 10;\n    this.damping = 1;         // 0-1\n\n    this.removed = false      // mark as removed upon destroy\n    this.id = null            // used by icons/extras\n    this.index = -1;          // will be set in world.createBody()\n  },\n\n  free: function(){\n    debug('free')\n\n    poly.free(this.shape)\n    vec.free(this.current)\n    vec.free(this.previous)\n    vec.free(this.velocity)\n    vec.free(this.acceleration)\n    vec.free(this.offset)\n\n    if( this.interpolate.offset ){\n      vec.free(this.interpolate.offset)\n    }\n\n    if( this.target ){\n        vec.free(this.target.position)\n        this.target.position = null\n    }\n\n    // null them to make sure they fail in case\n    // they're accessed again\n    this.shape = null\n    this.current = null\n    this.previous = null\n    this.velocity = null\n    this.offset = null\n    this.acceleration = null\n\n    this.data = null\n    this.interpolate = null\n    this.target = null\n  },\n\n  toString: function(inclFlags){\n    var str = '{'\n    +' c:'+this.current.join(',')\n    +' p:'+this.previous.join(',')\n    +' v:'+this.velocity.join(',')\n    +' a:'+this.acceleration.join(',');\n\n    if( inclFlags )\n      str += ' flags:'+BodyFlags.toString(this._flags);\n\n    return str +' }'\n  }\n\n}\n\nPool(Body,20)//@ sourceURL=slam/lib/sim/body.js"
));
require.register("slam/lib/sim/body-flags.js", Function("exports, require, module",
"var debug = require('debug')('sim:body-flags')\n\n// check if flag is on with:\n//    if( body.flags & Body.GHOST ) bla;\n// turn on:\n//    flags |= GHOST\n// turn off:\n//    flags &= ~GHOST\n// toggle:\n//    flags ^= GHOST\n// combine flags when created with:\n//    new Body(shape,x,y,Body.IMMOVABLE | Body.GHOST | Body.AWESOME)\n\n// add more flags by increasing the right integer (1<<2, 1<<3 etc)\nexports.DYNAMIC = 0 << 0;  // moves around\nexports.STATIC  = 1 << 0;  // stays put\nexports.DESTROY = 1 << 1;  // removed when hit\nexports.BOUNCE  = 1 << 2;  // will bounce off of anything that is BOUNCE and STEER or REFLECT\nexports.GHOST   = 1 << 3;  // passes through anything that is DYNAMIC\nexports.REFLECT = 0 << 4;  // reflects based on shape normal\nexports.STEER   = 1 << 4;  // reflects based on hit position\nexports.DIRECT  = 1 << 5;  // reflects based on shape normal + velocity\n\n// example definitions:\n// DEFAULT = DYNAMIC\n// BULLET = DYNAMIC | DESTROY\n// PUCK = DYNAMIC | BOUNCE\n// MULTI_PUCK = PUCK | DESTROY\n// GHOST_PUCK = PUCK | GHOST\n// PADDLE = DYNAMIC | BOUNCE | STEER\n// BRICK = STATIC | BOUNCE | DESTROY | REFLECT\n// OBSTACLE = STATIC | BOUNCE | REFLECT\n// EXTRA = STATIC | DESTROY\n\nexports.toString = function(f){\n  if( typeof f != 'number' ){\n    throw new Error('invalid flags, must be a number')\n  }\n  var s = []\n  if( f & exports.STATIC ){\n    s.push('STATIC');\n  } else {\n    s.push('DYNAMIC');\n  }\n  if( f & exports.DESTROY ){\n    s.push('DESTROY');\n  }\n  if( f & exports.BOUNCE ){\n    s.push('BOUNCE');\n  }\n  if( f & exports.GHOST ){\n    s.push('GHOST');\n  }\n  if( f & exports.DIRECT ){\n    s.push('DIRECT');\n  } else if( f & exports.STEER ){\n    s.push('STEER');\n  } else {\n    s.push('REFLECT');\n  }\n  return s.join(' | ')\n}\n\nexports.set = function(body,flags){\n  debug('set flags',body.id,exports.toString(flags))\n  body._flags = flags;\n}\n\nexports.has = function(body,flags){\n  // way too noisy...\n  // debug('has flags',Body.flags(flags))\n  return body._flags & flags;\n}\n\nexports.add = function(body,flags){\n  debug('add flags',body.id,exports.toString(flags))\n  debug(' =',exports.toString(body._flags))\n  body._flags |= flags;\n  debug(' >',exports.toString(body._flags))\n}\n\nexports.del = function(body,flags){\n  debug('del flags',body.id,exports.toString(flags))\n  debug(' =',exports.toString(body._flags))\n  body._flags &= ~flags;\n  debug(' >',exports.toString(body._flags))\n}\n//@ sourceURL=slam/lib/sim/body-flags.js"
));
require.register("slam/lib/sim/force.js", Function("exports, require, module",
"var geom = require('geom')\n  , vec = geom.vec;\n\nmodule.exports = Force;\n\n/**\n * A Force is a point which pulls or pushes on the Bodies\n */\nfunction Force(type,x,y,mass,power){\n  if( !type ) throw new Error('missing type')\n  this.type = type; // repell || attract\n  this.power = power || 1; // 0-1\n  this.mass = mass || 100;\n  this.radius = this.mass/2;\n  this.position = vec.make(x,y)\n  this.active = false;\n}\n\nForce.prototype = {\n  toString: function(){\n    return 'Force('+[\n      this.type,\n      'active:'+this.active,\n      'mass:'+this.mass,\n      'x:'+this.position[0],\n      'y:'+this.position[1]\n    ]+')'\n  }\n}//@ sourceURL=slam/lib/sim/force.js"
));
require.register("slam/lib/sim/physics.js", Function("exports, require, module",
"var debug = require('debug')('sim:physics')\n  , settings = require('../settings')\n  , onbounds = require('./bounds')\n  , oncollision = require('./collision')\n  , integration = require('./integration')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec;\n\nexports.update = update;\n\nvar removed = [];\nvar bodies = [];\nvar c = {};\n\nfunction broadphase(world,mayCollide,wasRemoved){\n  for(var i=0; i<world.bodies.length; i++){\n    var a = world.bodies.values[i];\n\n    // skip removed bodies\n    if( a.removed ){\n      wasRemoved.push(a);\n      continue;\n    }\n\n    // skip any other than puck and bullets\n    if( a.id != 'puck' && a.id != 'bullet' ){\n      continue;\n    }\n\n    // check if colliding with other bodies\n    for(var j=0; j<world.bodies.length; j++){\n      // skip self\n      if( i === j ) continue;\n\n      var b = world.bodies.values[j];\n\n      // whitelist\n      if( a.id == 'puck' ){\n        switch(b.id){\n          case 'puck':\n          case 'extra':\n          case 'obstacle':\n          case 'paddle':\n          case 'shield':\n            break;\n          default:\n            continue;\n        }\n      } else { // bullet\n        switch(b.id){\n          case 'paddle':\n          case 'obstacle':\n            break;\n          default:\n            continue;\n        }\n      }\n\n      // if closer than radius+velocity it may collide\n      var al = vec.len(a.velocity);\n      var bl = vec.len(b.velocity);\n      var ar = a.radius + al;\n      var br = b.radius + bl;\n      var d = vec.dist(a.current,b.current);\n      if( d-(ar+br) < 0 ){\n        // TODO should we check if the pair is in mayCollide first?\n        mayCollide.push(a,b);\n      }\n    }\n  }\n}\n\nfunction narrowphase(world,bodies,removed){\n  if( !bodies.length ) return;\n  var v = vec.make();\n  for(var i=0; i<bodies.length; i+=2){\n    var a = bodies[i]\n      , b = bodies[i+1];\n\n    // skip if removed\n    if( a.removed || b.removed ){\n      continue;\n    }\n\n    // calculate relative velocity\n    vec.sub(a.velocity,b.velocity,v);\n\n    // check for collision\n    poly.collides(a.shape,b.shape,v,c);\n\n    // for the ones actually colliding call \"oncollision\"\n    if( c.willIntersect ){\n      oncollision(world,a,b,c);\n      vec.free(c.minTranslationVector)\n      vec.free(c.nearestEdge)\n\n      // add to remove queue if marked for removal\n      a.removed && removed.push(a);\n      b.removed && removed.push(b);\n    // } else {\n    //   console.log('narrowphase not colliding',a.id,b.id)\n    //   console.log(' a aabb:',a.aabb.join(','))\n    //   console.log(' b aabb:',b.aabb.join(','))\n    //   console.log(' intersects?',collisions.intersects(a.aabb,b.aabb))\n    }\n  }\n  vec.free(v);\n}\n\nfunction checkbounds(world,removed){\n  var o = vec.make();\n  for(var i=0; i<world.bodies.length; i++){\n    var a = world.bodies.values[i];\n\n    // skip shield\n    if( a.id == 'shield' )\n      continue;\n\n    // skip obstacles\n    if( a.id == 'obstacle' )\n      continue;\n\n    // check bounds\n    var hit = oob(a.aabb,a.velocity,o)\n    if( hit ){\n      // console.log('HIT BOUNDS OK?!',a.id,a.index,bounds)\n      switch(a.id){\n        case 'puck':   onbounds.puck(world,a,o); break;\n        case 'bullet': onbounds.bullet(world,a,o); break;\n        case 'paddle': onbounds.paddle(world,a,o); break;\n        // ignore the rest...\n      }\n    }\n\n    // mark removed bodies\n    if( a.removed ){\n      removed.push(a);\n    }\n  }\n  vec.free(o);\n}\n\n// assumes bounds and aabb = [t,r,b,l]\n// if overlap it will return it as a vector\n// NOTE: it doesn't use the velocity in the Y-axis\n//       check to avoid accidental \"god mode\" when\n//       the puck never hits the player.\nfunction oob(aabb,v,o){\n  var bounds = settings.data.bounds;\n  o[0] = o[1] = 0\n  if( aabb[0] < bounds[0] )\n    o[1] = bounds[0] - (aabb[0] + v[1]);\n  if( aabb[1] + v[0] > bounds[1] )\n    o[0] = bounds[1] - (aabb[1] + v[0]);\n  if( aabb[2] > bounds[2] )\n    o[1] = bounds[2] - (aabb[2] + v[1]);\n  if( aabb[3] + v[0] < bounds[3] )\n    o[0] = bounds[3] - (aabb[3] + v[0]);\n  return o[0] !== 0 || o[1] !== 0;\n}\n\nfunction destroy(world,removed){\n  while(removed.length){\n    var body = removed.pop();\n    // there may be duplicates so check if\n    // it has a position still\n    if( body.current ){\n      world.destroyBody(body);\n    }\n  }\n}\n\nfunction integrate(world,tsq){\n  for(var i=0; i < world.bodies.length; i++){\n    var body = world.bodies.values[i];\n\n    // apply forces (if any)\n    for(var j=0; j < world.forces.length; j++){\n      if( body.id == 'puck'){ // only pucks? what about bullets?\n        integration.force(world.forces.values[j],body);\n      }\n    }\n\n    integration.body(body,tsq)\n  }\n}\n\nfunction update(world,timeStep){\n  // skip unless playing or preview\n  if( world.state != 'playing' && world.state != 'preview' )\n    return;\n\n  bodies.length = 0;\n  removed.length = 0;\n\n  // first check proximity and bounds\n  broadphase(world,bodies,removed);\n  // console.log('post broadphase %s collisions %s removed',bodies.length/2,removed.length)\n\n  // remove from world\n  // TODO also remove from `bodies` if found?\n  destroy(world,removed);\n\n  // check if actually colliding\n  narrowphase(world,bodies,removed);\n  // console.log('post narrowphase %s collisions %s removed',bodies.length/2,removed.length)\n\n  // remove from world any that was removed\n  // by \"oncollision\"\n  destroy(world,removed);\n\n  // check bounds after integration\n  // done after the collisions in case it has reflected\n  checkbounds(world,removed);\n\n  // remove from world any that was removed\n  // by \"onbounds\"\n  destroy(world,removed);\n\n  // update their position in the world\n  integrate(world,timeStep*timeStep);\n\n\n  // now we're at the next frame\n  world.frame += 1;\n}\n//@ sourceURL=slam/lib/sim/physics.js"
));
require.register("slam/lib/sim/shapes.js", Function("exports, require, module",
"var geom = require('geom')\n  , poly = geom.poly;\n\nexports.rect = function(w,h){\n  return poly.make(\n    0, 0,\n    0, h,\n    w, h,\n    w, 0\n  )\n}\n\nexports.oct = function(w){\n  return poly.make(\n    0,0,\n    w*0.5,0,\n    w*0.75,w*0.25,\n    0.75*w,w*0.75,\n    w*0.5,w,\n    0,w,\n    -0.25*w,w*0.75,\n    -0.25*w,w*0.25\n  )\n}\n\nexports.hex = function(w){\n  var hex = poly.make();\n  var a = 2 * Math.PI / 6;\n  for(var i=5; i >= 0; i--) {\n    poly.add(hex, w * Math.cos(i * a), w * Math.sin(i * a));\n  }\n  poly.close(hex)\n  return hex;\n}\n\nexports.triangle = function(w,h,side,vertical){\n  var triangle = poly.make()\n  if(!vertical) {\n    poly.add(triangle,0,-h);\n    poly.add(triangle,w*(side?1:-1),0);\n    poly.add(triangle,0,h);\n  } else {\n    poly.add(triangle,-w,0);\n    poly.add(triangle,0,h*(side?1:-1));\n    poly.add(triangle,w,0);\n  }\n  poly.close(triangle)\n  return triangle\n}\n\nexports.diamond = function(w){\n  var diamond = poly.make()\n  var a = 2 * Math.PI / 4;\n  for(var i=3; i >= 0; i--) {\n    poly.add(diamond, w * Math.cos(i * a), w * Math.sin(i * a) );\n  }\n  poly.close(diamond)\n  return diamond\n}\n//@ sourceURL=slam/lib/sim/shapes.js"
));
require.register("slam/lib/sim/integration.js", Function("exports, require, module",
"var debug = require('debug')('sim:integration')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec;\n\n// a temporary vector only required during the\n// update and not supposed to be available to\n// others\nvar next = vec.make()\n\n// a 0,0 vector that can be copied from without\n// allocating any array of vector.\nvar zero = vec.make()\n\n// verlet integration\nexports.body = function(body,tsq){\n  var c = body.current\n    , p = body.previous\n    , v = body.velocity\n    , a = body.acceleration\n    , o = body.offset\n    , i = body.interpolate\n    , t = body.target\n    , n = next\n    , z = zero;\n\n  // velocity = target - current\n  if( t && t.position ){\n    var tc = vec.sub(t.position,c)\n    vec.sdiv(tc,t.frames--,v)\n    vec.free(tc)\n    if( t.frames == 0 ){\n      vec.free(t.position)\n      t.frames = 0;\n      t.position = null;\n    }\n\n  // velocity = current - previous\n  } else {\n    vec.sub(c,p,v)\n  }\n\n  // damping\n  if( body.damping !== 1 ){\n    // damp until\n    // resets damping when the velocity of the body\n    // is lower than dampUntil^2\n    var duSq = body.dampUntil*body.dampUntil\n      , vSq = duSq && v[0]*v[0]+v[1]*v[1];\n    if( duSq && duSq > vSq ){\n      // console.log('stopping damping')\n      body.damping = 1;\n      delete body.dampUntil;\n    } else {\n      vec.smul(v,body.damping,v);\n    }\n  }\n\n  // next = current + velocity + acceleration/2 * (timestep*timestep)\n  n[0] = c[0] + v[0] + .5 * a[0] * tsq\n  n[1] = c[1] + v[1] + .5 * a[1] * tsq\n\n  vec.copy(c,p)     // previous = current\n  vec.copy(n,c)     // current = next\n  vec.copy(z,a)     // reset acceleration\n\n  // replay interpolation\n  // updates body.offset\n  if( i && i.frames ){\n    i.frames--\n    vec.lerp(z,i.offset,i.step*i.frames,o)\n    // console.log('applied interpolation to %s over %s frames',body.index,i.frames,i.offset.join(','),o.join(','))\n    if( i.frames <= 0 ){\n      // console.log('interpolation completed %s',o.join(','))\n      vec.copy(z,o) // reset offset\n      vec.free(i.offset)\n      i.offset = null\n      i.frames = null\n    }\n  }\n\n  // update the shape\n  move(body.shape,c)\n  poly.aabb(body.shape,body.aabb)\n}\n\n\nexports.force = function(force,body){\n  if( !force.active )\n    return;\n\n  switch( force.type ){\n\n    case 'attract':\n      var diff = vec.sub(force.position, body.current)\n        , distSq = vec.lenSq(diff)\n        , radiSq = force.radius*force.radius;\n      if( distSq < radiSq ){\n        // limit the distsq to avoid insane speeds\n        // when it gets too close to the center.\n        distSq = Math.max(100,distSq)\n        var f = (body.mass*force.mass)/distSq*force.power;\n        f = Math.min(.65, f)\n        var d = Math.sqrt(distSq);\n        exports.bodyForce(body, f * diff[0]/d, f * diff[1]/d);\n      }\n      vec.free(diff)\n      break;\n\n    case 'repell':\n      var diff = vec.sub(force.position, body.current)\n        , distSq = vec.lenSq(diff)\n        , radiSq = force.radius*force.radius;\n      if( distSq < radiSq ){\n        // limit the distsq to avoid insane speeds\n        // when it gets too close to the center.\n        distSq = Math.max(100,distSq)\n        var f = (body.mass*-force.mass)/distSq*force.power;\n        var d = Math.sqrt(distSq);\n        exports.bodyForce(body, f * diff[0]/d, f * diff[1]/d);\n      }\n      vec.free(diff)\n      break;\n\n    default:\n      throw new Error('invalid force')\n  }\n}\n\nexports.bodyForce = function(body,x,y){\n  var invMass = 1/body.mass;\n  var f = vec.make(x*invMass,y*invMass)\n  vec.add(body.acceleration, f, body.acceleration);\n  vec.free(f)\n}\n\n\nvar EPS = 1e-12;\nfunction eps(x){ return Math.round(x/EPS) * EPS }\n\nfunction move(shape,to){\n  var c = poly.centroid(shape)\n  var d = vec.sub(to,c)\n  poly.translate(shape, d[0] ,d[1]);\n  vec.free(c)\n  vec.free(d)\n}\n\n// [t,r,b,l]\nfunction center(aabb){\n  return vec.make((aabb[2]-aabb[0])/2,(aabb[1]-aabb[3])/2)\n}\n//@ sourceURL=slam/lib/sim/integration.js"
));
require.register("slam/lib/sim/interpolate.js", Function("exports, require, module",
"var debug = require('debug')('sim:interpolate')\n  , vec = require('geom').vec\n  , settings = require('../settings');\n\n/**\n * Adds properties to bodies `interpolate` object\n * which will be used in the integration to smooth\n * things about a bit between the two worlds.\n *\n * It should ignore interpolating if the difference is too\n * small.\n *\n *  ex.\n *\n *    {\n *      offset: vec.sub(before.current,after.current),\n *      step: 1/f, // ex 1/10 = .1\n *      frames: f   // ex 10 so\n *    }\n *\n *\n * @param {World} before The (temporary) world before the replay\n * @param {World} after The current world after the replay\n */\nmodule.exports = function interpolate(before, after, frames){\n  frames = Math.min(settings.data.interpolationMaxFrames,frames)\n  if( !frames ){\n    return;\n  }\n\n  // interpolate pucks\n  for(var i=0; i<after.pucks.length; i++){\n    var a = after.pucks.values[i];\n    if( before.pucks.has(a.index) ){\n      interpolateBody(a,before.pucks.get(a.index),frames)\n    }\n  }\n}\n\n// applies the interpolation to a single body\nfunction interpolateBody(a,b,f){\n  var i = a.interpolate;\n\n  // skip if it already has interpolation\n  // TODO should we re-create instead and make\n  //      sure we free the old ones first?\n  if( i.frames ){\n    // vec.free(i.offset)\n    // i.offset = null\n    // i.frames = null\n    console.log('skipping interpolation of %s because it already has one')\n    return;\n  }\n\n  // skip if distance is too large or small\n  var maxDist = settings.data.interpolationMaxDistance\n    , minDist = settings.data.interpolationMinDistance\n    , dist = vec.distSq(a.current,b.current);\n\n  if( dist < minDist*minDist ){\n    debug('skipping too short interpolation for %s (dist: %s)',a.index,Math.sqrt(dist))\n  } else if( dist > maxDist*maxDist ){\n    debug('skipping too long interpolation for %s (dist: %s)',a.index,Math.sqrt(dist))\n  } else {\n    i.offset = vec.sub(b.current,a.current);\n    vec.copy(i.offset,a.offset)\n    i.step = 1/(f+1);\n    i.frames = f;\n  }\n\n  // no need to free i.offset, it will be freed when done\n}//@ sourceURL=slam/lib/sim/interpolate.js"
));
require.register("slam/lib/sim/collision.js", Function("exports, require, module",
"var debug = require('debug')('sim:collision')\n  , settings = require('../settings')\n  , actions = require('../actions')\n  , BodyFlags = require('./body-flags')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec;\n\n\nmodule.exports = function collision(world,a,b,c){\n  // console.log('collides:')\n  // console.log('  a: %s:%s (%s)',a.id,a.index,BodyFlags.toString(a._flags))\n  // console.log('  b: %s:%s (%s)',b.id,b.index,BodyFlags.toString(b._flags))\n\n  // GHOST\n  if( (BodyFlags.has(a,BodyFlags.GHOST) && !BodyFlags.has(b,BodyFlags.STATIC)) ||\n      (BodyFlags.has(b,BodyFlags.GHOST) && !BodyFlags.has(a,BodyFlags.STATIC))){\n    // console.log(\"GHOST COLLISION!\")\n    // just ignoring for now\n    // but maybe even skip oncollision()?\n    // and should it bounce off of STATICs?\n    return;\n\n  // BOUNCE\n  } else if( BodyFlags.has(a,BodyFlags.BOUNCE) && BodyFlags.has(b,BodyFlags.BOUNCE) ){\n\n    // currently intersecting. move apart\n    // but don't change the velocity (it will be done below depending on flags)\n    if( c.intersect ){\n      fixIntersection(world,a,b,c)\n    }\n\n    if( BodyFlags.has(b,BodyFlags.DIRECT) ){\n      bounceDirect(world,a,b,c)\n\n    } else if( BodyFlags.has(b,BodyFlags.STEER) ){\n      bounceSteer(world,a,b,c)\n\n    } else {\n      bounceReflect(world,a,b,c)\n    }\n  }\n\n  // handle the collision based on\n  // body types\n  switch(a.id){\n    case 'puck':\n      switch(b.id){\n        case 'extra': return actions.hitPuckExtra(world,a,b);\n        case 'paddle': return actions.hitPuckPaddle(world,a,b);\n        case 'shield': return actions.hitPuckShield(world,a,b);\n        case 'obstacle': return actions.hitPuckObstacle(world,a,b);\n      }\n      return console.warn('unknown collision between %s and %s',a.id,b.id)\n\n    case 'bullet':\n      switch(b.id){\n        case 'paddle': return actions.hitBulletPaddle(world,a,b);\n        case 'obstacle': return actions.hitBulletObstacle(world,a,b);\n      }\n      return console.warn('unknown collision between %s and %s',a.id,b.id)\n  }\n}\n\nfunction fixIntersection(world,a,b,c){\n  var t = c.minTranslationVector;\n\n  // if both are DYNAMIC `a` should + t*.5 and `b` - t*.5.\n  // (see http://elancev.name/oliver/2D%20polygon.htm)\n  if( !BodyFlags.has(a,BodyFlags.STATIC) && !BodyFlags.has(b,BodyFlags.STATIC) ){\n    // split t in half\n    t[0] = t[0]/2\n    t[1] = t[1]/2\n\n    // update a\n    vec.add(a.previous,t,a.previous);\n    vec.add(a.current,t,a.current);\n    poly.translate(a.shape, t[0] ,t[1]);\n    poly.aabb(a.shape,a.aabb);\n\n    // update b\n    vec.sub(b.previous,t,b.previous);\n    vec.sub(b.current,t,b.current);\n    poly.translate(b.shape, -t[0] ,-t[1]);\n    poly.aabb(b.shape,b.aabb);\n\n  // otherwise only move a\n  } else {\n    vec.add(a.previous,t,a.previous);\n    vec.add(a.current,t,a.current);\n    poly.translate(a.shape, t[0] ,t[1]);\n    poly.aabb(a.shape,a.aabb);\n  }\n}\n\nfunction bounceDirect(world,a,b,c){\n  // console.log(\"BOUNCE DIRECT!\")\n  var I = vec.norm(a.velocity)\n    , n = vec.perp(c.nearestEdge)\n    , r = vec.reflect(I,vec.norm(n,n))\n    , l = vec.len(a.velocity);\n\n  // add the x-velocity of the paddle to the reflection angle\n  var d = b.velocity[0] / 10;\n  r[0] += d;\n\n  r[0] /= 4;\n\n  // normalizing again to avoid any additional velocity\n  vec.smul(vec.norm(r,r),l,r)\n\n  // update puck positions\n  vec.sub(a.current,r,a.previous)\n\n  // update velocity (which is used to check for other collisions)\n  vec.copy(r,a.velocity)\n\n  vec.free(r)\n  vec.free(I)\n  vec.free(n)\n}\n\nfunction bounceSteer(world,a,b,c){\n  // console.log(\"BOUNCE STEER!\")\n  // divide the diff w. width to get the x normal\n  var I = vec.norm(a.velocity)\n    , n = vec.perp(c.nearestEdge)\n    , r = vec.reflect(I,vec.norm(n,n))\n    , l = vec.len(a.velocity)\n    , d = (a.current[0] - b.current[0])/(a.aabb[1]-b.aabb[3]);\n\n  // as nearestEdge is a bit shaky in it's\n  // reliability we have the option of using\n  // one that find an edge that crosses the\n  // line between the centroids of the two\n  // polygons.\n  if( settings.data.improvedNormals ){\n    improveNormals(a,b,I,r)\n  }\n\n  // divide to make it less horizontal when\n  // we have momentum than without momentum\n  r[0] = settings.data.paddleMomentum\n         ? d/settings.data.steerWidthMomentum\n         : d/settings.data.steerWidth;\n\n  // normalizing again to avoid any additional velocity\n  vec.smul(vec.norm(r,r),l,r)\n\n  // update puck positions\n  vec.sub(a.current,r,a.previous)\n\n  // update velocity (which is used to check for other collisions)\n  vec.copy(r,a.velocity)\n\n  vec.free(r)\n  vec.free(I)\n  vec.free(n)\n}\n\nfunction bounceReflect(world,a,b,c){\n  // console.log(\"BOUNCE REFLECT!\",a.id,a.index)\n  var I = vec.norm(a.velocity)\n    , n = vec.perp(c.nearestEdge)\n    , r = vec.reflect(I,vec.norm(n,n))\n    , l = vec.len(a.velocity)\n\n  // as nearestEdge is a bit shaky in it's\n  // reliability we have the option of using\n  // one that find an edge that crosses the\n  // line between the centroids of the two\n  // polygons.\n  if( settings.data.improvedNormals ){\n    improveNormals(a,b,I,r)\n  }\n\n  // make sure it has the original velocity\n  vec.smul(r,l,r)\n\n  // console.log('before reflect')\n  // console.log(' c:',a.current)\n  // console.log(' p:',a.previous)\n  // console.log(' v:',a.velocity)\n\n  // update puck positions\n  vec.sub(a.current,r,a.previous)\n\n  // update velocity (which is used to check for other collisions)\n  vec.copy(r,a.velocity)\n\n  // console.log('after reflect')\n  // console.log(' c:',a.current)\n  // console.log(' p:',a.previous)\n  // console.log(' v:',a.velocity)\n\n  vec.free(r)\n  vec.free(I)\n  vec.free(n)\n}\n\n\nfunction improveNormals(a,b,I,r){\n  var x = vec.make(); // output normal\n  var o = vec.copy(a.current) // origin\n  var t = vec.copy(b.current) // target\n  var s = vec.sub(t,o) // ray\n\n  // extend `s` backwards by `a.radius` to\n  // avoid a possible issue where the lines won't\n  // intersect.\n  var ext = vec.norm(s)\n  vec.smul(ext,a.radius,ext)\n  vec.sub(o,ext,o)\n\n  // update s\n  vec.sub(t,o,s)\n\n  if( findEdgeNormal(b.shape,o,s,x) ){\n    vec.reflect(I,x,r)\n  }\n  vec.free(t)\n  vec.free(o)\n  vec.free(s)\n  vec.free(x)\n}\n\n/**\n * Sends a ray (the vector) into the Polygon\n * to see which edge segment it intersects.\n *\n * Based on: http://afloatingpoint.blogspot.se/2011/04/2d-polygon-raycasting.html\n *\n * @param  {Polygon} p The polygon\n * @param  {Vector} o The ray origin\n * @param  {Vector} v The ray direction\n * @param  {Vector} n The edge normal (if found)\n * @return {Boolean} true if normal was found\n */\nfunction findEdgeNormal(p,o,v,n){\n  var e = vec.add(o,v)\n  var f = vec.make()\n  for(var i=0; i<p.length; i++){\n    var a = p.vertices[i];\n    var b = vec.add(a,p.edges[i],f)\n    if( intersectsLineLine(o,e,a,b) ){\n      vec.perp(p.edges[i],n)\n      vec.norm(n,n)\n      vec.free(f)\n      vec.free(e)\n      return true;\n    }\n  }\n  vec.free(e)\n  vec.free(f)\n  return false;\n}\n\nfunction intersectsLineLine(a1,a2,b1,b2,i){\n  var uaT = (b2[0] - b1[0]) * (a1[1]-b1[1]) - (b2[1]-b1[1]) * (a1[0]-b1[0]);\n  var ubT = (a2[0] - a1[0]) * (a1[1]-b1[1]) - (a2[1]-a1[1]) * (a1[0]-b1[0]);\n  var u   = (b2[1] - b1[1]) * (a2[0]-a1[0]) - (b2[0]-b1[0]) * (a2[1]-a1[1]);\n  if( u !== 0 ){\n    var ua = uaT / u;\n    var ub = ubT / u;\n\n    if( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ){\n      // intersection point:\n      if( i ){\n        i[0] = a1[0]+ua*(a2[0]-a1[0])\n        i[1] = a1[1]+ua*(a2[1]-a1[1])\n      }\n      return true;\n    } else {\n      // no intersection\n      return false;\n    }\n\n  } else if( uaT === 0 || ubT === 0 ){\n    // coincident\n    return false;\n  } else {\n    // parallel\n    return false;\n  }\n}//@ sourceURL=slam/lib/sim/collision.js"
));
require.register("slam/lib/sim/bounds.js", Function("exports, require, module",
"var debug = require('debug')('sim:bounds')\n  , actions = require('../actions')\n  , settings = require('../settings')\n  , BodyFlags = require('./body-flags')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec\n  , dmaf = require('../dmaf.min');\n\n/**\n * Will take care of the collision between\n * a body and boundries detected in physics.js.\n *\n * @param  {World} world\n * @param  {Body} a     A body\n * @param  {Object} b   Collision information (ex. {})\n * @return\n */\n\n\nexports.puck = function(world,p,b){\n  debug('puck',p.index)\n\n  var h = (p.aabb[2] - p.aabb[0])*.5;\n\n  // first see if we hit the bounds behind\n  // any player?\n  var player = null;\n  if( p.current[1] <= h ){\n    player = world.players.b;\n  } else if( p.current[1] >= settings.data.arenaHeight-h  ){\n    player = world.players.a;\n  }\n\n  // offset b to avoid intersection\n  vec.add(p.current, b, p.current)\n\n  // flip velocity by adding it to current\n  // (moving the previous ahead)\n  if( b[0] ) p.previous[0] = p.current[0] + p.velocity[0]\n  if( b[1] ) p.previous[1] = p.current[1] + p.velocity[1]\n\n  // update the velocity\n  vec.sub(p.current, p.previous, p.velocity)\n\n  // negate the offset if there is one\n  if( p.interpolate.offset ){\n    // console.log('negating the interpolation offset')\n    if( b[0] ) p.interpolate.offset[0] = -p.interpolate.offset[0];\n    if( b[1] ) p.interpolate.offset[1] = -p.interpolate.offset[1];\n  }\n\n  // check for player\n  if( player && !BodyFlags.has(p,BodyFlags.GHOST) && !settings.data.godMode){\n    actions.playerHit(world,player,p);\n  } else {\n    dmaf.tell('wall_hit');\n  }\n\n  actions.puckBounced(world,p)\n}\n\n\nexports.paddle = function(world,p,b){\n  debug('paddle',p.index)\n  // offset b to avoid intersection\n  // reset velocity by settings previous to current\n  vec.add(p.current, b, p.current)\n  vec.copy(p.current, p.previous)\n}\n\n\nexports.bullet = function(world,p,b){\n  debug('bullet',p.index)\n  actions.destroyBullet(world,p);\n}\n\n//@ sourceURL=slam/lib/sim/bounds.js"
));
require.register("slam/lib/support/aabb.js", Function("exports, require, module",
"\n/**\n * A helper method to see if a body is\n * colliding with any others in the world.\n *\n * @param  {World} world\n * @param  {Body} a\n * @return {Boolean} `true` in case of collision\n */\nexports.colliding = colliding;\nfunction colliding(world,a){\n  for(var j=0; j < world.bodies.length; j++){\n    var b = world.bodies.values[j]\n    // skip self\n    if( b === a ) {\n      continue;\n    }\n\n    // fix for preventing obstacles to collide with\n    // each other when spawning\n    if( b.id == 'obstacle' && a.id == 'obstacle'){\n      continue;\n    }\n\n    if( intersects(a.aabb,b.aabb) ){\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks if two AABB arrays intersects.\n *\n * Used for a faster `colliding()` check, since velocities\n * are not required for their use (extra creation).\n *\n * @param {AABB} a [t,r,b,l]\n * @param {AABB} b [t,r,b,l]\n * @return {Boolean} `true` if they intersect\n */\nexports.intersects = intersects;\nfunction intersects(a,b){\n  if( b[3] > a[1] || a[3] > b[1] ) return false;\n  if( b[0] > a[2] || a[0] > b[2] ) return false;\n  return true;\n}//@ sourceURL=slam/lib/support/aabb.js"
));
require.register("slam/lib/support/diff.js", Function("exports, require, module",
"/* See license.txt for terms of usage */\n\n/*\n * Text diff implementation.\n * \n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n * \n * JsDiff.diffCss: Diff targeted at CSS content\n * \n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\nvar JsDiff = (function() {\n  function clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n  }\n  function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, \"&amp;\");\n    n = n.replace(/</g, \"&lt;\");\n    n = n.replace(/>/g, \"&gt;\");\n    n = n.replace(/\"/g, \"&quot;\");\n\n    return n;\n  }\n\n\n  var fbDiff = function(ignoreWhitespace) {\n    this.ignoreWhitespace = ignoreWhitespace;\n  };\n  fbDiff.prototype = {\n      diff: function(oldString, newString) {\n        // Handle the identity case (this is due to unrolling editLength == 0\n        if (newString == oldString) {\n          return [{ value: newString }];\n        }\n        if (!newString) {\n          return [{ value: oldString, removed: true }];\n        }\n        if (!oldString) {\n          return [{ value: newString, added: true }];\n        }\n\n        newString = this.tokenize(newString);\n        oldString = this.tokenize(oldString);\n\n        var newLen = newString.length, oldLen = oldString.length;\n        var maxEditLength = newLen + oldLen;\n        var bestPath = [{ newPos: -1, components: [] }];\n\n        // Seed editLength = 0\n        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n        if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\n          return bestPath[0].components;\n        }\n\n        for (var editLength = 1; editLength <= maxEditLength; editLength++) {\n          for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\n            var basePath;\n            var addPath = bestPath[diagonalPath-1],\n                removePath = bestPath[diagonalPath+1];\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n            if (addPath) {\n              // No one else is going to attempt to use this value, clear it\n              bestPath[diagonalPath-1] = undefined;\n            }\n\n            var canAdd = addPath && addPath.newPos+1 < newLen;\n            var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n            if (!canAdd && !canRemove) {\n              bestPath[diagonalPath] = undefined;\n              continue;\n            }\n\n            // Select the diagonal that we want to branch from. We select the prior\n            // path whose position in the new string is the farthest from the origin\n            // and does not pass the bounds of the diff graph\n            if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n              basePath = clonePath(removePath);\n              this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\n            } else {\n              basePath = clonePath(addPath);\n              basePath.newPos++;\n              this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\n            }\n\n            var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\n\n            if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\n              return basePath.components;\n            } else {\n              bestPath[diagonalPath] = basePath;\n            }\n          }\n        }\n      },\n\n      pushComponent: function(components, value, added, removed) {\n        var last = components[components.length-1];\n        if (last && last.added === added && last.removed === removed) {\n          // We need to clone here as the component clone operation is just\n          // as shallow array clone\n          components[components.length-1] =\n            {value: this.join(last.value, value), added: added, removed: removed };\n        } else {\n          components.push({value: value, added: added, removed: removed });\n        }\n      },\n      extractCommon: function(basePath, newString, oldString, diagonalPath) {\n        var newLen = newString.length,\n            oldLen = oldString.length,\n            newPos = basePath.newPos,\n            oldPos = newPos - diagonalPath;\n        while (newPos+1 < newLen && oldPos+1 < oldLen && this.equals(newString[newPos+1], oldString[oldPos+1])) {\n          newPos++;\n          oldPos++;\n          \n          this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\n        }\n        basePath.newPos = newPos;\n        return oldPos;\n      },\n\n      equals: function(left, right) {\n        var reWhitespace = /\\S/;\n        if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {\n          return true;\n        } else {\n          return left == right;\n        }\n      },\n      join: function(left, right) {\n        return left + right;\n      },\n      tokenize: function(value) {\n        return value;\n      }\n  };\n  \n  var CharDiff = new fbDiff();\n  \n  var WordDiff = new fbDiff(true);\n  WordDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\s+|\\b)/));\n  };\n  \n  var CssDiff = new fbDiff(true);\n  CssDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n  };\n  \n  var LineDiff = new fbDiff();\n  LineDiff.tokenize = function(value) {\n    return value.split(/^/m);\n  };\n  \n  return {\n    diffChars: function(oldStr, newStr) { return CharDiff.diff(oldStr, newStr); },\n    diffWords: function(oldStr, newStr) { return WordDiff.diff(oldStr, newStr); },\n    diffLines: function(oldStr, newStr) { return LineDiff.diff(oldStr, newStr); },\n\n    diffCss: function(oldStr, newStr) { return CssDiff.diff(oldStr, newStr); },\n\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n      var ret = [];\n\n      ret.push(\"Index: \" + fileName);\n      ret.push(\"===================================================================\");\n      ret.push(\"--- \" + fileName + (typeof oldHeader === \"undefined\" ? \"\" : \"\\t\" + oldHeader));\n      ret.push(\"+++ \" + fileName + (typeof newHeader === \"undefined\" ? \"\" : \"\\t\" + newHeader));\n\n      var diff = LineDiff.diff(oldStr, newStr);\n      if (!diff[diff.length-1].value) {\n        diff.pop();   // Remove trailing newline add\n      }\n      diff.push({value: \"\", lines: []});   // Append an empty value to make cleanup easier\n\n      function contextLines(lines) {\n        return lines.map(function(entry) { return ' ' + entry; });\n      }\n      function eofNL(curRange, i, current) {\n        var last = diff[diff.length-2],\n            isLast = i === diff.length-2,\n            isLastOfType = i === diff.length-3 && (current.added === !last.added || current.removed === !last.removed);\n\n        // Figure out if this is the last line for the given file and missing NL\n        if (!/\\n$/.test(current.value) && (isLast || isLastOfType)) {\n          curRange.push('\\\\ No newline at end of file');\n        }\n      }\n\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n          oldLine = 1, newLine = 1;\n      for (var i = 0; i < diff.length; i++) {\n        var current = diff[i],\n            lines = current.lines || current.value.replace(/\\n$/, \"\").split(\"\\n\");\n        current.lines = lines;\n\n        if (current.added || current.removed) {\n          if (!oldRangeStart) {\n            var prev = diff[i-1];\n            oldRangeStart = oldLine;\n            newRangeStart = newLine;\n            \n            if (prev) {\n              curRange = contextLines(prev.lines.slice(-4));\n              oldRangeStart -= curRange.length;\n              newRangeStart -= curRange.length;\n            }\n          }\n          curRange.push.apply(curRange, lines.map(function(entry) { return (current.added?\"+\":\"-\") + entry; }));\n          eofNL(curRange, i, current);\n\n          if (current.added) {\n            newLine += lines.length;\n          } else {\n            oldLine += lines.length;\n          }\n        } else {\n          if (oldRangeStart) {\n            // Close out any changes that have been output (or join overlapping)\n            if (lines.length <= 8 && i < diff.length-2) {\n              // Overlapping\n              curRange.push.apply(curRange, contextLines(lines));\n            } else {\n              // end the range and output\n              var contextSize = Math.min(lines.length, 4);\n              ret.push(\n                  \"@@ -\" + oldRangeStart + \",\" + (oldLine-oldRangeStart+contextSize)\n                  + \" +\" + newRangeStart + \",\" + (newLine-newRangeStart+contextSize)\n                  + \" @@\");\n              ret.push.apply(ret, curRange);\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n              if (lines.length <= 4) {\n                eofNL(ret, i, current);\n              }\n\n              oldRangeStart = 0;  newRangeStart = 0; curRange = [];\n            }\n          }\n          oldLine += lines.length;\n          newLine += lines.length;\n        }\n      }\n\n      return ret.join('\\n') + '\\n';\n    },\n\n    convertChangesToXML: function(changes){\n      var ret = [];\n      for ( var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push(\"<ins>\");\n        } else if (change.removed) {\n          ret.push(\"<del>\");\n        }\n\n        ret.push(escapeHTML(change.value));\n\n        if (change.added) {\n          ret.push(\"</ins>\");\n        } else if (change.removed) {\n          ret.push(\"</del>\");\n        }\n      }\n      return ret.join(\"\");\n    },\n    \n    convertChangesToDMP: function(changes){\n      var ret = [], change;\n      for ( var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        ret.push([(change.added ? 1 : change.removed ? -1 : 0), change.value]);\n      }\n      return ret;\n    }\n  };\n})();\n\nif (typeof module !== \"undefined\") {\n    module.exports = JsDiff;\n}//@ sourceURL=slam/lib/support/diff.js"
));
require.register("slam/lib/support/inspect.js", Function("exports, require, module",
"\nmodule.exports = inspect;\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  if (opts) {\n    // got an \"options\" object\n    extend(ctx, opts);\n  }\n  // set default options\n  if (typeof ctx.showHidden === 'undefined') \n    ctx.showHidden = false;\n  if (typeof ctx.depth === 'undefined') \n    ctx.depth = 2;\n  if (typeof ctx.colors === 'undefined') \n    ctx.colors = false;\n  if (typeof ctx.customInspect === 'undefined') \n    ctx.customInspect = true;\n  if (ctx.colors) \n    ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect && value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    return String(value.inspect(recurseTimes));\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (typeof value === 'function') {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  try { \n    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] } \n  } catch(e){\n    return '';\n  };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\nfunction extend(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || typeof add !== 'object') return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}//@ sourceURL=slam/lib/support/inspect.js"
));
require.register("slam/lib/support/draw.js", Function("exports, require, module",
"var geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec;\n\nmodule.exports = function(ctx){\n  return new Draw(ctx);\n}\n\nfunction Draw(ctx){\n  this.ctx = ctx;\n}\n\nDraw.prototype = {\n  clear: function(){\n    this.ctx.clearRect(0,0,canvas.width,canvas.height)\n  },\n  poly: function(p){\n    this.ctx.beginPath();\n    var v = p.vertices[0]\n      , x = v[0]\n      , y = v[1];\n\n    for(var i=0; i < p.edges.length; i++){\n      var e = p.edges[i];\n      this.ctx.moveTo(x,y)\n      this.ctx.lineTo(x+e[0],y+e[1]);\n\n      // draw normal\n      var n = vec.perp(e)\n      vec.norm(n,n)\n      var m = vec.lerp([x,y],[x+e[0],y+e[1]],.5)\n      this.ctx.moveTo(m[0],m[1])\n      this.ctx.lineTo(m[0]+n[0]*5,m[1]+n[1]*5)\n\n      // draw index\n      this.ctx.font = '3px courier'\n      var t = this.ctx.measureText(i).width;\n      this.ctx.fillText(i,m[0]-t/2,m[1])\n\n      // free the vectors\n      vec.free(n)\n      vec.free(m)\n\n      x += e[0]\n      y += e[1];\n    }\n    this.ctx.closePath();\n\n    // draw centroid\n    var c = poly.centroid(p)\n    this.ctx.fillRect(c[0]-1,c[1]-1,2,2)\n    vec.free(c)\n\n    return this;\n  },\n  line: function(S){\n    var a = S[0], b = S[1];\n    this.ctx.beginPath();\n    this.ctx.moveTo(a[0],a[1])\n    this.ctx.lineTo(b[0],b[1])\n    this.ctx.closePath();\n    return this;\n  },\n  rect: function(r){ // [t,r,b,l]\n    this.ctx.beginPath();\n    this.ctx.rect(r[0],r[3],r[1]-r[3],r[2]-r[0]);\n    this.ctx.closePath();\n    return this;\n  },\n  point: function(a,r){\n    r = r || 1\n    this.ctx.beginPath();\n    this.ctx.rect(a[0]-r,a[1]-r,r+r,r+r);\n    this.ctx.closePath();\n    return this;\n  },\n  stroke: function(strokeStyle,lineWidth){\n    if( lineWidth )\n      this.ctx.lineWidth = lineWidth;\n    if( strokeStyle )\n      this.ctx.strokeStyle = strokeStyle;\n    this.ctx.stroke()\n    return this;\n  },\n  fill: function(fillStyle){\n    if( fillStyle )\n      this.ctx.fillStyle = fillStyle;\n    this.ctx.fill()\n    return this;\n  }\n}//@ sourceURL=slam/lib/support/draw.js"
));
require.register("slam/lib/support/info.js", Function("exports, require, module",
"var $ = require('jquery')\n  , settings = require('../settings')\n  , inputs = require('../inputs')\n  , vec = require('geom').vec;\n\nvar p = ''; // previous string\nvar report = ''; // the PeerConnection#getStats results\nvar disabled = false;\nvar pre = $('#debug-info pre')[0];\nmodule.exports = function(ctx,enabled){\n\n  if( enabled ){\n    disabled = false;\n  } else if( enabled === false ){\n    disabled = true;\n  }\n\n  if( disabled ){\n    return;\n  }\n\n  var s = '';\n  s += context(ctx)\n  s += query(ctx.query)\n  s += world(ctx.game.world,ctx.sync&&ctx.sync.world) || '';\n  s += ctx.sync && world(ctx.sync.world,ctx.game.world) || '';\n  s += net(ctx.network) || '';\n  s += inp(inputs.info()) || '';\n  s += game(ctx.game.world) || '';\n  s += ctx.renderer.impl && ctx.renderer.impl.renderer && webgl(ctx.renderer.impl.renderer.info) || '';\n  s += ctx.network.remote && peercon(ctx.network.remote.connection) || '';\n  s += ctx.network.game && datchan(ctx.network.game.channel) || '';\n  s += ctx.network.game && netchan(ctx.network.game) || '';\n  s += report;\n\n  if( p !== s ){\n    // $('#debug-info pre').text(s);\n    pre.innerText = s;\n    p = s;\n  }\n}\n\nfunction context(ctx){\n  return 'Context\\n\\t' + [\n    'dev: '+ ctx.dev,\n    'pathname: '+ ctx.pathname,\n    'multiplayer: '+!!ctx.multiplayer,\n    'touch: '+!!ctx.touch,\n    'silent: '+!!ctx.silent,\n    'mobile: '+!!ctx.mobile,\n    'room: '+ctx.room,\n    'user: '+ctx.user\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction query(q){\n  return 'Query\\n\\t'\n    + Object.keys(q).map(function(k){\n      return k+': '+(q[k] || true)\n    }).join('\\n\\t') + '\\n\\n'\n}\n\nfunction game(w){\n  return 'Game\\n\\t' + [\n    'framerate: '+settings.data.framerate,\n    'speed: '+settings.data.unitSpeed,\n    'bullets: '+w.bullets.length,\n    'forces: '+w.forces.length,\n    'shields: '+w.shields.length,\n    'extras: '+w.extras.length,\n    'obstacles: '+w.obstacles.length,\n    'paddles: '+w.paddles.length,\n    'pucks: '+w.pucks.length\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction world(w,o){\n  return 'World\\n\\t' + [\n   'name: '+w.name,\n   'frame: '+w.frame+(o?' ('+(w.frame-o.frame)+')':''),\n   'multiplayer: '+w.multiplayer,\n   // 'code: '+w.code(), // NOTE: HEAVY\n   'seed: '+w.rand.state,\n   'state: '+w.state,\n   'score: '+w.players.a.score+' - '+w.players.b.score,\n   'wins: '+w.players.a.wins+' - '+w.players.b.wins,\n   'me: '+ (w.me && (w.me === w.players.a ? 'a' : 'b') + (w.me.hit !== -1 ? '(hit)':'')),\n   'opponent: '+ (w.opponent && (w.opponent === w.players.a ? 'a' : 'b') + (w.opponent.hit !== -1 ? '(hit)':'')),\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction netchan(nc){\n  return nc && 'NetChannel\\n\\t' + [\n    'seq: '+nc.seq,\n    'ack: '+nc.ack,\n    'resent: '+nc.resent,\n    'sent acks: '+nc.sentACKs,\n    'recv acks: '+nc.recvACKs,\n    'buffer: '+nc.buffer.length,\n    'buffer size: '+nc.bufferLength,\n    'encoded: '+(nc.encoded&&nc.encoded.byteLength)\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction peercon(pc){\n  // if( pc && typeof pc.getStats == 'function'){\n    // pc.getStats(function(s){ report = stats(s.result()) })\n  // }\n  return pc && 'PeerConnection\\n\\t' + [\n    'ice: '+pc.iceConnectionState,\n    'gathering: '+pc.iceGatheringState,\n    'signal: '+pc.signalingState\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction datchan(dc){\n  return dc && 'DataChannel\\n\\t' + [\n    'label: '+dc.label,\n    'reliable: '+dc.reliable,\n    'bufferedAmount: '+dc.bufferedAmount,\n    'ready: '+dc.readyState\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction inp(i){\n  return i && 'Inputs\\n\\t' + [\n    'ack: ' + i.ack,\n    'replaying: ' + i.replaying,\n    'recorded: ' + i.recorded,\n    'buffered: ' + i.buffered,\n    'length: ' + i.length,\n    'loc: ' + i.loc,\n    'net: ' + i.net\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction net(n){\n  return n && 'Network\\n\\t' + [\n    'connected: ' + n.connected,\n    'winner: ' + n.winner,\n    'ready: ' + n.ready,\n    'pathname: ' + n.pathname,\n    'challenge: ' + n.challenge,\n    'send rate: ' + settings.data.sendRate + 'hz',\n    'keep alive interval: ' + settings.data.keepAliveInterval+'ms'\n  ].join('\\n\\t') + '\\n\\n'\n}\n\nfunction stats(results){\n  var s = '';\n  for (var i = 0; i < results.length; ++i) {\n    var res = results[i];\n    s += 'Report ' + i + '\\n\\t';\n    if (res.local) {\n      s += \"Local\\n\";\n      s += dump(res.local,\"\\t\\t\");\n      s += '\\n\\t'\n    }\n    if (res.remote) {\n      s += \"Remote\\n\";\n      s += dump(res.remote,\"\\t\\t\");\n      s += '\\n\\t'\n    }\n  }\n  return s;\n}\n\nfunction webgl(i){\n\n    // memory: {\n    //   programs: 0,\n    //   geometries: 0,\n    //   textures: 0\n    // },\n\n    // render: {\n    //   calls: 0,\n    //   vertices: 0,\n    //   faces: 0,\n    //   points: 0\n    // }\n  var m = i.memory;\n  var r = i.render;\n  return i && 'WebGL\\n\\t' + [\n    'programs: ' + m.programs,\n    'geometries: ' + m.geometries,\n    'textures: ' + m.textures,\n    'render calls: ' + r.calls,\n    'vertices: ' + r.vertices,\n    'faces: ' + r.faces,\n    'points: ' + r.points\n  ].join('\\n\\t') + '\\n\\n'\n}\n\n// Dumping a stats variable as a string.\n// might be named toString?\nfunction dump(obj,pre) {\n  var s = pre+'Timestamp: ' + obj.timestamp;\n  if (obj.names) {\n    var names = obj.names();\n    for (var i = 0; i < names.length; ++i) {\n       s += '\\n'+pre;\n       s += names[i];\n       s += ':';\n       s += obj.stat(names[i]);\n    }\n  } else {\n    if (obj.stat('audioOutputLevel')) {\n      s += \"audioOutputLevel: \";\n      s += obj.stat('audioOutputLevel');\n      s += \"\\n\"+pre;\n    }\n  }\n  return s;\n}//@ sourceURL=slam/lib/support/info.js"
));
require.register("slam/lib/support/select-text.js", Function("exports, require, module",
"\n\nmodule.exports = function selectText(element){\n  var doc = document\n    , range, selection;\n  if (doc.body.createTextRange) {\n    range = document.body.createTextRange();\n    range.moveToElementText(element);\n    range.select();\n  } else if (window.getSelection) {\n    selection = window.getSelection();\n    range = document.createRange();\n    range.selectNodeContents(element);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n}//@ sourceURL=slam/lib/support/select-text.js"
));
require.register("slam/lib/support/see.js", Function("exports, require, module",
"var Emitter = require('emitter'+(typeof process == 'undefined' ? '' : '-component'))\n  , debug = require('debug')('see');\n\nmodule.exports = Emitter(see);\n\nvar stack = []    // current active states\n  , queue = []    // next targets\n  , target        // current target\n  , current = []  // current path\n  , states = {}   // available states\n  , lookup = []   // connects stack indexes/paths to states\n  , active        // the currently active state (esp. during async)\n  , bound = {}    // cache of bound functions\n  , context = {}\n  , running = false;\n\n// see(path,state)\n// see(path)\nfunction see(path,state){\n  // create - see(path,state)\n  if( arguments.length == 2 ){\n    if( typeof state != 'object' || !state ){\n      throw new Error('state must be an object');\n    }\n\n    path = normalize(path)\n    debug('create',path,[state])\n    if( !states[path] ){\n      states[path] = [state];\n    } else {\n      states[path].push(state);\n    }\n\n  // go - see(path)\n  } else {\n    debug('go',path)\n    see.go(path || '/')\n\n  }\n}\n\nsee.abort = function(){\n  debug('abort',queue,stack,active)\n\n  // clear queue\n  queue.length = 0\n\n  // cleanup active\n  if( active ){\n    see.emit('leave',context);\n    active.cleanup && active.cleanup(context);\n    active = null;\n  }\n\n  // start again on next see()\n  running = false;\n}\n\nsee.ctx = function(ctx){\n  context = ctx;\n}\n\nsee.go = function(path){\n  debug('go',path)\n\n  path = normalize(path);\n\n  if( !states[path] ){\n    throw new Error('path does not exist: '+path);\n  }\n\n  // add to queue\n  queue.push(path);\n\n  // go only if queue was empty\n  // (or we'll have parallel states running)\n  running || nextInQueue()\n}\n\n/**\n * Binds a see(path) call for an event listener.\n *\n * Only creates a single bound function per path\n * so that it can easily be removed from the event\n * listener again.\n *\n * Example:\n *\n *    emitter.on('go',see.bind('/to/here'))\n *    emitter.off('go',see.bind('/to/here'))\n *\n * @param  {String} path\n * @return {Function} bound to see.go(path)\n */\nsee.bind = function(path){\n  return bound[path] || (bound[path] = see.go.bind(see,path));\n}\n\nfunction nextInQueue(){\n  if( queue.length ){\n    running = true;\n    target = queue.shift().split('/');\n    go()\n\n  } else {\n    // done!\n    debug('done')\n    running = false;\n  }\n}\n\n// returns 1 / -1 / 0\n// depending on if it matches\nfunction diff(){\n  var t = str(target)\n    , c = str(current)\n    , l = stack[stack.length-1];\n\n  debug('diff',t,c,l)\n\n  // if already there\n  if( t === c ){\n    return 0;\n  }\n\n  // if shorter and they match so far\n  if( current.length < target.length && t.indexOf(c) === 0 ){\n    return +1;\n  }\n\n  // if it doesn't match what's in the stack\n  if( l && l.indexOf(c) !== 0 ){\n    return -2;\n  }\n\n  // if longer or they don't match so far\n  if( current.length > target.length || t.indexOf(c) !== 0 ){\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction go(){\n  switch(diff()){\n    case 1: // push\n      current.push(target[current.length])\n      updateContext(str(current))\n      return push()\n\n    case -1: // pop\n      updateContext(str(current))\n      current.pop()\n      return pop()\n\n    case -2: // pop without touching the stack\n      current.pop()\n      return go();\n\n    case 0: // done\n      see.emit(str(target))\n      return nextInQueue()\n  }\n}\n\nfunction pop(){\n  var pathname = stack.pop()\n    , nextpath = stack[stack.length-1]\n    , state = lookup.pop()\n    , next = nextpath === pathname ? pop : go;\n\n  // mark state as active\n  active = state;\n\n  // run\n  if( state && typeof state.leave == 'function' ){\n    // async\n    if( state.leave.length >= 2 ){\n      debug('pop async',context.pathname)\n      state.leave(context,function(err){\n        if( err instanceof Error ){\n          see.emit('error',err);\n        } else {\n          see.emit('leave',context);\n          state.cleanup && state.cleanup(context);\n          active = null;\n          next();\n        }\n      })\n\n    // sync\n    } else {\n      debug('pop sync',context.pathname)\n      state.leave(context);\n      see.emit('leave',context);\n      state.cleanup && state.cleanup(context);\n      active = null;\n      next();\n    }\n\n  // no leave\n  } else if(state){\n    debug('pop no leave',context.pathname)\n    see.emit('leave',context);\n    state.cleanup && state.cleanup(context);\n    active = null;\n    next();\n\n  // no more states\n  } else {\n    next();\n  }\n}\n\n\nfunction push(){\n  var state = nextMatchingState();\n\n  // mark state as active\n  active = state;\n\n  // run\n  if( state && typeof state.enter == 'function' ){\n    // async\n    if( state.enter.length >= 2 ){\n      debug('push async',context.pathname)\n      see.emit('enter',context);\n      state.enter(context,function(err){\n        active = null;\n        if( err instanceof Error ){\n          see.emit('error',err);\n        } else {\n          stack.push(context.pathname)\n          lookup.push(state)\n          push();\n        }\n      })\n\n    // sync\n    } else {\n      debug('push sync',context.pathname)\n      see.emit('enter',context);\n      state.enter(context);\n      active = null;\n      stack.push(context.pathname)\n      lookup.push(state)\n      push();\n    }\n\n  // no enter\n  } else if( state ){\n    debug('push no enter',context.pathname)\n    see.emit('enter',context);\n    active = null;\n    push()\n\n  // no more states\n  } else {\n    go()\n  }\n}\n\nfunction str(path){\n  return path.join('/') || '/';\n}\n\n// find a matching state\nfunction nextMatchingState(){\n  var path = str(current);\n  // console.log('nextMatchingState()',path,states[path])\n  if( states[path] ){\n    for(var i=0; i < states[path].length; i++){\n      if( !~lookup.indexOf(states[path][i]) ){\n        return states[path][i];\n      } else {\n        // console.log('already in stack?',states[path][i],stack)\n      }\n    }\n  }\n}\n\n\nvar supportsConfigurable = (function(){\n  var x={};\n  Object.defineProperty(x,'x',{value:123,configurable:true});\n  Object.defineProperty(x,'x',{value:456,configurable:true});\n  return x.x === 456;\n})()\n\nfunction updateContext(path){\n  var i = path.indexOf('?');\n  if( !supportsConfigurable ){\n    context.path = path\n    context.pathname = ~i ? path.slice(0, i) : path\n    context.querystring = ~i ? path.slice(i + 1) : ''\n  } else {\n    Object.defineProperties(context,{\n      path: {\n        value: path,\n        configurable: true\n      },\n      pathname: {\n        value: ~i ? path.slice(0, i) : path,\n        configurable: true\n      },\n      querystring: {\n        value: ~i ? path.slice(i + 1) : '',\n        configurable: true\n      }\n    })\n  }\n}\n\nfunction normalize(path){\n  // TODO (\"../\" \"./\" \"/\" \"//\")\n  return path || '';\n}//@ sourceURL=slam/lib/support/see.js"
));
require.register("slam/lib/support/mouse.js", Function("exports, require, module",
"var Emitter = require('emitter')\n  , debug = require('debug')('mouse')\n\nvar mx, my\n  , px, py\n  , cx, cy\n  , pt\n  , element = document;\n\nEmitter(exports)\n\nvar u; // = undefined!\n\nexports.tick = function(){\n  var t = Date.now()\n    , dt = t-pt;\n  if( (px !== u && py !== u) && (mx !== px || my !== py) )\n    exports.emit('move',mx-px,my-py,dt)\n  if( cx && cy )\n    exports.emit('click',cx,cy,dt)\n  px = mx; py = my; pt = t;\n  cx = cy = null;\n}\n\nexports.start = function(el){\n  debug('start',el)\n  if( el ) element = el;\n  element.addEventListener('touchstart',touchStart,true)\n  element.addEventListener('touchmove',touchMove,true)\n  element.addEventListener('mousemove',move,true)\n  element.addEventListener('click',click,true)\n}\n\nexports.stop = function(){\n  debug('stop')\n  mx = px;\n  my = py;\n  element.removeEventListener('touchstart',touchStart,true)\n  element.removeEventListener('touchmove',touchMove,true)\n  element.removeEventListener('mousemove',move,true)\n  element.removeEventListener('click',click,true)\n}\n\nfunction move(e){\n  mx = e.pageX; my = e.pageY;\n}\n\nfunction click(e){\n  cx = e.pageX; cy = e.pageY;\n}\n\nfunction touchStart(e){\n  var t = e.touches[0];\n  if( t ){\n    px = mx = t.pageX;\n    py = my = t.pageY;\n  }\n}\n\nfunction touchMove(e){\n  var t = e.touches[0];\n  if( t ){\n    mx = t.pageX;\n    my = t.pageY;\n    exports.tick();\n  }\n  e.preventDefault()\n}//@ sourceURL=slam/lib/support/mouse.js"
));
require.register("slam/lib/support/buffer.js", Function("exports, require, module",
"exports.Writer = Writer;\n\nexports.Reader = Reader;\n\n\nfunction Reader(buffer,offset){\n  // TypedArray\n  if( buffer.buffer ){\n    this.data = new DataView(buffer.buffer);\n    this.offset = offset || 0;\n    this.littleEndian = true;\n\n  // ArrayBuffer\n  } else {\n    this.data = new DataView(buffer);\n    this.offset = offset || 0;\n    this.littleEndian = true;\n  }\n}\nReader.prototype = {\n  getInt8: get('getInt8',1),\n  getUint8: get('getUint8',1),\n  getInt16: get('getInt16',2),\n  getUint16: get('getUint16',2),\n  getFloat32: get('getFloat32',4),\n  getFloat64: get('getFloat64',8),\n  readString: function(){\n    var length = this.getUint8();\n    var bytes = new Uint8Array(this.data.buffer,this.offset,length);\n    this.offset += 1+length;\n    return String.fromCharCode.apply(null, bytes);\n  }\n}\n\nfunction get(type,size){\n  return function(){\n    var v = this.data[type](this.offset,this.littleEndian);\n    this.offset += size;\n    return v;\n  }\n}\n\nfunction Writer(buffer,offset){\n  this.data = new DataView(buffer);\n  this.offset = offset || 0;\n  this.littleEndian = true;\n}\nWriter.prototype = {\n  setInt8: set('setInt8',1),\n  setUint8: set('setUint8',1),\n  setInt16: set('setInt16',2),\n  setUint16: set('setUint16',2),\n  setFloat32: set('setFloat32',4),\n  setFloat64: set('setFloat64',8),\n  writeString: function(str){\n    if( str.length > 255 ){\n      throw new Error('only 255 chars supported')\n    }\n    var bytes = getCharCodes(str);\n    this.setUint8(bytes.length);\n    new Uint8Array(this.data.buffer,this.offset,bytes.length).set(bytes);\n    this.offset += 1 + bytes.length;\n    return this;\n  }\n}\n\nfunction set(type,size){\n  return function(d){\n    this.data[type](this.offset,d,this.littleEndian)\n    this.offset += size;\n    return this;\n  }\n}\n\nfunction getCharCodes(s) {\n  var codes = new Array(s.length);\n  for(var i=0, l=s.length; i<l; i++) {\n    codes[i] = s.charCodeAt(i) & 0xff;\n  }\n  return codes;\n}\n//@ sourceURL=slam/lib/support/buffer.js"
));
require.register("slam/lib/support/pool.js", Function("exports, require, module",
"\nmodule.exports = Pool;\n\n\n/**\n * A very simple object pooling function.\n *\n * It will auto-expand if needed.\n *\n * Example:\n *\n *    var pool = require('pool');\n *\n *    function Obj(){}\n *    pool(Obj);\n *\n *    var o = Obj.alloc();\n *    // use `o`\n *    Obj.free(o);\n */\n\nfunction Pool(C,size){\n  var totalPooled = size || 1;\n  var freeList = [];\n  function expand(howMany){\n    console.warn('pool expand %s: %s',C.name,howMany)\n    for(var i=0; i < howMany; i++ ){\n      freeList[i] = new C;\n    }\n    totalPooled += howMany;\n  }\n  expand(totalPooled)\n  C.alloc = function(){\n    if( freeList.length < 1 ){\n      expand(totalPooled) // *= 2\n    }\n    var instance = freeList.pop();\n    instance.alloc && instance.alloc()\n    return instance;\n  }\n  C.free = function(instance){\n    instance.free && instance.free()\n    freeList.push(instance)\n  }\n}\n//@ sourceURL=slam/lib/support/pool.js"
));
require.register("slam/lib/support/tick.js", Function("exports, require, module",
"var debug = require('debug')('tick')\n  , actions = require('../actions')\n  , settings = require('../settings');\n\nmodule.exports = Tick;\n\nvar TIMEOUT = 0\n  , INTERVAL = 1;\n\nvar TIMEOUT_LEN = 6\n  , ADDED_LEN = 5;\nvar slice = [].slice;\n\nfunction Tick(){\n  this._timeouts = [];\n  this._added = [];\n  this._index = 1;\n}\n\nTick.prototype.nextFrame = function(action){\n  if( typeof actions[action] != 'function' )\n    return console.warn('invalid action \"%s\"',action)\n  var id = this._index++;\n  debug('nextFrame(%s) %s',action,id)\n  this._added.push(id,action,slice.call(arguments,1),0,TIMEOUT);\n  return id;\n}\n\nTick.prototype.setTimeout = function(action,ms){\n  if( typeof actions[action] != 'function' )\n    return console.warn('invalid action \"%s\"',action)\n  var id = this._index++;\n  var frames = msToFrames(ms);\n  debug('setTimeout(%s) %s (%s frames)',action,id,frames)\n  this._added.push(id,action,slice.call(arguments,2),frames,TIMEOUT);\n  return id;\n}\n\nTick.prototype.clearTimeout = function(id){\n  debug('clearTimeout %s',id)\n  return outOfRange(id,this._index)\n      || clearAdded(id,this._added,TIMEOUT)\n      || clearTimeouts(id,this._timeouts,TIMEOUT)\n}\n\nTick.prototype.setInterval = function(action,ms){\n  if( typeof actions[action] != 'function' )\n    return console.warn('invalid action \"%s\"',action)\n  var id = this._index++;\n  var frames = msToFrames(ms);\n  debug('setInterval(%s) %s (%s frames)',action,id,frames)\n  this._added.push(id,action,slice.call(arguments,2),frames,INTERVAL)\n  return id;\n}\n\nTick.prototype.clearInterval = function(id){\n  debug('clearInterval %s',id)\n  return outOfRange(id,this._index)\n      || clearAdded(id,this._added,INTERVAL)\n      || clearTimeouts(id,this._timeouts,INTERVAL)\n}\n\nTick.prototype.update = function(world){\n  checkForAdded(world.frame,this._added,this._timeouts)\n  checkForActive(world,this._added,this._timeouts)\n}\n\nTick.prototype.reset = function(){\n  this._timeouts.length = 0;\n  this._added.length = 0;\n  this._index = 1;\n}\n\nfunction checkForAdded(frame,added,timeouts){\n  while(added.length){\n    var id = added.shift()\n      , action = added.shift()\n      , args = added.shift()\n      , frames = added.shift()\n      , type = added.shift()\n      , when = frame + frames;\n    timeouts.push(when,id,frames,action,args,type);\n  }\n}\n\nfunction checkForActive(world,added,timeouts){\n  var frame = world.frame;\n  // loop from back for easy splice\n  for(var i=timeouts.length-TIMEOUT_LEN; i>=0; i-=TIMEOUT_LEN) {\n    var when = timeouts[i];\n\n    if( when === frame ) {\n      var id = timeouts[i+1]\n        , frames = timeouts[i+2]\n        , action = timeouts[i+3]\n        , args = timeouts[i+4]\n        , type = timeouts[i+5];\n\n      // remove from list\n      timeouts.splice(i,TIMEOUT_LEN);\n\n      // re-add when interval\n      if( type === INTERVAL ){\n        timeouts.push(frame+frames,id,frames,action,args,type);\n      }\n\n      // call\n      actions[action].apply(actions,[world].concat(args));\n    }\n  }\n}\n\nfunction outOfRange(id,index){\n  return typeof id == 'number'\n      && id >= index;\n      // TODO can we check if id is lower than the lowest \"active\"?\n}\n\nfunction clearAdded(id,added,type){\n  for(var i=added.length; i>=0; i -= ADDED_LEN){\n    if( added[i] === id && added[i+4] === type ){\n      added.splice(i,ADDED_LEN);\n      return true;\n    }\n  }\n}\n\nfunction clearTimeouts(id,timeouts,type){\n  for(var i=timeouts.length-TIMEOUT_LEN; i>=0; i -= TIMEOUT_LEN){\n    if( timeouts[i+1] === id && timeouts[i+5] === type ){\n      timeouts.splice(i,TIMEOUT_LEN);\n      return true;\n    }\n  }\n}\n\nfunction msToFrames(ms){\n  // 60/1000 = 0.06\n  // 100ms * 0.06 = 6 frames\n  return Math.round(ms*settings.data.framerate/1000) || 1;\n}//@ sourceURL=slam/lib/support/tick.js"
));
require.register("slam/lib/support/rand.js", Function("exports, require, module",
"\nmodule.exports = RNG;\n\n// http://stackoverflow.com/a/424445/80582\nfunction RNG(seed) {\n  this.state = seed ? seed : Math.floor(Math.random() * (this.m-1));\n}\n\n// LCG using GCC's constants\nRNG.prototype = {\n  m: 0x100000000, // 2**32;\n  a: 1103515245,\n  c: 12345\n}\n\n/**\n *  Generate a 32bit integer.\n */\nRNG.prototype.integer = function() {\n  this.state = (this.a * this.state + this.c) % this.m;\n  return this.state;\n}\n\n/**\n *  Generate a float [0,1]\n */\nRNG.prototype.random =\nRNG.prototype.float = function() {\n  return this.integer() / (this.m - 1);\n}\n\n/**\n * Generate a number within `start` (incl) and\n * `end` (excl).\n */\nRNG.prototype.range = function(start, end) {\n  return start + Math.floor((this.integer() / this.m) * (end - start));\n}\n\n/**\n * Pick a random item in `array`.\n */\nRNG.prototype.choice = function(array) {\n  return array[this.range(0, array.length)];\n}//@ sourceURL=slam/lib/support/rand.js"
));
require.register("slam/lib/support/time-sync.js", Function("exports, require, module",
"var debug = require('debug')('time-sync')\n  , Emitter = require('emitter')\n  , latency = require('latency')\n  , now = require('now');\n\n/**\n  This lib assumes that a PeerConnection has been\n  set up between two clients.\n\n  It works by using `DataChannel#send` to send a series\n  of sync requests (of which the local time has been stored)\n  and listening for sync replies and then calculates a\n  latency based on median-stddev.\n\n  Based on http://www.gamedev.net/page/resources/_/technical/multiplayer-and-network-programming/clock-synchronization-of-client-programs-r2493\n\n    // uses DataChannel to synchronize the time\n    // of 2 clients, very useful for a realtime\n    // multiplayer game like \"chrome pong\"\n    var TimeSync = require('time-sync')\n      , sync = new TimeSync(dataChannel);\n\n    // will be called for both host and guest when\n    // the total latency has been calculated\n    sync.on('done',function(){\n      // now set game clock to 0 + this.latency\n    }).start()\n*/\n\nmodule.exports = TimeSync;\n\nfunction TimeSync(channel){\n  if( !(this instanceof TimeSync) )\n    return new TimeSync(channel);\n  this.channel = channel;\n  this.times = [];\n  this.received = 0;\n  this.index = 0;\n  this.wanted = 40;\n  this.requestTimes = {};\n  this.timeout = 10000;\n  this.interval = 80;\n}\n\nEmitter(TimeSync.prototype);\n\nTimeSync.prototype.onmessage = function(msg){\n  // wrap in typed array\n  msg = new Uint8Array(msg);\n\n  // check for REQUEST\n  if( is(REQ,msg) ){\n    var index = parse(msg)\n    debug('got REQUEST',index)\n    this.channel.send(write(REP,index))\n    this.emit('request',index)\n    return true;\n\n  // check for REPLY\n  }else if( is(REP,msg) ){\n    var index = parse(msg)\n\n    // we good, it's one of ours\n    var requestTime = this.requestTimes[index]\n    if( this.requesting && requestTime ){\n      var replyTime = now()\n      debug('got REPLY %sms',replyTime-requestTime,index)\n      this.received++;\n      this.times[index % this.wanted] = (replyTime-requestTime)/2;\n      delete this.requestTimes[index]\n      this.emit('reply',index)\n    }\n    return true;\n\n  // check for DONE\n  } else if( is(DON,msg) ){\n    if( !this.requesting ){\n      this.latency = parse(msg)\n      debug('got DONE',this.latency)\n      this.emit('done',this.latency,false)\n    } else {\n      console.warn('unexpected DONE')\n    }\n    return true;\n\n  }\n  // not a TimeSync message!\n  return false;\n}\n\nTimeSync.prototype.start = function(){\n  debug('start');\n\n  if( this.requesting ){\n    throw new Error('already started');\n  }\n\n  if( !this.channel ){\n    throw new Error('missing data channel');\n  }\n\n  this.times.length = 0 // clear array\n  this.index = Math.round(Math.random()*10000)\n  this.update(this.wanted)\n}\n\nTimeSync.prototype.update = function(n){\n  debug('update',n)\n  this.requesting = true\n  // send a request every 30ms until we have received\n  // enough replies.\n  this.received = 0;\n  this._interval = setInterval(function(){\n    // if we have enough request/replies we're done\n    if( this.requesting && this.received >= n ){\n      this.done()\n\n    // or we keep sending requests\n    } else if( this.requesting ){\n      this.request()\n\n    // or stop it\n    } else {\n      this.stop()\n    }\n  }.bind(this),this.interval)\n\n  this._timeout = setTimeout(function(){\n    debug('timed out')\n    this.stop()\n    this.emit('timeout')\n  }.bind(this),this.timeout)\n}\n\nTimeSync.prototype.request = function(){\n  var requestIndex = this.index\n  this.requestTimes[requestIndex] = now()\n  this.channel.send(write(REQ,requestIndex))\n  debug('sent REQUEST',requestIndex,this.times.length == 0 ? 'initial' : '')\n  this.index++\n}\n\nTimeSync.prototype.stop = function(){\n  // cancel the rest of the requests\n  clearInterval(this._interval)\n  clearTimeout(this._timeout)\n  this.requesting = false\n}\n\nTimeSync.prototype.done = function(){\n  this.stop()\n  this.latency = Math.round(calculateLatency(this.times)) // rounded because of 16bit int\n  this.channel.send(write(DON,this.latency))\n  debug('sent DONE',this.latency)\n  this.emit('done',this.latency,true)\n}\n\n// calculate the latency from an array of \"midway-latencies\"\nfunction calculateLatency(times){\n  return latency(times);\n}\n\nvar PREFIX = 'TS';\n\n// REQ is a prebuilt buffer with:\n//  - a time-sync prefix (TS)\n//  - the REQUEST type (0)\n//  - and room for a 16bit index\nvar REQ = new Uint8Array([PREFIX.charCodeAt(0),PREFIX.charCodeAt(1),0,0,0])\n\n// REP is a prebuilt buffer with:\n//  - a time-sync prefix (TS)\n//  - the REPLY type (1)\n//  - and room for a 16bit index\nvar REP = new Uint8Array([PREFIX.charCodeAt(0),PREFIX.charCodeAt(1),1,0,0])\n\n// DON is a prebuilt buffer with:\n//  - a time-sync prefix (TS)\n//  - the DONE type (2)\n//  - and room for a 16bit latency\nvar DON = new Uint8Array([PREFIX.charCodeAt(0),PREFIX.charCodeAt(1),2,0,0])\n\nfunction write(buf,index){\n  buf[3] = (index >> 8) & 0xff\n  buf[4] = (index >> 0) & 0xff\n  return buf;\n}\nfunction parse(buf){\n  return (buf[3] << 8) + buf[4];\n}\nfunction is(buf,msg){\n  return buf.byteLength === msg.byteLength\n      && buf[0] === msg[0]\n      && buf[1] === msg[1]\n      && buf[2] === msg[2];\n}//@ sourceURL=slam/lib/support/time-sync.js"
));
require.register("slam/lib/support/hash-code.js", Function("exports, require, module",
"\nmodule.exports = function hashCode(object) {\n  var hashs = [];\n  if (typeof(object) == \"number\") {\n    hashs.push(eps(object));\n\n  } else if( typeof object !== 'object' || object === null ){\n    hashs.push(object);\n\n  } else if( typeof object.hashCode == 'function' ){\n    hashs.push(object.hashCode());\n\n  } else {\n    for (var key in object) {\n      var val = object[key];\n\n      // recurse through objects (and arrays)\n      if (typeof(val) == \"object\") {\n        val = hashCode(val);\n      }\n\n      // round off number to avoid float rounding errors\n      if (typeof(val) == \"number\") {\n        val = eps(val);\n      }\n\n      // add to hash\n      hashs.push(key + val + key.length + String(val).length);\n    }\n  }\n\n  // sort by keys\n  hashs.sort();\n\n  return djb2(hashs.join('|'));\n}\n\nfunction djb2(str) {\n  var hash = 5381;\n  for (var i = 0; i < str.length; i++) {\n    var ch = str.charCodeAt(i);\n    hash = ((hash << 5) + hash) + ch; /* hash * 33 + c */\n  }\n  return hash;\n}\n\n// var EPS = 1e-1;\n// function eps(x){ return Math.round(Math.round(x/EPS) * EPS) }\n\n// var EPS_1 = 1e-1;\n// var EPS_2 = 1e-2;\n// function eps(x){\n//   x = Math.round(Math.round(x/EPS_1)*EPS_1);\n//   return Math.round(Math.round(x/EPS_2)*EPS_2);\n// }\n\nvar EPS = Math.pow(2,-512);\nfunction eps(x){\n  return Math.round(x*EPS)/EPS;\n}\n\nfunction toString(s){\n  return Object.prototype.toString.call(null,s);\n}//@ sourceURL=slam/lib/support/hash-code.js"
));
require.register("slam/lib/support/exclude.js", Function("exports, require, module",
"\nmodule.exports = exclude;\n\n// temporary excludes properties in `obj` defined in `excluded`\n// calls fn with the obj and then adds the properties back after\n// the callback.\nfunction exclude(obj,excluded,fn){\n  var map = {}\n  excluded.forEach(function(prop){\n    var props = prop.split('.');\n    var tmp = obj;\n    for (var i = 0; i < props.length; ++i) {\n      var name = props[i];\n      if( i == props.length-1 ){\n        map[prop] = tmp[name]\n        delete tmp[name]\n      } else {\n        tmp = tmp[name];\n      }\n    }\n  })\n  fn(obj)\n  Object.keys(map).forEach(function(prop){\n    var props = prop.split('.');\n    var tmp = obj;\n    for (var i = 0; i < props.length; ++i) {\n      var name = props[i];\n      if( i == props.length-1 ){\n        tmp[name] = map[prop];\n      } else {\n        tmp = tmp[name];\n      }\n    }\n  })\n}//@ sourceURL=slam/lib/support/exclude.js"
));
require.register("slam/lib/support/estimate-slow-down.js", Function("exports, require, module",
"var settings = require('../settings')\n\n/**\n * Calculates a multiplier how much to slow\n * down to adjust the arrival for latency.\n *\n *\n *   // use\n *   var paddle = world.paddles.get(world.opponent.paddle);\n *   var puck = world.pucks.values[0];\n *   var time = 1000/settings.data.sendRate + ctx.latency;\n *   var m = estimateSlowDown(paddle.current[1] - puck.current[1],puck.velocity[1],t)\n *   // returns null if the puck is going in the wrong direction\n *\n *   if( m != null ){\n *     // based on the sync puck or we'll have a squared decceleration.\n *     var spuck = ctx.sync.world.pucks.get(puck.index)\n *     vec.smul(spuck.velocity,m,puck.velocity);\n *     vec.sub(puck.current,puck.velocity,puck.previous)\n *   } else {\n *     replay = true;\n *   }\n *\n *\n * @param  {Number} d The distance to travel (ex. b[1]-a[1])\n * @param  {Number} v The current velocity (ex. a[1])\n * @param  {Number} t The time to adjust for (ex. ctx.latency)\n * @return {Number} A number to multiply the current velocity by. Or null if going in the opposite direction.\n */\nmodule.exports = function estimateSlowDown(d,v,t){\n  // no velocity means \"keep it up!\"\n  if( !v || !d || !t ){\n    return 1;\n  }\n\n  // check the direction first\n  if( !sameSign(d,v) ){\n    return null;\n  }\n\n  // the time it can take the puck to get to the paddle\n  var t2 = d/v * settings.data.timestep;\n\n  // the time we want it to take the puck to reach the paddle\n  var t3 = t2 + t;\n\n  // return a multiplier\n  return t2/t3;\n\n  // the new velocity required\n  var v2 = t2/t3*v;\n}\n\nfunction sameSign(x, y){\n  return (x >= 0) ^ (y < 0);\n}\n//@ sourceURL=slam/lib/support/estimate-slow-down.js"
));
require.register("slam/lib/support/improved-noise.js", Function("exports, require, module",
"// http://mrl.nyu.edu/~perlin/noise/\n\nmodule.exports = new ImprovedNoise();\n\nfunction ImprovedNoise() {\n\n\tthis.p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,\n\t\t 23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,\n\t\t 174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,\n\t\t 133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,\n\t\t 89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,\n\t\t 202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,\n\t\t 248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,\n\t\t 178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,\n\t\t 14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,\n\t\t 93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n\n\tfor (var i=0; i < 256 ; i++) {\n\n\t\tthis.p[256+i] = this.p[i];\n\n\t}\n\n}\n\nImprovedNoise.prototype.noise =  function (x, y, z) {\n\n\tvar floorX = ~~x, floorY = ~~y, floorZ = ~~z;\n\n\tvar X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;\n\n\tx -= floorX;\n\ty -= floorY;\n\tz -= floorZ;\n\n\tvar xMinus1 = x -1, yMinus1 = y - 1, zMinus1 = z - 1;\n\n\tvar u = fade(x), v = fade(y), w = fade(z);\n\n\tvar A = this.p[X]+Y, AA = this.p[A]+Z, AB = this.p[A+1]+Z, B = this.p[X+1]+Y, BA = this.p[B]+Z, BB = this.p[B+1]+Z;\n\n\treturn lerp(w, lerp(v, lerp(u, grad(this.p[AA], x, y, z), \n\t\t\t\t\tgrad(this.p[BA], xMinus1, y, z)),\n\t\t\t\tlerp(u, grad(this.p[AB], x, yMinus1, z),\n\t\t\t\t\tgrad(this.p[BB], xMinus1, yMinus1, z))),\n\t\t\tlerp(v, lerp(u, grad(this.p[AA+1], x, y, zMinus1),\n\t\t\t\t\tgrad(this.p[BA+1], xMinus1, y, z-1)),\n\t\t\t\tlerp(u, grad(this.p[AB+1], x, yMinus1, zMinus1),\n\t\t\t\t\tgrad(this.p[BB+1], xMinus1, yMinus1, zMinus1))));\n\n}\n\nfunction fade(t) {\n\n\t\treturn t * t * t * (t * (t * 6 - 15) + 10);\n\n\t}\n\n\tfunction lerp(t, a, b) {\n\n\t\treturn a + t * (b - a);\n\n\t}\n\n\tfunction grad(hash, x, y, z) {\n\n\t\tvar h = hash & 15;\n\t\tvar u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n\t\treturn ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n\n\t}\n//@ sourceURL=slam/lib/support/improved-noise.js"
));
require.register("slam/lib/states/index.js", Function("exports, require, module",
"\nexports.IO = require('./io');\nexports.Setup = require('./setup');\nexports.Mobile = require('./mobile');\nexports.Loading = require('./loading');\nexports.Error = require('./error');\nexports.MainMenu = require('./main-menu');\nexports.Friend = require('./friend');\nexports.Webcam = require('./webcam');\nexports.Prompt = require('./prompt');\nexports.Game = require('./game');\nexports.Game.Input = require('./game/input');\nexports.Game.Verify = require('./game/verify');\nexports.Game.Multiplayer = require('./game/multiplayer');\n\n\n//@ sourceURL=slam/lib/states/index.js"
));
require.register("slam/lib/states/error.js", Function("exports, require, module",
"var see = require('../support/see')\n  , inputs = require('mousetrap')\n  , $ = require('jquery');\n\nexports.enter = function(){\n\n}\n\nexports.leave = function(){\n\n}\n\nexports.DataChannels = {\n  enter: function(ctx){\n    var btn = $('.main-menu',ctx.el).on('click', function(e){\n      see('/main-menu')\n      e.preventDefault()\n    })\n    inputs.bind('space',function(){\n      btn.click();\n    })\n  },\n  leave: function(ctx){\n    $('.mainmenu',ctx.el).off('click')\n    inputs.unbind('space')\n  }\n}\nexports.ConnectionError = {\n  enter: function(ctx){\n    inputs.bind('space',function(){\n      $('a.button',ctx.el).click();\n    })\n  },\n  leave: function(ctx){\n    inputs.unbind('space')\n  }\n}\nexports.FullRoom = {\n  enter: function(ctx){\n    var btn = $('.main-menu',ctx.el).on('click', function(){\n      see('/main-menu')\n    })\n    inputs.bind('space',function(){\n      btn.click();\n    })\n  },\n  leave: function(ctx){\n    $('.mainmenu',ctx.el).off('click')\n    inputs.unbind('space')\n  }\n}\n\nexports.Browser = {\n  enter: function(ctx){\n    var btn = $('.button',ctx.el).on('click', function(){\n    })\n  },\n  leave: function(ctx){\n    $('.button',ctx.el).off('click')\n  }\n}\n\nexports.Lonely = {\n  enter: function(ctx){\n    var btn = $('.button',ctx.el).on('click', function(){\n    })\n  },\n  leave: function(ctx){\n    $('.button',ctx.el).off('click')\n  }\n}\n\n//@ sourceURL=slam/lib/states/error.js"
));
require.register("slam/lib/states/io.js", Function("exports, require, module",
"var $ = require('jquery');\n\nexports.enter = function(ctx){\n  if( ctx.room !== 'io'){\n    return;\n  }\n\n  // overrides when using /io\n  ctx.query.autonav = true;\n  ctx.query.quality = 'mobile';\n  ctx.query.ns = 'single';\n  ctx.query.level = '1';\n  ctx.query.extras = 'x';\n\n  // temp\n  if( ctx.dev ){\n    ctx.silent = true;\n    ctx.query.benchmark = true;\n    ctx.query.play = true;\n    // ctx.query.renderer = 'none';\n  }\n\n  // hide some overlying elements\n  // (hidden #footer will also resize the #game to fit)\n  $('#canv-2d,#canv-db,#canv-css,#footer,#settingsGUIContainer').hide()\n}//@ sourceURL=slam/lib/states/io.js"
));
require.register("slam/lib/states/setup.js", Function("exports, require, module",
"/* global _gaq: true, Stats: true */\n\nvar debug = require('debug')('states:setup')\n  , keys = require('mousetrap')\n  , Game = require('../game')\n  , Renderer = require('../renderer')\n  , Renderer2D = require('../renderer-2d')\n  , Network = require('../network')\n  , settings = require('../settings')\n  , localization = require('../localization')\n  , see = require('../support/see')\n  , info = require('../support/info')\n  , selectRange = require('../support/select-text')\n  , cssEvent = require('css-emitter')\n  , inputs = require('../inputs')\n  , actions = require('../actions')\n  , cookie = require('cookie')\n  , sound = require('../sound')\n  , $ = require('jquery')\n  , dmaf = require('../dmaf.min');\n\n\nvar Setup = exports;\n\n\nSetup.enter = function(ctx){\n  ctx.query.dev = ctx.query.dev ? true : false;\n\n  // set before 3d is created\n  if( ctx.query.quality ){\n\n    if( ctx.query.quality === settings.QUALITY_LOW || ctx.query.quality === settings.QUALITY_HIGH || ctx.query.quality === settings.QUALITY_MOBILE) {\n      settings.data.quality = ctx.query.quality;\n    }\n\n    if(settings.data.quality == settings.QUALITY_LOW || window.devicePixelRatio > 1){\n      settings.data.antialias = false;\n    }\n\n    if(ctx.query.quality === settings.QUALITY_BEST) {\n      settings.data.antialias = true;\n    }\n\n    if(ctx.query.quality === settings.QUALITY_MOBILE) {\n      settings.data.cameraOverlay = false;\n    }\n  }\n\n  ctx.renderer = new Renderer()\n  ctx.game = new Game('game',ctx.renderer);\n\n  if( ctx.query.renderer == '2d' ){\n    ctx.renderer.set(new Renderer2D(document.getElementById('canv-2d')))\n  }\n\n  // start game paused\n  if( ctx.query.paused ){\n    console.warn('started game in paused mode. step forward with \".\".')\n    ctx.game.pause();\n\n    // manually update\n    keys.bind('.',function(){\n      ctx.game.update();\n      ctx.game.emit('render',ctx.game.world,0)\n    })\n  }\n\n  // wrap loop with stats js\n  if( typeof Stats == 'function' ){\n    var stats = new Stats();\n    $(stats.domElement).css({\n      'letter-spacing':'normal',\n      'position': 'absolute',\n      'z-index': 999\n    })\n    $(stats.domElement).insertBefore('#benchmarks');\n    ctx.game.on('enter frame',function(){stats.begin()})\n    ctx.game.on('leave frame',function(){stats.end()})\n  }\n\n  // check for touch\n  ctx.touch = 'ontouchstart' in window || navigator.msMaxTouchPoints;\n  if( ctx.touch ){\n    $('body').addClass('touch');\n    settings.data.mouseSensitivity = 0.7/10;\n  }\n\n  // optionally disable sounds entirely\n  ctx.silent = ctx.silent || ctx.query.silent;\n  if( !ctx.silent ) {\n    ctx.silent = !(window.webkitAudioContext || window.AudioContext);\n  }\n\n  // no need to show sound button when silent\n  ctx.silent && $('.sound').hide();\n  sound(cookie('sound'),true); // true = prevent GA tracking first time\n\n  // enable dmaf logs\n  dmaf.log = ctx.query.dmaf;\n\n  stateHack();\n  socialPopup();\n  trackExternalLinks();\n\n  // networking\n  setupNetwork(ctx);\n\n  // key bindings\n  setupBindings(ctx);\n\n  // init localization\n  localize(ctx.acceptLanguage)\n\n  // toggle debug info\n  //info(ctx,ctx.dev || ctx.query.dev)\n  info(ctx, ctx.query.dev)\n  $('#debug-info').toggle(ctx.query.dev)\n  //$('#debug-info').toggle(ctx.dev || ctx.query.dev)\n}\n\nSetup.leave = function(){\n  throw new Error('this should never happen...')\n}\n\nfunction trackExternalLinks(){\n  $('#footer [target=_blank]').on('click', function(){\n    _gaq.push(['_trackEvent', 'outbound links', $(this).attr('href')]);\n  })\n  $('header').addClass('delay');\n}\n\n\nfunction localize(acceptLanguage){\n  localization.init(acceptLanguage);\n  localization.on('load', function() {\n    var langs = localization.availLanguages();\n    if (langs.length < 2) { // only EN\n      $('#localizationSwitch').closest('li').hide();\n    } else {\n      $('#localizationSwitch').html(langs.join('/')).click(function(e) {\n        e.preventDefault();\n        localization.nextLanguage();\n        return false;\n      });\n    }\n  });\n}\n\nfunction stateHack(){\n  $('.state.inactive').hide().css('visibility', 'visible')\n  //Hack to putting out the state-layers after transitions to prevent recalculation\n  $('.state .animate').add($('.state.animate')).each(function(){\n    cssEvent(this).on('end',afterTransition)\n  })\n  function afterTransition(evt){\n    var stateElem = $(evt.target).hasClass('state') ? $(evt.target) : $(evt.target).closest('.state');\n    if( !stateElem.hasClass('active') ){\n      stateElem.hide();\n    }\n  }\n}\n\nfunction socialPopup(){\n\n  $('.social a').on('mouseover', function(){\n    dmaf.tell('share_over');\n  })\n\n  $('.social a').on('click', function(){\n    dmaf.tell('share_click');\n    alert('Please do not spread this link.');\n    return false;\n    var href = $(this).attr('href');\n    _gaq.push(['_trackEvent', 'share', href]);\n    window.open(href, 'Cube Slam', 'toolbar=0,status=0,width=626,height=480')\n    return false;\n  })\n}\n\nfunction setupNetwork(ctx){\n  ctx.network = new Network(ctx)\n\n  if( !ctx.mobile && ctx.network.available ){\n    // update debug info\n    ctx.game.on('post update',function(){ info(ctx) })\n\n    see.on('enter',function(ctx,state){\n      ctx.network.emit('state',ctx.pathname)\n    })\n\n    // make a sound when a friend connects\n    ctx.network.on('connected',function(){\n      dmaf.tell('friend_join');\n    })\n\n    // update the inputs latency\n    ctx.network.on('change latency',function(latency){\n      var quality = latency > 150 ? 'bad'\n                  : latency > 50 ? 'ok'\n                  : 'good';\n\n      $('#latencyMeter span').text(latency).removeClass('ok good bad').addClass(quality)\n        .closest('li').removeClass('inactive')\n\n      if(quality != 'good') {\n        var notification = $('#latency-notification:not(.inactive)').addClass('active');\n        if(notification.length > 0){\n          _gaq.push(['_trackEvent', '2p', 'latency',undefined,parseInt(latency,10)]);\n          notification.addClass('inactive').fadeOut(0)\n            .fadeIn(200).delay(12000).fadeOut(200);\n        }\n      }\n\n      _gaq.push(['_trackEvent', '2p', 'latency',undefined,parseInt(latency,10)]);\n    })\n\n    // add remote camera\n    ctx.network.on('addstream',function(e){\n      var remoteVideo = document.getElementById('remoteInput');\n      remoteVideo.src = webkitURL.createObjectURL(e.stream);\n      ctx.renderer.triggerEvent('remoteVideoAvailable', {visible:true});\n    })\n    ctx.network.on('removestream',function(e){\n      ctx.renderer.triggerEvent('remoteVideoAvailable', {visible:false});\n      document.getElementById('remoteInput').src = '';\n    })\n    ctx.network.on('full', function(){\n      $('body').addClass('error room-full')\n    })\n\n    // a little counter so we can break after a certain amount\n    // or errors.\n    var messageTooLong = 0;\n    ctx.network.on('error', function(e){\n      console.error(e.stack)\n\n      var eventAction = 'Generic connection error';\n\n      switch(e.code){\n        case 1168: // message too long (1168 = max length)\n          eventAction = 'Message too long'\n          if( ++messageTooLong < 10 ){\n            // ignoring the error 10 times\n            return\n          }\n          // reset for after a reconnect\n          messageTooLong = 0;\n          break;\n\n        case 408:  // connection timed out\n          eventAction = 'Connection timeout'\n          break;\n      }\n\n      _gaq.push(['_trackEvent', 'error', eventAction]);\n      ctx.network.close()\n\n      // abort unless loading\n      if( ctx.pathname != '/loading' ){\n        see.abort();\n      }\n      see('/error/connection');\n    })\n\n    ctx.network.on('connected',function(){\n      if( ctx.pathname != '/loading' ){\n        see.abort()\n      }\n\n      dmaf.tell('microphone_on');\n      sound('off', true, true)\n      //show and hide notification flag\n      $('#multiplayer-notification').fadeOut(0)\n        .fadeIn(200).delay(8000).fadeOut(200);\n\n      if(this.winner){\n        see('/friend/arrived');\n      } else {\n        see('/friend/waiting');\n      }\n    })\n    ctx.network.on('disconnected', function(){\n      if( ctx.pathname != '/loading' ){\n        see.abort()\n      }\n      dmaf.tell('microphone_off');\n      sound(cookie('sound'))\n      see('/friend/left')\n      // make sure we reactivate the webcam\n      ctx.webcam = false;\n    })\n\n    ctx.network.setupRemote({\n      dataChannels: ['game'],\n      bufferCandidates: ctx.query.buffer || ctx.dev,\n      signal: ctx.query.signal,\n\n      // options for WebSocketSignal\n      url: 'ws://nj.publicclass.co:8081/'+ctx.room,\n\n      // options for AppChannelSignal\n      token: ctx.token,\n      user: ctx.user,\n      room: ctx.room\n    })\n\n  }\n}\n\nfunction setupBindings(ctx){\n  // input bindings\n  keys.bind('o',function(){\n    $('#settingsGUIContainer,#debug-info').toggle();\n    info(ctx,$('#debug-info').is(':visible'))\n  })\n  keys.bind('p',function(){ actions.createPuckCenter(ctx.game.world) })\n  keys.bind('e',function(){ ctx.renderer.triggerEvent('explode') })\n  keys.bind('h',function(){ ctx.renderer.triggerEvent('heal') })\n  keys.bind('m',function(){\n    settings.data.debugMirror = !settings.data.debugMirror\n    ctx.renderer.triggerEvent('mirrorEffect',{active:settings.data.debugMirror})\n  })\n\n  //camera\n  for (var i = 1; i < 6; i++) {\n    keys.bind(String(i),function(index){\n      settings.data.cameraType = index-1;\n      settings.emit('cameraTypeChanged')\n    }.bind(null,i))\n  }\n  keys.bind('c',function(){\n    ctx.renderer.triggerEvent('trace-camera')\n  })\n\n  var r2d = new Renderer2D(document.getElementById('canv-2d'))\n    , rXd;\n  keys.bind('0',function(){\n    // toggle between the 2d renderer and the current one\n    if( ctx.renderer.impl !== r2d ){\n      rXd = ctx.renderer.impl;\n      ctx.renderer.set(r2d)\n      $(rXd.canvas || rXd.element).hide();\n      $(r2d.canvas).show()\n    } else if( rXd ){\n      ctx.renderer.set(rXd);\n      $(r2d.canvas).hide();\n      $(rXd.canvas || rXd.element).show();\n    }\n  })\n}\n//@ sourceURL=slam/lib/states/setup.js"
));
require.register("slam/lib/states/mobile.js", Function("exports, require, module",
"var debug = require('debug')('mobile')\n  , settings = require('../settings')\n  , keys = require('mousetrap')\n  , see = require('../support/see')\n  , mouse = require('../support/mouse')\n  , $ = require('jquery');\n\nvar Mobile = exports;\n\nMobile.enter = function(ctx){\n  if( !ctx.query.mobile && hasWebGL() ){\n    return;\n  }\n  ctx.mobile = true;\n  ctx.query.renderer = ctx.query.renderer || 'css';\n  $('html').addClass('mobile')\n\n  var img = $('.mobile section.main-menu img').data($(document).width() > 800 ? 'src-tablet' : 'src-mobile');\n  $('header.main-menu').css({backgroundImage: 'url('+img+')'});\n\n  if(!has3d()) {\n    $('header.main-menu').removeClass('inactive').addClass('active');\n    $('header.main-menu .nav').hide();\n    $('.loading').hide();\n    see.abort();\n    see('/error/browser');\n    return;\n  }\n\n  if( $('body').hasClass('room-lonely') ) {\n    see.abort();\n    $('header.main-menu').addClass('active');\n    $('header.main-menu .nav').hide();\n    $('#footer').hide();\n    $('.loading').remove();\n    see('/error/lonelyroom');\n    return;\n  }\n\n\n  //iPhone hack to get rid of omnibar.\n  // we need at least 64px extra height and scrollto 0 to remove the bar.\n  var iphoneOmnibar = 64;\n  // $('#footer').css('paddingBottom', iphoneOmnibar);\n  window.scrollTo(0,1)\n  see.on('enter',function(ctx,state){\n    if(ctx.pathname.indexOf('/game/')>-1) {\n      // window.scrollTo(0,1);\n    }\n  })\n  window.onorientationchange = function() {\n    window.scrollTo(0,0)\n  }\n\n  //hack to get :active psuedo classes to work on ios.\n  $('button').on('touchstart', function(){$(this).addClass('down')});\n  $('button').on('touchend', function(){$(this).removeClass('down')});\n\n  $('#gamepad button:first')\n    .on('mousedown touchstart', function(){ keys.trigger('left,up,a','keydown'); $(this).addClass('down'); return false; })\n    .on('mouseup touchend', function(){ keys.trigger('left,up,a','keyup'); $(this).removeClass('down'); return false; })\n  $('#gamepad button:last')\n    .on('mousedown touchstart', function(){ keys.trigger('right,down,d','keydown'); $(this).addClass('down'); return false; })\n    .on('mouseup touchend', function(){ keys.trigger('right,down,d','keyup'); $(this).removeClass('down'); return false; })\n\n  $('footer .technology a').on('click', function(e){\n    if(ctx.pathname.indexOf('game') < 0){\n      see('/cssinfo');\n    } else {\n      if( ctx.pathname.indexOf('over') > -1 ){\n        see('/game/over/cssinfo');\n      } else {\n        see('/game/cssinfo');\n      }\n    }\n    e.stopImmediatePropagation();\n    return false;\n  })\n  $('#mobile-menu button.info').on('click', function(){\n    see('/game/cssinfo');\n    return false;\n  })\n\n  mouse.once('move',function(){\n    $('#canv-css .swipe-instruction').addClass('hide');\n  })\n\n  $('#canv-css .background')\n    .css('backgroundImage', 'url('+$('#canv-css .background img.bg').data( $(document).width() > 800 ? 'src-tablet' : 'src-mobile')+')');\n\n  $('.state.friend-invite').remove();\n  $('section.state.game-pause').remove();\n  $('.state.webcam-activate').remove();\n  $('.state.webcam-information').remove();\n  $('.state.webcam-waiting').remove();\n  $('.state.webcam-arrived').remove();\n  $('.state.game-wait').remove();\n  $('.state.friend-accept').remove();\n  $('.state.friend-left').remove();\n  $('#extras').remove();\n\n  var c = document.getElementById('canv-css').style;\n  $(window).on('resize', function(){\n    var rect = {w: 560, h: 500}\n      , dw = $(window).width()\n      , dh = $(window).height()\n      , w = dw / rect.w\n      , h = dh / rect.h\n      , scale = (w > h) ? h : w;\n    c.transform = c.webkitTransform = c.msTransform = c.MozTransform = c.OTransform = 'scale('+scale+') translateZ(0)';\n    // document.getElementsByTagName('html')[0].style.clip = 'rect(0, '+dw+'px, '+(dh+iphoneOmnibar)+'px, 0)'\n    // document.getElementById('game').style.clip = 'rect('+-dh/2+'px, '+dw/2+'px, '+(dh/2)+'px, '+(-dw/2)+'px)'\n    if( scale < 1.4){\n      settings.data.mouseSensitivity = (1.8-scale)/10;\n    }\n  }).resize();\n}\n\nMobile.leave = function(ctx, next){\n  // Nothing to do...\n}\n\nexports.Info = {\n  enter: function(ctx){\n    ctx.el.scrollTop(0,0);\n    if(ctx.pathname.indexOf('game') > -1) {\n      if(ctx.pathname.indexOf('over') > -1) {\n        $('button',ctx.el).on('click',function(){ see('/game/over') })\n      } else {\n        $('button',ctx.el).on('click',function(){ see('/game/pause') })\n      }\n    } else {\n      $('button',ctx.el).on('click',function(){ see('/main-menu') })\n    }\n  },\n  leave: function(ctx){\n    $('button',ctx.el).off('click');\n  },\n  cleanup: function(ctx){\n  }\n}\n\nfunction hasWebGL(){\n  if(window.WebGLRenderingContext){\n    try {\n      var canvas = document.createElement('canvas');\n      var context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n      if( context ){\n        return true;\n      } else {\n        console.warn('webgl was not available. you might want to visit http://get.webgl.org/troubleshooting/')\n      }\n    } catch(e){\n      console.error(e)\n    }\n  }\n  return false;\n}\n\nfunction has3d() {\n  var el = document.createElement('p'),\n    has,\n    transforms = {\n      'webkitTransform':'-webkit-transform',\n      'OTransform':'-o-transform',\n      'msTransform':'-ms-transform',\n      'MozTransform':'-moz-transform',\n      'transform':'transform'\n    };\n\n  // Add it to the body to get the computed style.\n  document.body.insertBefore(el, null);\n\n  for (var t in transforms) {\n    if (el.style[t] !== undefined) {\n      el.style[t] = 'translate3d(1px,1px,1px)';\n      has = window.getComputedStyle(el).getPropertyValue(transforms[t]);\n    }\n  }\n\n  document.body.removeChild(el);\n\n\n  //Check for preserve3d\n  var element = document.createElement('p'),\n      html = document.getElementsByTagName('HTML')[0],\n      body = document.getElementsByTagName('BODY')[0],\n      properties = {\n        'webkitTransformStyle':'-webkit-transform-style',\n        'MozTransformStyle':'-moz-transform-style',\n        'msTransformStyle':'-ms-transform-style',\n        'transformStyle':'transform-style'\n      };\n\n    body.insertBefore(element, null);\n\n    for (var i in properties) {\n      if (element.style[i] !== undefined) {\n        element.style[i] = 'preserve-3d';\n      }\n    }\n\n    var st = window.getComputedStyle(element, null),\n        transform = st.getPropertyValue('-webkit-transform-style') ||\n                    st.getPropertyValue('-moz-transform-style') ||\n                    st.getPropertyValue('-ms-transform-style') ||\n                    st.getPropertyValue('transform-style');\n\n    if(transform!=='preserve-3d'){\n      has = undefined;\n    }\n    document.body.removeChild(element);\n\n  return (has !== undefined && has.length > 0 && has !== 'none');\n}//@ sourceURL=slam/lib/states/mobile.js"
));
require.register("slam/lib/states/loading.js", Function("exports, require, module",
"/* global _gaq: true */\n\nvar $ = require('jquery')\n  , Preloader = require('preloader')\n  , see = require('../support/see')\n  , dmaf = require('../dmaf.min');\n\nvar Loading = exports;\n\nLoading.enter = function(ctx){\n  this.loader = new Preloader();\n  see('/main-menu')\n}\n\nLoading.leave = function(ctx, next){\n  var el = ctx.el;\n\n  if(!ctx.silent){\n    this.loader.push(function(done){\n      dmaf.addEventListener('dmaf_ready', function(){ done() });\n      dmaf.addEventListener('dmaf_fail', function(){\n        done();\n        _gaq.push(['_trackEvent', 'sound', 'failed']);\n      });\n      dmaf.init('/dmaf__assets/');\n    })\n  }\n\n  if( ctx.query.renderer == 'css' ){\n    // load CSS renderer\n    _gaq.push(['_trackEvent', 'renderer', 'css']);\n\n    this.loader.push(function(done){\n      console.time('load css')\n      loadScript('/javascript/renderer-css'+ctx.ext,function(err){\n        console.timeEnd('load css')\n        if( err ){return done(err)}\n        var RendererCSS = require('../renderer-css')\n        ctx.renderer.set(new RendererCSS(document.getElementById('canv-css')))\n        done()\n      })\n    })\n\n    this.loader.add('/images/mobile/puck.png');\n    this.loader.add('/images/mobile/paddle-p1.png');\n    this.loader.add('/images/mobile/paddle-p2.png');\n    this.loader.add('/images/mobile/shields.png');\n    this.loader.add('/images/mobile/bear.png');\n    this.loader.add('/images/mobile/extra-icons.png');\n    this.loader.add('/images/mobile/effects.png');\n    this.loader.add('/images/mobile/obstacles.png');\n    this.loader.add(findSrc('.mobile section.main-menu img'));\n    this.loader.add(findSrc('#canv-css .background img.bg'));\n\n    $('#canv-css .background').css('backgroundImage', 'url('+findSrc('#canv-css .background img.bg')+')');\n    $('header.main-menu').css('backgroundImage', 'url('+findSrc('.mobile section.main-menu img')+')');\n\n\n  } else if( ctx.query.renderer != 'none' ){\n    // load 3D renderer\n    _gaq.push(['_trackEvent', 'renderer', '3d']);\n\n    this.loader.push(function(done){\n      console.time('load 3d')\n      var pending = 3;\n      loadScript('/javascript/libs/TweenMax.min.js',check)\n      loadScript('/javascript/libs/three'+ctx.ext,check)\n      loadScript('/javascript/renderer-3d'+ctx.ext,check)\n      function check(err){\n        if( err ){return done(err)}\n        --pending || init()\n      }\n      function init(){\n        console.timeEnd('load 3d')\n        console.time('init 3d')\n        console.groupCollapsed('init 3d')\n\n        var Renderer3D = require('../renderer-3d');\n\n\n\n        var renderer = new Renderer3D(document.getElementById('canv-3d'))\n        renderer.on('initDone',function(){\n          console.groupEnd('init 3d')\n          console.timeEnd('init 3d')\n          done()\n        })\n        ctx.renderer.set(renderer)\n      }\n    })\n  }\n\n  this.loader.end(function(err){\n    console.timeEnd('load')\n    console.groupEnd('load')\n\n    // start the game loop\n    ctx.game.run()\n    el.remove()\n\n    next()\n  })\n}\n\nfunction findSrc(el){\n  if( $(document).width() > 800 ){\n    return $(el).data('src-tablet');\n  } else {\n    return $(el).data('src-mobile');\n  }\n}\n\nfunction loadScript(src,fn){\n  var s = document.createElement('script');\n  s.type = 'text/javascript';\n  s.async = true;\n  s.onerror = function(e){fn(e)};\n  s.onload = function(){fn()};\n  s.src = src;\n  var f = document.getElementsByTagName('script')[0];\n  f.parentNode.insertBefore(s, f);\n}//@ sourceURL=slam/lib/states/loading.js"
));
require.register("slam/lib/states/main-menu.js", Function("exports, require, module",
"/* global _gaq: true */\n\nvar inputs = require('mousetrap')\n  , see = require('../support/see')\n  , cookie = require('cookie')\n  , settings = require('../settings')\n  , settingsGUI = require('../settings-gui')\n  , actions = require('../actions')\n  , sound = require('../sound')\n  , $ = require('jquery')\n  , dmaf = require('../dmaf.min');\n\nvar MainMenu = exports;\n\nMainMenu.enter = function(ctx){\n  dmaf.tell('splash_screen')\n  ctx.renderer.changeView('main-menu');\n\n  document.addEventListener( 'visibilitychange', function ( event ) {\n    document.hidden?dmaf.tell('inactive'):dmaf.tell('active');\n  }, false );\n\n  // webkit\n  document.addEventListener( 'webkitvisibilitychange', function ( event ) {\n    document.webkitHidden?dmaf.tell('inactive'):dmaf.tell('active');\n  }, false );\n\n  $('#about').find('li').off('mousedown').on('mousedown', function(evt){\n    dmaf.tell('text_button_down', {className:evt.currentTarget.className})\n  }).off('mouseover').on('mouseover', function(evt){\n    dmaf.tell('text_button_over', {className:evt.currentTarget.className})\n  })\n\n  $('#socials').find('li').off('mousedown').on('mousedown', function(evt){\n    dmaf.tell('small_button_down', {className:evt.currentTarget.className})\n  }).off('mouseover').on('mouseover', function(evt){\n    dmaf.tell('small_button_over', {className:evt.currentTarget.className})\n  })\n\n  $('button').off('mousedown').on('mousedown', function(evt){\n    dmaf.tell('button_down', {className:evt.currentTarget.className})\n  }).off('mouseover').on('mouseover', function(evt){\n    dmaf.tell('button_over',{className:evt.currentTarget.className})\n  })\n\n\n  $('header.main-menu .links a').off('click').on('click', function(){\n    _gaq.push(['_trackEvent', 'outbound links', $(this).attr('href')]);\n  })\n\n  // check sound setting (stored in a cookie)\n  $('.sound-switch').click(function(){sound();return false;})\n\n  var friend = $('.play-friend',ctx.el)\n    , comp = $('.start',ctx.el);\n  friend.on('click',function(){\n    if($('body').hasClass('room-full')){\n      return see('/error/fullroom');\n    }\n    if(!ctx.network.available){\n      return see('/error/datachannels');\n    }\n    switch(ctx.network.pathname){\n      case '/friend/arrived':\n        return see('/friend/accept');\n      case '/friend/invite':\n      case '/friend/waiting':\n        return see('/friend/arrived');\n      default:\n        return see('/friend/invite');\n    }\n  })\n  //.prop('disabled',!ctx.network.available)\n\n  this.waitingFor = function(pathname){\n    if( ctx.network.pathname == '/friend/invite' ){\n      see('/friend/waiting')\n    }\n  }\n  ctx.network.on('change pathname',this.waitingFor)\n  if( ctx.network.pathname == '/friend/invite' ){\n    see('/friend/waiting')\n  }\n\n  comp.on('click', function(){\n    see('/game/instructions')\n  });\n\n  inputs.bind('space',function(){\n    comp.click()\n  })\n\n  if( ctx.query.extras ) {\n    var extras = ctx.query.extras.split(',');\n    var len = extras.length;\n    if( len ) {\n      settings.data.overrideSpawnExtras = true;\n      for( var i=0; i<len; i++) {\n        if( settings.data.spawnExtras.hasOwnProperty(extras[i]) ){\n          settings.data.spawnExtras[extras[i]] = true;\n        }\n      }\n    }\n  }\n\n  if( ctx.query.dev ) {\n    _gaq.push(['_trackEvent', 'settings', 'dev enabled']);\n    settingsGUI.createGenericUI( {isMobile:ctx.mobile, isNetwork: ctx.network.available})\n  }\n\n  // auto route\n  if(ctx.query.see) {\n    if( ctx.query.noleave ) {\n      see.abort();\n    }\n    see(ctx.query.see);\n  } else if( ctx.query.play ){\n    see('/game/instructions')\n  }\n\n}\n\nMainMenu.leave = function(ctx){\n  //removing delay added from setup for intro animation\n  $(ctx.el).removeClass('delay')\n\n  ctx.network.off('change pathname',this.waitingFor);\n  $('.play-friend',ctx.el).off('click')\n  $('.start',ctx.el).off('click')\n  inputs.unbind('space')\n}//@ sourceURL=slam/lib/states/main-menu.js"
));
require.register("slam/lib/states/prompt.js", Function("exports, require, module",
"var debug = require('debug')('states:prompt')\n  , see = require('../support/see')\n  , $ = require('jquery')\n  , dmaf = require('../dmaf.min');\n\nvar BEAT = 952.38;\n\nvar Prompt = exports;\n\nPrompt.enter = function(ctx){\n\n}\nPrompt.leave = function(ctx){\n}\n\nexports.Level = {\n  enter: function(ctx){\n    dmaf.tell('countdown_init')\n    see('/game/prompt/round')\n  },\n  leave: function(ctx,next){\n    this.timeout = setTimeout(next,BEAT)\n  },\n  cleanup: function(ctx){\n    clearTimeout(this.timeout)\n  }\n}\n\nexports.Round = {\n  enter: function(ctx){\n    var players = ctx.sync ? ctx.sync.world.players : ctx.game.world.players;\n    var round = players.a.score + players.b.score + 1;\n    $('#round-prompt h3 span').html(round);\n    see('/game/prompt/start')\n  },\n  leave: function(ctx,next){\n    this.timeout = setTimeout(next,BEAT)\n  },\n  cleanup: function(ctx){\n    clearTimeout(this.timeout)\n  }\n}\n\nexports.Start = {\n  enter: function(ctx){\n    var path = ctx.afterStart;\n    ctx.afterStart = null;\n\n    $(ctx.el).closest('section').addClass('alternate')\n    see(path||'/game/start')\n  },\n  leave: function(ctx,next){\n    $(ctx.el).closest('section').removeClass('alternate')\n    this.timeout = setTimeout(next,BEAT)\n  },\n  cleanup: function(ctx){\n    clearTimeout(this.timeout)\n  }\n}\n\nexports.Over = {\n  enter: function(ctx){\n    dmaf.tell('gameover_screen');\n    if(!ctx.multiplayer){\n      $('.over', $(ctx.el)).show().siblings().hide();\n    }\n    see('/game/over');\n  },\n  leave: function(ctx,next){\n    this.timeout = setTimeout(next,BEAT*3)\n  },\n  cleanup: function(ctx){\n    clearTimeout(this.timeout)\n  }\n}//@ sourceURL=slam/lib/states/prompt.js"
));
require.register("slam/lib/states/game.js", Function("exports, require, module",
"/* global _gaq:true */\nvar debug = require('debug')('states:game')\n  , settings = require('../settings')\n  , tracking = require('../tracking')\n  , see = require('../support/see')\n  , now = require('now')\n  , mouse = require('../support/mouse')\n  , keys = require('mousetrap')\n  , World = require('../world')\n  , inputs = require('../inputs')\n  , icons = require('../extra-icons')\n  , actions = require('../actions')\n  , puppeteer = require('../puppeteer')\n  , Themes = require('../themes')\n  , $ = require('jquery')\n  , dmaf = require('../dmaf.min');\n\nexports.Setup = {\n  enter: function(ctx){\n    debug('setup enter')\n    $('#scores .level').show();\n    $('#scores li').addClass('active');\n    $('#extras').show();\n\n    // set the active player in the renderer\n    ctx.renderer.activePlayer(!ctx.multiplayer || ctx.network.winner ? 0 : 1, false, ctx.multiplayer)\n\n    if( ctx.query.god ) {\n      settings.data.godMode = true;\n    }\n\n    if( ctx.query.momentum == 'off' ){\n      settings.data.paddleMomentum = false;\n    }\n\n    if( !isNaN(ctx.query.framerate) ){\n      var framerate = parseInt(ctx.query.framerate,10);\n      settings.data.framerate = framerate;\n      settings.data.timestep = 1000/framerate;\n    }\n\n    if( !isNaN(ctx.query.speed) ){\n      var speed = parseInt(ctx.query.speed,10);\n      settings.data.unitSpeed = speed;\n    }\n\n    // set the correct levels namespace\n    if( ctx.query.ns ){\n      puppeteer.namespace(ctx.query.ns);\n    } else if( ctx.mobile ){\n      puppeteer.namespace('mobile');\n    } else if( ctx.multiplayer ){\n      puppeteer.namespace('multi');\n    } else {\n      puppeteer.namespace('single');\n    }\n\n    setupLevel(ctx,ctx.game)\n    setupLevel(ctx,ctx.sync)\n    updateLevel(ctx,ctx.game.world.level.index)\n\n    $('#scores').fadeOut(0);\n  },\n\n  leave: function(ctx){\n    debug('setup leave')\n\n    inputs.reset()\n\n    // reset game to INIT\n    ctx.game.off('pre update',puppeteer.update)\n    ctx.game.reset();\n    ctx.game.world.players.a.reset(true, true);\n    ctx.game.world.players.b.reset(true, true);\n    ctx.game.world.setState(World.INIT)\n    ctx.game.world.level = null;\n    ctx.afterStart = null;\n\n    // remove ai when going from single to\n    // multiplayer\n    ctx.game.ai.setTarget(null);\n  }\n}\n\n\nexports.Instructions = {\n  enter: function(ctx){\n    debug('information enter')\n\n    dmaf.tell('info_screen')\n\n    startGame(ctx.game,ctx.network.winner,ctx.multiplayer,true)\n    startGame(ctx.sync,ctx.network.winner,ctx.multiplayer,true)\n\n    ctx.renderer.changeView('play');\n\n    $('#scores').hide()\n\n    $('.game-controls').show();\n    $('.info-animation', ctx.el).addClass('hidden').hide();\n\n    var self = this;\n\n    this.play = $('.play',ctx.el).show()\n    this.play.one('click',function(){\n      $('.game-controls').fadeOut(300);\n      $('.info-animation.mobile', ctx.el).parent().hide();\n      $('.info-animation.objective', ctx.el).delay(500).removeClass('hidden').hide().fadeIn({duration:0});\n\n      //Hack to easily get past info\n      keys.unbind('space');\n      keys.bind('space', function(){ infoComplete(ctx) });\n      $('.info-animation.objective', ctx.el).parent().one('click',function(){ infoComplete(ctx) })\n      clearTimeout(self.gameStartTimeout);\n      self.gameStartTimeout = setTimeout(function(){ infoComplete(ctx) }, 5000);\n    })\n    keys.bind('space', function(){ $('.play',ctx.el).click() });\n\n    if(ctx.mobile){\n      if(!ctx.touch) {\n        this.play.click()\n      } else {\n        var mob = $('.info-animation.mobile', ctx.el).removeClass('hidden').hide().fadeIn({duration:400}).parent();\n        mob.show();\n        self.gameStartTimeout = setTimeout(function(){\n          mob.click();\n        }, 12000);\n        mob.one('click',function(){\n          clearTimeout(self.gameStartTimeout);\n          self.play.click();\n        })\n      }\n    }\n\n    // autonavigate while testing multiplayer\n    if( ctx.query.autonav || ctx.query.play ){\n      infoComplete(ctx)\n    }\n\n    //debug round\n    if( !isNaN(ctx.query.round) ){\n      var round = Math.min(4,ctx.query.round);\n      ctx.game.world.me.score = Math.floor(ctx.query.round/2)\n\n      while(ctx.game.world.me.score + ctx.game.world.opponent.score < 4 ){\n        ctx.game.world.opponent.score += 1;\n      }\n    }\n  },\n\n  leave: function(ctx, next){\n    debug('information leave')\n    clearTimeout(this.gameStartTimeout);\n\n    dmaf.tell('info_screen_out')\n\n    this.play.off('click');\n    keys.unbind('space');\n    $('.info-animation', ctx.el).parent().unbind('click')\n\n    $('#scores .singleplayer').toggle(!ctx.multiplayer);\n    $('#scores .multiplayer').toggle(!!ctx.multiplayer);\n\n    $(ctx.el).removeClass('active').addClass('inactive')\n\n    this.nextTimeout = setTimeout(next, 1000)\n    ctx.game.world.setState(World.STARTING)\n  },\n\n  cleanup: function(ctx){\n    clearTimeout(this.nextTimeout)\n  }\n}\n\nexports.Wait = {\n  enter: function(ctx){\n    this.waiting = waitFor(ctx,'/game/wait','/game/prompt/level')\n  },\n\n  leave: function(ctx,next){\n    // wait until we're in play view\n    // and offset for latency for the one\n    // who came last (and thus has no `this.waiting`)\n    //\n    // one issues with this latency is that it's\n    // based on data channel instead of the signalling\n    // api so it may not be precise enough\n    //\n    // TODO add a EMIT(id) message which will be\n    //      executed as soon as it arrives instead of\n    //      being enqueued. maybe simply inputs.emit(id)\n    //      then we can use that in waitFor()\n    //\n    // console.log('wait latency',ctx.latency)\n    var offset = this.waiting !== null ? 100 : 100+(ctx.latency*2 || 0);\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(next, offset);\n  },\n\n  cleanup: function(ctx){\n    clearTimeout(this.timeout);\n    this.waiting && ctx.network.off('change pathname',this.waiting)\n  }\n}\n\nexports.Start = {\n\n  enter: function(ctx){\n    // start both games.\n    // (game, local, preview)\n    startGame(ctx.game,ctx.network.winner,ctx.multiplayer)\n    startGame(ctx.sync,ctx.network.winner,ctx.multiplayer)\n\n    // reset everything in the network\n    inputs.network.reset(true)\n\n    // restart the level\n    puppeteer.goto(ctx.game.world);\n    ctx.sync && puppeteer.goto(ctx.sync.world);\n    updateLevel(ctx,ctx.game.world.level.index);\n\n    if( ctx.game.world.level.index != tracking.currentLevel ) {\n      var levelTime = Date.now() - tracking.levelStartTime;\n      var level = ctx.game.world.level.index+1;\n      if( level > 1 ) {\n         _gaq.push(['_trackEvent', (ctx.multiplayer)?'2p':'1p', 'level ' + (level-1) + ' completed', undefined,Math.round(levelTime/1000) ]);\n      }\n      tracking.currentLevel = ctx.game.world.level.index;\n      tracking.levelStartTime = Date.now();\n      _gaq.push(['_trackEvent', (ctx.multiplayer)?'2p':'1p', 'level ' + level + ' started', undefined, level ]);\n    }\n\n    // update the ai based on level\n    ctx.game.ai.updateBrain(ctx.game.world.level.ai);\n    ctx.sync && ctx.sync.ai.updateBrain(ctx.sync.world.level.ai);\n\n    // copy the sync scores to world\n    if( ctx.multiplayer ){\n      ctx.game.world.players.a.score = ctx.sync.world.players.a.score;\n      ctx.game.world.players.b.score = ctx.sync.world.players.b.score;\n    }\n\n    // show scores\n    updateScores(ctx.sync ? ctx.sync.world : ctx.game.world)\n\n    // singleplayer\n    if( !ctx.multiplayer || ctx.query.ai ){\n      ctx.game.ai.setTarget(ctx.game.world.opponent.paddle);\n    }\n\n    see('/game/play')\n  },\n\n  leave: function(ctx){\n    ctx.renderer.changeView('play');\n  }\n\n}\n\nexports.Play = {\n  enter: function(ctx){\n    ctx.game.ai.start();\n    dmaf.tell('game_screen');\n    ctx.renderer.triggerEvent('gameStart');\n    $('.game-play').removeClass('active');\n    keys.bind(['esc','space'], see.bind('/game/pause'))\n    $('button.pause').on('click', see.bind('/game/pause'))\n    this.timeout = setTimeout(function(){\n      ctx.game.world.setState(World.PLAYING)\n      ctx.sync && ctx.sync.world.setState(World.PLAYING)\n\n      if(ctx.query.benchmark){\n        ctx.benchmarkStart = now();\n        ctx.benchmarkFrames = 0;\n\n        ctx.benchmarkCount = function(){\n          ctx.benchmarkFrames++;\n        }\n        ctx.game.on('enter frame',ctx.benchmarkCount)\n      }\n\n    }, 952.38)\n\n    if(ctx.touch) {\n      mouse.start(document.getElementById('game'))\n    }\n  },\n\n  leave: function(ctx){\n    keys.unbind(['esc','space'])\n    $('button.pause').off('click')\n    // send 10 more requests and see if latency has changed\n    ctx.multiplayer && ctx.network.winner && ctx.network.sync.update(10)\n    ctx.game.world.setState(World.PAUSED)\n    ctx.sync && ctx.sync.world.setState(World.PAUSED)\n    if(ctx.touch) {\n      mouse.stop(document.getElementById('game'))\n    }\n\n    if(ctx.query.benchmark){\n      ctx.benchmarkEnd = now();\n      ctx.game.off('enter frame',ctx.benchmarkCount)\n\n      var ms = ctx.benchmarkEnd - ctx.benchmarkStart;\n      var frames = ctx.benchmarkFrames;\n      var fps = frames/(ms/1000);\n      console.log('BENCHMARK: '+ms+' ms '+frames+' frames = '+fps+' avg fps')\n      $('#benchmarks').append('<p>'+ms.toFixed(2)+'ms, '+frames+' frames = '+fps.toFixed(2)+' avg fps</p>')\n    }\n\n  },\n\n  cleanup: function(){\n    this.unverify && this.unverify();\n    clearTimeout(this.timeout)\n  }\n}\n\n\nexports.Pause = {\n  enter: function(ctx){\n    ctx.game.ai.stop();\n    dmaf.tell('pause');\n    $('.main-menu',ctx.el)\n      .toggle(!ctx.multiplayer) // hidden if we already play in multiplayer\n      .on('click',see.bind('/main-menu'))\n\n    clearTimeout(this.timeout)\n    this.timeout = setTimeout(function(){\n      keys.bind('space', see.bind('/game/play'))\n      keys.bind('esc', see.bind('/main-menu'))\n      $('button.play', ctx.el).on('click',see.bind('/game/play'))\n    }, 1000);\n  },\n  leave: function(ctx){\n    clearTimeout(this.timeout);\n    keys.unbind('space')\n    keys.unbind('esc')\n    $('button.play',ctx.el).off('click')\n    $('.main-menu',ctx.el).off('click')\n    dmaf.tell('unpause')\n  }\n}\n\nexports.Next = {\n\n  enter: function(ctx){\n    var world = ctx.sync ? ctx.sync.world : ctx.game.world;\n\n    ctx.game.ai.stop();\n\n    debug('%s round over',world.frame)\n\n    // reset the input ack\n    inputs.network.reset()\n\n    // reset the icons\n    icons.clear()\n\n    // console.log('NEEEEXT!\\n\\n\\n\\n\\n\\n\\n')\n\n    var frame = world.frame;\n\n    // update the score for the opponent\n    // TODO this will fail if hit was on the other world\n    var other = ctx.game.world.players.a.hit !== -1 || world.players.a.hit !== -1\n                ? world.players.b\n                : world.players.a;\n    other.score += 1;\n\n    // hides everything a bit early for know\n    ctx.game.reset()\n    ctx.renderer.triggerEvent('resetPaddles');\n\n    // round over when someone reaches 3\n    var maxBalls = 3; // TODO setting?\n    var gameOver = world.players.a.score >= maxBalls || world.players.b.score >= maxBalls;\n    var winner = world.players.a.score > world.players.b.score\n               ? world.players.a\n               : world.players.b;\n\n    updateScores(world);\n\n    _gaq.push(['_trackEvent', ctx.multiplayer?'2p':'1p', (gameOver)?'game over':'round', undefined ,frame ]);\n\n    // multiplayer\n    if( ctx.multiplayer ){\n      if( winner === world.me ){\n        dmaf.tell('user_won_match')\n        $('.state.game-prompt-over h4.win').show().siblings().hide();\n      } else {\n        dmaf.tell('user_lost_match')\n        $('.state.game-prompt-over h4.loose').show().siblings().hide();\n      }\n\n      // round over = game over!\n      if( gameOver ){\n        debug('multiplayer game over')\n        winner.wins += 1;\n\n        if( winner === world.me ){\n          // TODO use the correct puck position (same as in actions.roundOver())\n          ctx.renderer.triggerEvent('explodeOpponent',{point:0.5})\n        }\n\n        world.setState(World.GAME_OVER)\n        ctx.renderer.triggerEvent('gameOver');\n        this.waiting = waitFor(ctx,'/game/next','/game/prompt/over');\n\n      // next round!\n      } else {\n        debug('multiplayer next round!')\n        dmaf.tell('countdown_short')\n        world.setState(World.NEXT_ROUND)\n        ctx.renderer.triggerEvent('roundOver');\n        this.waiting = waitFor(ctx,'/game/next','/game/prompt/round');\n\n      }\n\n    // singleplayer\n    } else {\n      //  round over + opponent winner = game over!\n      if( gameOver && winner === world.opponent ){\n        debug('singleplayer game over')\n        dmaf.tell('user_lost_match')\n        world.setState(World.GAME_OVER)\n        ctx.renderer.triggerEvent('gameOver')\n        see('/game/prompt/over')\n\n      // round over + me winner = level up!\n      } else if( gameOver && winner === world.me ){\n        debug('singleplayer level up!')\n        dmaf.tell('user_won_match')\n        // TODO use the correct puck position (same as in actions.roundOver())\n        ctx.renderer.triggerEvent('explodeOpponent',{point:0.5})\n        world.setState(World.NEXT_LEVEL)\n\n        clearTimeout(this.nextLevelTimeout)\n        this.nextLevelTimeout = setTimeout(function(){\n\n          world.players.a.reset(true);\n          world.players.b.reset(true);\n\n          ctx.renderer.triggerEvent('levelUp');\n\n          puppeteer.up(ctx.game.world);\n          ctx.sync && puppeteer.up(ctx.sync.world);\n          updateLevel(ctx,ctx.game.world.level.index);\n\n          clearTimeout(this.nextLevelTimeout)\n          this.nextLevelTimeout = setTimeout(function(){\n            see('/game/prompt/level');\n          }, (ctx.mobile ? 1500 : 4000))\n        }, (ctx.mobile ? 1000 :  4000))\n\n      // next round!\n      } else {\n        debug('singleplayer next round!')\n        if( other !== world.me ){\n          dmaf.tell('user_lost_round');\n        }\n        else {\n          dmaf.tell('user_won_round');\n        }\n\n        ctx.renderer.triggerEvent('roundOver');\n        world.setState(World.NEXT_ROUND)\n\n        clearTimeout(this.nextRoundTimeout)\n        this.nextRoundTimeout = setTimeout(function(){\n\n          ctx.renderer.triggerEvent('startCountDown');\n          clearTimeout(this.nextRoundTimeout)\n          this.nextRoundTimeout = setTimeout(function(){\n            dmaf.tell('countdown_short')\n            see('/game/prompt/round')\n          },952.38)\n        },2000);\n      }\n    }\n  },\n\n\n  leave: function(ctx,next){\n\n    clearTimeout(this.nextLevelTimeout)\n    clearTimeout(this.nextRoundTimeout)\n\n    this.waiting && ctx.network.off('change pathname',this.waiting)\n\n    // give some time for the bear to dance etc...\n    if( ctx.multiplayer ){\n      this.nextTimeout = setTimeout(next,2500)\n    } else {\n      this.nextTimeout = setTimeout(next,500)\n    }\n  },\n\n  cleanup: function(ctx){\n    clearTimeout(this.nextLevelTimeout)\n    clearTimeout(this.nextRoundTimeout)\n    clearTimeout(this.nextTimeout);\n  }\n\n}\n\n\nexports.Over = {\n  enter: function(ctx){\n\n    dmaf.tell('gameover_sign_in');\n\n    $('#scoreboard-multi').toggle(!!ctx.multiplayer)\n    $('#scoreboard-single').toggle(!ctx.multiplayer)\n    $('#scores').hide()\n\n    if(!ctx.multiplayer){\n      $('#single-levels i').text(ctx.game.world.level.index+1);\n    } else {\n      $('#me-levels i').text(ctx.sync.world.me.wins);\n      $('#opponent-levels i').text(ctx.sync.world.opponent.wins);\n    }\n\n    $('.main-menu',ctx.el).on('click',see.bind('/main-menu'));\n\n    function restart(){\n      $('.play',ctx.el).off('click');\n      keys.unbind('space');\n\n      $('.info-animation', ctx.el).unbind('click')\n\n      _gaq.push(['_trackEvent', (ctx.multiplayer)?'2p':'1p', 'restarted ' + (tracking.replayClicks++) + ' times' ]);\n\n      ctx.renderer.triggerEvent('restart');\n\n      if( ctx.multiplayer ) {\n        ctx.renderer.triggerEvent('levelUp');\n        puppeteer.up(ctx.game.world);\n        puppeteer.up(ctx.sync.world);\n        updateLevel(ctx,ctx.game.world.level.index);\n      }\n\n      $('#scores').fadeIn(500);\n\n      if(ctx.multiplayer){\n        see('/game/wait')\n\n      } else {\n        see('/game/prompt/level')\n\n      }\n      return false;\n    }\n\n    keys.bind('space',restart)\n    $('.play',ctx.el).on('click',restart)\n\n    ctx.renderer.changeView('gameOver');\n  },\n\n  leave: function(ctx){\n    dmaf.tell('gameover_sign_out');\n\n    ctx.game.reset()\n    ctx.sync && ctx.sync.reset()\n    updateScores(ctx.sync ? ctx.sync.world : ctx.game.world)\n\n    keys.unbind('space')\n    $('.main-menu',ctx.el).on('click')\n  }\n}\n\nfunction waitFor(ctx,path,then){\n  // console.log('  waiting for %s -> %s',path,then)\n  var next = null;\n  if( ctx.network.pathname === path ){\n    see(then)\n\n  } else {\n    // console.log('  waiting for pathname change')\n    next = function(pathname){\n      // console.log('  network pathname change', pathname)\n      if( pathname === path ){\n        ctx.network.off('change pathname',next)\n        see(then)\n      }\n    }\n    ctx.network.on('change pathname',next)\n  }\n  return next;\n}\n\nfunction setupLevel(ctx,game){\n  // ctx.sync is not available in mobile\n  // console.error('startGame', game, local, withPuck)\n  if( !game ) {return}\n\n  var world = game.world;\n\n  // add an update listener\n  game.on('pre update',puppeteer.update)\n\n  // debug shortcut\n  if( !isNaN(ctx.query.level) ){\n    puppeteer.goto(world,parseInt(ctx.query.level,10)-1);\n    console.log('DEBUG LEVEL',ctx.query.level)\n\n  } else {\n    puppeteer.goto(world,0)\n  }\n}\n\nfunction startGame(game,local,multi,preview){\n  // ctx.sync is not available in mobile\n  // console.error('startGame', game, local, withPuck)\n  if( !game ) {return}\n\n  var world = game.world;\n\n  // easy player access\n  world.me = !multi || local ? world.players.a : world.players.b;\n  world.opponent = !multi || local ? world.players.b : world.players.a;\n\n  // because I'm too lazy to do this better\n  world.multiplayer = multi;\n\n  // reset the game\n  game.reset();\n\n  // let the extra icons know which world\n  // it should listen too\n  // (will be sync when it exists)\n  icons.use(world)\n\n  // create paddles\n  world.players.a.paddle = actions.createPaddle(world,world.players.a);\n  world.players.b.paddle = actions.createPaddle(world,world.players.b);\n\n  if( preview ){\n    world.setState(World.PREVIEW)\n\n  } else {\n    // create shields\n    actions.createShields(world,world.players.a)\n    actions.createShields(world,world.players.b)\n\n    // create puck\n    actions.createPuckCenter(world)\n\n    world.setState(World.STARTING)\n  }\n}\n\nfunction updateScores(world){\n  debug('update scores %s %s - %s',world.name,world.players.a.score,world.players.b.score)\n  $('#scores li').addClass('active')\n  $('#scores .singleplayer .player li').slice(world.me.score).removeClass('active latest-winner');\n  $('#scores .singleplayer .opponent li').slice(world.opponent.score).removeClass('active latest-winner');\n  $('#scores .multiplayer .player li').slice(world.me.score).removeClass('active latest-winner');\n  $('#scores .multiplayer .opponent li').slice(world.opponent.score).removeClass('active latest-winner');\n}\n\nfunction updateLevel(ctx,level){\n  $('#level-prompt h2 span')\n    .html(level+1)\n    .closest('section')\n    .toggleClass('start', level===0); // adds start class for transition delay purposes\n  $('#level').html(level+1);\n\n  // make some noise\n  dmaf.tell('level_'+level);\n\n  // update theme\n  Themes.goto(level);\n  $('html').addClass('theme-'+Themes.current.name.replace(' ', ''));\n}\n\nfunction infoComplete(ctx){\n  $('#scores').fadeIn(500);\n  if( ctx.multiplayer ){\n    see('/game/wait')\n  } else {\n    see('/game/prompt/level')\n  }\n}//@ sourceURL=slam/lib/states/game.js"
));
require.register("slam/lib/states/game/input.js", Function("exports, require, module",
"var debug = require('debug')('states:game')\n  , settings = require('../../settings')\n  , mouse = require('../../support/mouse')\n  , keys = require('mousetrap')\n  , World = require('../../world')\n  , inputs = require('../../inputs');\n\nvar KEYS_LEFT = ['left','up','a']\n  , KEYS_RIGHT = ['right','down','d'];\n\nvar isLeft = 0\n  , isRight = 0;\n\nvar ctx;\n\nexports.enter = function(context){\n  ctx = context;\n  ctx.game.on('pre update',onupdate)\n  ctx.game.on('pre update',inputs.process)\n  keys.bind(KEYS_LEFT,onleft,'keydown')\n  keys.bind(KEYS_LEFT,offleft,'keyup')\n  keys.bind(KEYS_RIGHT,onright,'keydown')\n  keys.bind(KEYS_RIGHT,offright,'keyup')\n  mouse.on('move',onmove.bind(null,ctx.game.world))\n}\n\nexports.leave = function(ctx){\n  ctx.game.off('pre update',onupdate)\n  ctx.game.off('pre update',inputs.process)\n  keys.unbind(KEYS_LEFT,onleft,'keydown')\n  keys.unbind(KEYS_LEFT,offleft,'keyup')\n  keys.unbind(KEYS_RIGHT,onright,'keydown')\n  keys.unbind(KEYS_RIGHT,offright,'keyup')\n  mouse.off('move')\n}\n\nfunction onupdate(world,timestep){\n  switch(world.state){\n    case World.PREVIEW:\n    case World.PLAYING:\n    case World.OVER:\n      break;\n    default:\n      return;\n  }\n  // if( ctx.query.benchmark ) return;\n  var dir = settings.data.invertControls ? -1 : 1\n  isLeft  && inputs.record(inputs.types.MOVE,world.me.paddle,eps(-settings.data.keyboardSensitivity*dir));\n  isRight && inputs.record(inputs.types.MOVE,world.me.paddle,eps(+settings.data.keyboardSensitivity*dir));\n  if(ctx.touch){\n    mouse.tick() // will emit 'move' or 'click'\n  }\n}\n\nfunction onmove(world,dx,dy,dt){\n  // if( ctx.query.benchmark ) return;\n  var dir = settings.data.invertControls ? -1 : 1\n  inputs.record(inputs.types.MOVE,world.me.paddle,eps(dx * settings.data.mouseSensitivity*dir))\n}\n\nfunction onleft(){ isLeft = 1 }\nfunction onright(){ isRight = 1 }\nfunction offleft(){ isLeft = 0 }\nfunction offright(){ isRight = 0 }\nfunction eps(x){ return Math.round(x*1000)/1000 }\n//@ sourceURL=slam/lib/states/game/input.js"
));
require.register("slam/lib/states/game/multiplayer.js", Function("exports, require, module",
"var debug = require('debug')('states:game:multiplayer')\n  , settings = require('../../settings')\n  , see = require('../../support/see')\n  , keys = require('mousetrap')\n  , World = require('../../world')\n  , inputs = require('../../inputs')\n  , Game = require('../../game')\n  , estimateSlowDown = require('../../support/estimate-slow-down')\n  , now = require('now')\n  , latency = require('latency')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec\n  , $ = require('jquery')\n  , dmaf = require('../../dmaf.min');\n\nvar tell = null\n  , lock = false\n  , replay = false\n  , puckDirection = 0;\n\nvar lastSent = now()\n  , sent = {}\n  , times = []\n  , timesIndex = 0;\n\n// a lazy hack because it's used all over this\n// file. and this is better than relying on a\n// global object to have been defined...\nvar ctx;\n\nexports.enter = function(context){\n  ctx = context;\n  if( !ctx.multiplayer ){ return; }\n\n  // create a network game\n  ctx.sync = new Game('sync');\n  $('#extras').hide();\n\n  if( ctx.query.render == 'sync' ){\n    var Renderer2D = require('../../renderer-2d')\n    ctx.sync.setRenderer(new Renderer2D(document.getElementById('canv-db')))\n  }\n\n  // default to turn momentum off for multiplayer\n  settings.data.paddleMomentum = false;\n\n  // invert the controls for the \"other\" player\n  settings.data.invertControls = !ctx.network.winner;\n\n  // lower the framerate and raise the speed\n  // TODO tweak the speed\n  // TODO if we have a lower framerate we need to interpolate the\n  //      paddles or they look skippy.\n  settings.data.framerate = 30;\n  settings.data.timestep = 1000/30;\n  settings.data.unitSpeed = 35;\n\n  ctx.game.on('enter frame',flushInputs);\n  ctx.game.on('leave frame',forwardSync);\n  // ctx.game.on('pre update',lockOpponentPaddle);\n  // ctx.game.on('post update',timeShift);\n\n  ctx.sync.on('pre update',puckDirectionSave);\n  ctx.sync.on('post update',puckDirectionCheck);\n\n  ctx.network.on('change pathname',pathnameChange)\n  ctx.network.on('change latency',onlatency)\n  ctx.network.on('message',inputs.network.onmessage)\n  ctx.game.world.latency = ctx.latency;\n\n  inputs.network.on('ping',onping)\n  inputs.network.on('pong',onpong)\n  inputs.network.on('message',onmessage)\n  inputs.network.on('ack',onack)\n  inputs.network.on('move',onmove)\n  // inputs.network.on('hit',hitOrMiss)\n  // inputs.network.on('miss',hitOrMiss)\n\n  keys.bind('r',forceReplay)\n}\n\nexports.leave = function(ctx){\n  if( !ctx.multiplayer ){ return; }\n\n  ctx.game.off('enter frame',flushInputs);\n  ctx.game.off('leave frame',forwardSync);\n  ctx.game.off('pre update',lockOpponentPaddle);\n  ctx.game.off('post update',timeShift);\n\n  ctx.sync.off('pre update',puckDirectionSave);\n  ctx.sync.off('post update',puckDirectionCheck);\n  ctx.sync = null;\n\n  ctx.network.off('change pathname',pathnameChange)\n  ctx.network.off('change latency',onlatency)\n  ctx.network.off('message',inputs.network.onmessage)\n\n  inputs.network.off('ping',onping)\n  inputs.network.off('pong',onpong)\n  inputs.network.off('message',onmessage)\n  inputs.network.off('ack',onack)\n  inputs.network.off('move',onmove)\n  inputs.network.off('hit',hitOrMiss)\n  inputs.network.off('miss',hitOrMiss)\n\n  keys.unbind('r',forceReplay)\n}\n\n// used to measure the time since the last packet\n// to send KEEP_ALIVE packets.\nfunction flushInputs(world){\n  var sendRate = 1000/settings.data.sendRate;\n  var n = now();\n  if( n - lastSent > sendRate ){\n    if( inputs.network.flush() ){\n      lastSent = n;\n    } else if( world.state == World.PLAYING && n - lastSent > settings.data.keepAliveInterval ){\n      var id = (Math.random()*65535)|0; // 16bit\n      sent[id] = now();\n      inputs.record(inputs.types.PING,id);\n    }\n  }\n}\n\nfunction forwardSync(world){\n  var state = ctx.sync.world.state\n    , frame = ctx.sync.world.frame;\n\n  // silence\n  tell = dmaf.tell;\n  dmaf.tell = silentDMAF;\n\n  // forward the sync game\n  inputs.network.forward(ctx.sync,world.frame,ctx.network.winner)\n\n  // render the sync game\n  // (adds a 'hack'-puck which shows it's position in \"game\")\n  if( ctx.query.render == 'sync' ){\n    var p = ctx.game.world.pucks.values[0];\n    p && ctx.sync.world.pucks.set('hack',p)\n    ctx.sync.render()\n    p && ctx.sync.world.pucks.del('hack')\n  }\n\n  // has a replay been requested?\n  if( replay ){\n    // console.log('replaying %s -> %s',ctx.sync.world.frame,world.frame)\n    var frames = Math.floor(ctx.latency*settings.data.timestep);\n    inputs.network.replay(ctx.sync.world,world,frames)\n    replay = false;\n  }\n\n  // end of silence\n  dmaf.tell = tell;\n}\n\n// lock the position of the paddle\n// data.x should be removed after a replay\n// so this should be enough\nfunction lockOpponentPaddle(world){\n  if( world.state !== World.PLAYING ){\n    return;\n  }\n\n  var paddle = world.paddles.get(world.opponent.paddle);\n  if( paddle && paddle.data.x ){\n    console.log('opponent paddle locked at %s',paddle.data.x)\n    paddle.previous[0] = paddle.current[0] = paddle.data.x;\n  }\n}\n\nfunction timeShift(world){\n  if( world.state !== World.PLAYING ){\n    return;\n  }\n\n  // slow down the puck if necessary\n  var paddle = world.paddles.get(world.opponent.paddle);\n  var puck = world.pucks.values[0];\n  var spuck = ctx.sync.world.pucks.get(puck.index)\n  if( world.frame > 1 && puck && ctx.latency ){\n\n    // max out at 300ms latency to avoid insanely slow pucks\n    // (a warning will be shown at this point anyway)\n    // var t = 1000/settings.data.sendRate + Math.min(ctx.latency,300);\n    // var t = Math.min(ctx.latency,300); // latency should include send rate, right?\n    var t = Math.abs( world.frame - ctx.sync.world.frame ) * settings.data.timestep;\n    var m = estimateSlowDown(paddle.current[1] - puck.current[1],spuck.velocity[1],t)\n\n    if( m !== null && m !== 1 ){\n      // based on the sync puck velocity or we'll have\n      // a squared deceleration.\n      var l = vec.len(spuck.velocity);\n      if( l ){\n        vec.norm(puck.velocity,puck.velocity)\n        vec.smul(puck.velocity,m*l,puck.velocity);\n        vec.sub(puck.current,puck.velocity,puck.previous)\n      }\n    }\n  }\n}\n\nfunction puckDirectionSave(world){\n  if( world.state !== World.PLAYING ){\n    return;\n  }\n\n  // store the pre-update direction to track direction\n  // change\n  var puck = world.pucks.values[0];\n  if( puck ){\n    puckDirection = puck.velocity[1] > 0 ? +1 : -1;\n    // console.log('setting puck direction',puckDirection)\n  }\n}\n\nfunction puckDirectionCheck(world){\n  if( world.state !== World.PLAYING ){\n    return;\n  }\n\n  var puck = world.pucks.values[0];\n  if( puck && puckDirection ){\n    var prevDirection = puckDirection;\n    puckDirection = puck.velocity[1] > 0 ? +1 : -1;\n    // console.log('getting puck direction',prevDirection,puckDirection)\n    if( prevDirection !== puckDirection ){\n      // console.log('puck direction change player: %s v: %s',world.me === world.players.a ? 'a' : 'b', puck.velocity[1])\n      if( (world.me === world.players.a && puck.velocity[1] > 0) ||\n          (world.me === world.players.b && puck.velocity[1] < 0) ){\n        // console.log('replaying because of direction change')\n        replay = true;\n      }\n    }\n  }\n}\n\nfunction pathnameChange(pathname){\n  switch(pathname){\n    case '/game/pause':\n      if( ctx.pathname === '/game/play' ){\n        see(pathname);\n      }\n      break;\n    case '/game/play':\n      if( ctx.pathname === '/game/pause' ){\n        see(pathname);\n      }\n      break;\n  }\n}\n\nfunction onmessage(buf){\n  ctx.network.send(buf)\n}\nfunction onping(id){\n  inputs.record(inputs.types.PONG,id)\n}\nfunction onpong(id){\n  var p = sent[id];\n\n  // invalid PONG!\n  if( !p ){ return; }\n\n  // latency is one-way\n  var n = now();\n  var d = (n - p)/2;\n\n  // store in a circular array w. 128 elements\n  times[timesIndex] = d;\n  timesIndex = (timesIndex+1) & 127;\n\n  // wait until we have a bit of times before\n  // updating ctx.latency. for better accuracy.\n  if( times.length > 16 ){\n    ctx.latency = Math.round(latency(times));\n    ctx.network.emit('change latency',ctx.latency)\n  }\n}\nfunction onack(ack){\n  // console.log('ack %s world %s diff %s',ack,ctx.game.world.frame,ack-ctx.game.world.frame)\n  if( ack - 5 > ctx.game.world.frame ){\n    var steps = Math.min(50,ack - ctx.game.world.frame);\n    console.warn('game is way behind! should update %s frames extra',steps)\n    for(var i=0;i<steps;i++){\n      ctx.game.update();\n    }\n  }\n}\nfunction onmove(input){\n  if( input[1] == ctx.game.world.opponent.paddle ){\n    inputs.types.execute(ctx.game.world,input)\n  }\n}\nfunction onlatency(latency){\n  ctx.game.world.latency = latency;\n}\nfunction forceReplay(){\n  replay = true;\n}\nfunction hitOrMiss(x,v,f){\n  if( ctx.game.world.state !== World.PLAYING ){\n    return;\n  }\n\n  // console.log('received hit or miss. opponent paddle will be at x: %s v: %s',x,v,f)\n  var paddle = ctx.game.world.paddles.get(ctx.game.world.opponent.paddle);\n\n  // store the velocity on the paddle so it can be used when\n  // calculating the momentum instead of the actual velocity\n  // which may be 0;\n  paddle.data.vx = v;\n  paddle.data.x = x;\n}\n\nfunction silentDMAF(id){\n  var valid = ~id.indexOf('_screen') ||\n              ~id.indexOf('countdown_') ||\n              ~id.indexOf('_match') ||\n              ~id.indexOf('_round') ||\n              ~id.indexOf('level_') ||\n              ~id.indexOf('_score');\n\n  if( valid ){\n    tell.apply(dmaf,arguments);\n  } else if( dmaf.log ){\n    console.log('dmaf.tell (silent): %s',id)\n  }\n}//@ sourceURL=slam/lib/states/game/multiplayer.js"
));
require.register("slam/lib/states/game/verify.js", Function("exports, require, module",
"var debug = require('debug')('states:game:verify')\n  , exclude = require('../../support/exclude')\n  , keys = require('mousetrap')\n  , World = require('../../world')\n  , inputs = require('../../inputs')\n  , diff = require('../../support/diff');\n\nvar hashes = {}\n  , jsons = {}\n  , verifyInputs = []\n  , interval;\n\nvar ctx;\n\nexports.enter = function(context){\n  ctx = context;\n  if( !ctx.query.verify ){\n    return;\n  }\n\n  if( ctx.query.verify == 'inputs' ){\n    keys.bind('i',sendInputs)\n    ctx.network.remote.on('inputs',compareInputs)\n    inputs.network.on('dequeue',logInputs)\n  } else {\n    keys.bind('.',sendHashes)\n    ctx.network.remote.on('hashes',compareHashes)\n    ctx.network.remote.on('world',compareWorlds)\n    ctx.sync.on('post update',logHashCode)\n  }\n\n  if( !isNaN(ctx.query.verify) ){\n    var ms = +ctx.query.verify;\n    console.warn('sending hashes every %sms',ms)\n    interval = setInterval(function(){ keys.trigger('.') },ms)\n  }\n}\n\n\nexports.leave = function(ctx){\n  if( !ctx.query.verify ){\n    return;\n  }\n  clearInterval(interval);\n  keys.unbind('.',sendHashes)\n  ctx.network.remote.off('inputs',compareInputs)\n  ctx.network.remote.off('hashes',compareHashes)\n  ctx.network.remote.off('world',compareWorlds)\n  ctx.sync && ctx.sync.off('post update',logHashCode)\n  inputs.network.off('dequeue',logInputs)\n}\n\nfunction sendHashes(){\n  console.log('sending %s hashes!',hashes.length)\n  if( !hashes.length ){ return; }\n  ctx.network.remote.signal.send({type:'hashes',hashes: hashes})\n}\n\nfunction sendInputs(){\n  console.log('sending %s inputs!',verifyInputs.length/2)\n  if( !verifyInputs.length ){ return; }\n  ctx.network.remote.signal.send({type:'inputs',inputs: verifyInputs})\n}\n\nfunction compareInputs(e){\n  console.groupCollapsed('comparing inputs')\n  var l = Math.min(verifyInputs.length,e.inputs.length);\n  for(var i=0; i<l; i+=2){\n    if( !compareInput(i,verifyInputs,e.inputs) ){\n      console.error('inputs mismatched!',verifyInputs[i],verifyInputs[i+1],e.inputs[i+1])\n      throw new Error('inputs mismatched!')\n    }\n  }\n  console.groupEnd('comparing inputs')\n}\n\nfunction compareInput(i,a,b){\n  if( a[i] !== b[i] ){\n    console.log('frames mismatched:',a[i],b[i])\n    return false;\n  }\n  i += 1\n  if( a[i][0] !== b[i][0] ){\n    console.log('types mismatched:',a[i][0],b[i][0])\n    return false;\n  }\n  if( a[i].length !== b[i].length ){\n    console.log('input length mismatched:',a[i].length,b[i].length)\n    return false;\n  }\n  for(var j=1; j<a[i].length; j++){\n    if( a[i][j] !== b[i][j] ){\n      console.log('input arguments mismatched:',a[i],b[i])\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction compareHashes(e){\n  var frames = [].concat(Object.keys(e.hashes),Object.keys(hashes))\n                 .sort(function(a,b){return parseInt(a,10)-parseInt(b,10)});\n  console.groupCollapsed('comparing hashes')\n  var misMatch = null\n    , f = -1; // last frame\n  for(var i=0; i<frames.length; i++){\n    var frame = frames[i];\n    if( f === frame ){ continue; }\n    f = frame;\n    console.log(' frame: %s local: %s network: %s',frame,hashes[frame],e.hashes[frame]);\n    if( hashes[frame] && e.hashes[frame] && hashes[frame] !== e.hashes[frame] ){\n      console.log(' hashes does not match (%s vs %s), sending json of world to compare',hashes[frame],e.hashes[frame])\n      ctx.network.remote.signal.send({type:'world',frame: frame,world: jsons[frame]})\n      misMatch = frame;\n      break;\n    }\n  }\n  console.groupEnd('comparing hashes')\n  if( misMatch !== null ){\n    console.error('hashes did not match at %s',misMatch)\n    throw new Error('check diff on other machine plz');\n  }\n}\n\nfunction compareWorlds(e){\n  var misMatch = false;\n  console.group('comparing worlds at frame %s',e.frame)\n  if( jsons[e.frame] !== e.world ){\n    console.log('NOT THE SAME, trying diff:')\n    console.log(diff.createPatch('diff for frame '+e.frame,jsons[e.frame],e.world,'local','remote'))\n    console.log('remote',[JSON.parse(e.world)])\n    console.log('local',[JSON.parse(jsons[e.frame])])\n    misMatch = true;\n  }\n  console.groupEnd('comparing worlds at frame %s',e.frame)\n\n  if(misMatch){\n    throw new Error('check diff plz');\n  }\n}\n\n// used as JSON replacer to\n// find undefined values\nfunction unhide(k,v){\n  if( typeof v == 'undefined' ){\n    return 'undefined';\n  }\n  return v;\n}\n\nfunction logHashCode(world){\n  // hash and store without me/opponent/name\n  hashes[world.frame] = world.code()\n  exclude(world,World.EXCLUDED,function(world){\n    jsons[world.frame] = JSON.stringify(world,unhide,2)\n  })\n}\n\nfunction logInputs(input,frame){\n  verifyInputs.push(frame,input);\n}//@ sourceURL=slam/lib/states/game/verify.js"
));
require.register("slam/lib/states/webcam.js", Function("exports, require, module",
"var see = require('../support/see')\n  , $ = require('jquery');\n\nvar getUserMedia = navigator.getUserMedia\n                || navigator.webkitGetUserMedia\n                || navigator.mozGetUserMedia\n                || navigator.msGetUserMedia;\nif( getUserMedia ){\n  getUserMedia = getUserMedia.bind(navigator);\n}\n\nexports.Activation = {\n  enter: function(ctx){\n    ctx.renderer.changeView('webcamActivation')\n    $('#settingsGUIContainer').css('opacity',0);\n\n    var constraints = {\n      video: {\n        mandatory: {\n          maxWidth: 320,\n          maxHeight: 240,\n          minFrameRate: 10\n        }\n      },\n      audio: !ctx.dev\n    }\n\n    getUserMedia(constraints,success,error)\n\n    function success(stream){\n      ctx.webcam = true;\n      var videoInput = document.getElementById('localInput');\n      videoInput.width = 320\n      videoInput.height = 240\n      videoInput.videoWidth = 320\n      videoInput.videoHeight = 240\n      videoInput.autoplay = true\n      videoInput.src = window.webkitURL ? window.webkitURL.createObjectURL(stream) : stream\n      ctx.renderer.triggerEvent('localVideoAvailable');\n      ctx.network.remote.addStream(stream)\n      see('/webcam/waiting')\n    }\n\n    function error(){\n      ctx.webcam = false;\n      see('/webcam/information');\n    }\n  },\n  leave: function(ctx){\n    $('#settingsGUIContainer').css('opacity',1);\n  }\n}\n\n\nexports.Information = {\n  enter: function(ctx){\n    $('#activate-camera').on('click',function(){\n      see('/webcam/activate')\n    })\n    $('.keyboard',ctx.el).on('click',function(){\n      see('/game/start')\n    })\n  },\n  leave: function(ctx){\n    $('#activate-camera').off('click')\n    $('.keyboard',ctx.el).off('click')\n  }\n}\n\n\nexports.Waiting = {\n  enter: function(ctx){\n    this.pathchange = function(pathname){\n      if( pathname == '/webcam/waiting'){\n        see('/game/instructions')\n      }\n    }\n    ctx.network.on('change pathname',this.pathchange)\n    if( ctx.network.pathname == '/webcam/waiting'){\n      see('/game/instructions')\n    }\n  },\n  leave: function(ctx,next){\n    ctx.network.off('change pathname', this.pathchange)\n\n    // wait until ready before leaving\n    if( ctx.network.ready ){\n      next()\n    } else {\n      // TODO cleanup next?\n      ctx.network.once('ready',next);\n      ctx.network.start()\n    }\n  },\n  cleanup: function(ctx){\n    ctx.network.off('ready')\n  }\n}\n\n//@ sourceURL=slam/lib/states/webcam.js"
));
require.register("slam/lib/states/friend.js", Function("exports, require, module",
"var debug = require('debug')('states:game')\n  , see = require('../support/see')\n  , inputs = require('mousetrap')\n  , selectRange = require('../support/select-text')\n  , $ = require('jquery')\n  , dmaf = require('../dmaf.min');\n\nfunction mainmenu(){ see('/main-menu') }\nfunction webcam(ctx){\n  ctx.webcam ? see('/webcam/waiting') : see('/webcam/activate')\n}\n\nexports.Invite = {\n  enter: function(ctx){\n    dmaf.tell('friend_screen');\n    $('.return-mainmenu',ctx.el).on('click',mainmenu)\n    inputs.bind('space',mainmenu)\n    $('span.url', ctx.el).text(window.location.href)\n    selectRange($('.share-url')[0])\n  },\n  leave: function(ctx){\n    dmaf.tell('friend_screen_out');\n    $('.return-mainmenu',ctx.el).off('click')\n    inputs.unbind('space')\n  }\n}\n\n\nexports.Accept = {\n  enter: function(ctx){\n    dmaf.tell('friend_accept')\n    this.waitingFor = waitFor(ctx, '/friend/accept', webcam)\n  },\n  leave: function(ctx){\n    dmaf.tell('friend_accept_out')\n    this.waitingFor && ctx.network.off('change pathname', this.waitingFor)\n  }\n}\n\n\nexports.Arrived = {\n  enter: function(ctx){\n    dmaf.tell('friend_arrived');\n    $('.play-friend',ctx.el).on('click',function(){ inputs.trigger('space') })\n    inputs.bind('space',function(){ see('/friend/accept') })\n    if( ctx.query.autonav ){\n      this.timeout = setTimeout(function(){\n        inputs.trigger('space')\n      },1000)\n    }\n  },\n  leave: function(ctx){\n    dmaf.tell('friend_arrived_out');\n    $('.play-friend',ctx.el).off('click')\n    inputs.unbind('space')\n  }\n}\n\nexports.Waiting = {\n  enter: function(ctx){\n    dmaf.tell('friend_waiting')\n    $('.play-friend',ctx.el).on('click',function(){ inputs.trigger('space') })\n    inputs.bind('space',function(){ see('/friend/accept') })\n    // while testing click the button automatically\n    if( ctx.query.autonav ){\n      this.timeout = setTimeout(function(){\n        inputs.trigger('space')\n      },1000)\n    }\n  },\n  leave: function(ctx){\n    dmaf.tell('friend_waiting_out')\n  },\n  cleanup: function(ctx){\n\n    // this.waitingFor && ctx.network.off('change pathname', this.waitingFor)\n    $('.play-friend',ctx.el).off('click')\n    inputs.unbind('space')\n    clearTimeout(this.timeout)\n  }\n}\n\n\nexports.Left = {\n  enter: function(ctx){\n    dmaf.tell('friend_left')\n    var btn = $('.main-menu',ctx.el).on('click',mainmenu)\n    inputs.bind('space',mainmenu)\n  },\n  leave: function(ctx){\n    dmaf.tell('friend_left_out')\n    $('.main-menu',ctx.el).off('click')\n    inputs.unbind('space')\n  }\n}\n\nfunction waitFor(ctx,path,then){\n  debug('  waiting for %s -> %s',path,then)\n  var next = null;\n  if( ctx.network.pathname && ctx.network.pathname.indexOf(path) === 0 ){\n    then(ctx)\n  } else {\n    debug('  waiting for pathname change')\n    next = function(pathname){\n      debug('  network pathname change', pathname)\n      if( pathname.indexOf(path) === 0 ){\n        ctx.network.off('change pathname',next)\n        then(ctx)\n      }\n    }\n    ctx.network.on('change pathname',next)\n  }\n  return next;\n}//@ sourceURL=slam/lib/states/friend.js"
));
require.register("slam/lib/actions/index.js", Function("exports, require, module",
"var Emitter = require('emitter');\n\nEmitter(exports)\n\nmerge(exports,require('./bodies'))\nmerge(exports,require('./bullet'))\nmerge(exports,require('./paddle'))\nmerge(exports,require('./puck'))\nmerge(exports,require('./game'))\nmerge(exports,require('./extra'))\nmerge(exports,require('./obstacle'))\nmerge(exports,require('./force'))\nmerge(exports,require('./debug'))\nmerge(exports,require('./player'))\nmerge(exports,require('./shields'))\n\nfunction merge(into,obj){\n  for(var k in obj)\n    into[k] = obj[k];\n}//@ sourceURL=slam/lib/actions/index.js"
));
require.register("slam/lib/actions/bodies.js", Function("exports, require, module",
"var debug = require('debug')('actions:bodies')\n  , actions = require('./');\n\n/**\n * Destroys a Body based on index.\n *\n * Used in `world.copyBodies()` as it doesn't know\n * which what type of body it will have to delete.\n *\n * @param  {World} world\n * @param  {Number} index\n */\nexports.destroy = function(world,index){\n  debug('%s destroy',world.name,index)\n\n  if( world.pucks.has(index) ){\n    actions.destroyPuck(world,world.pucks.get(index));\n\n  } else if( world.extras.has(index) ){\n    actions.destroyExtra(world,world.extras.get(index));\n\n  } else if( world.obstacles.has(index) ){\n    actions.destroyObstacle(world,world.obstacles.get(index));\n\n  } else if( world.forces.has(index) ){\n    actions.destroyForce(world,world.forces.get(index));\n\n  } else if( world.bullets.has(index) ){\n    actions.destroyBullet(world,world.bullets.get(index));\n\n  } else if( world.paddles.has(index) ){\n    actions.destroyPaddle(world,world.paddles.get(index));\n\n  } else if( world.shields.has(index) ){\n    actions.destroyShield(world,world.shields.get(index));\n\n  } else {\n    console.warn('unknown type of body:',index)\n  }\n}//@ sourceURL=slam/lib/actions/bodies.js"
));
require.register("slam/lib/actions/bullet.js", Function("exports, require, module",
"var debug = require('debug')('actions:bullet')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec\n  , BodyFlags = require('../sim/body-flags')\n  , shapes = require('../sim/shapes')\n  , settings = require('../settings')\n  , actions = require('../actions')\n  , dmaf = require('../dmaf.min');\n\n\n// id is a generated id (ex 'a1' = player + (last shot id + 1))\n// x, y is position it should start at\n// v is the speed it should be moving with\nexports.createBullet = function(world,paddle){\n  debug('%s create',world.name ,paddle)\n\n  var forward = paddle.index === world.players.b.paddle;\n\n  var c = paddle.current\n    , s = settings.data.unitSpeed * settings.data.bulletSpeed\n    , v = vec.make(0, forward ? -s : s);\n\n  // define a shape of the shot\n  var bulletWidth = settings.data.unitSize;\n  var bulletHeight = 150;\n  var shape = shapes.rect(bulletWidth,bulletHeight);\n\n\n  // round x to unitSize\n  var paddleCenter = c[0] + bulletWidth*0.5 // no this would be the paddle edge?\n  var spawnX = Math.floor(paddleCenter/bulletWidth)*bulletWidth-bulletWidth*0.5;\n\n  // create a shot body\n  var paddleHeight = paddle.aabb[2] - paddle.aabb[0];\n  var spawnY = c[1] + s + (paddleHeight + bulletHeight)*(forward ? 1 : -1);\n\n  var body = world.createBody(shape,spawnX,spawnY, BodyFlags.DYNAMIC | BodyFlags.DESTROY);\n  body.id = 'bullet';\n\n  // push it in the right direction (based on `v`)\n  vec.add(body.current,v,body.previous)\n  vec.free(v)\n\n  // save it for rendering and physics\n  world.bullets.set(body.index,body)\n  actions.emit('added','bullet',world,body);\n}\n\nexports.hitBulletObstacle = function(world, bullet, obstacle){\n  debug('%s hit obstacle', world.name, bullet.index, obstacle.index)\n\n  actions.destroyBullet(world,bullet);\n}\n\nexports.hitBulletPaddle = function(world, bullet, paddle){\n  debug('%s hit paddle', world.name, bullet.index, paddle.index)\n\n  // destroy the bullet\n  actions.destroyBullet(world,bullet);\n\n  dmaf.tell( (paddle.index == world.me.paddle?'user':'opponent')+ '_paddle_shrink')\n\n  // shrink paddle to half the size\n  actions.resizePaddle(world, paddle.index, 0.5);\n\n  // timeout after 5s and scale back to normal\n  world.tick.clearTimeout(paddle.data.resizeTimeout);\n  paddle.data.resizeTimeout = world.tick.setTimeout('resizePaddle',5000,paddle.index,1)\n}\n\nexports.destroyBullet = function(world, body){\n  debug('%s destroy',world.name ,body.index)\n  world.bullets.del(body.index)\n  world.releaseBody(body)\n  actions.emit('removed','bullet',world,body);\n}//@ sourceURL=slam/lib/actions/bullet.js"
));
require.register("slam/lib/actions/paddle.js", Function("exports, require, module",
"var debug = require('debug')('actions:paddle')\n  , settings = require('../settings')\n  , BodyFlags = require('../sim/body-flags')\n  , shapes = require('../sim/shapes')\n  , actions = require('../actions')\n  , inputs = require('../inputs')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec\n  , mat = geom.mat\n  , dmaf = require('../dmaf.min');\n\n\nexports.createPaddle = function(world,player){\n  debug('%s create',world.name ,player)\n  var aw = settings.data.arenaWidth\n    , ah = settings.data.arenaHeight\n    , u = settings.data.unitSize\n    , w = u*5\n    , h = u\n    , x = aw/2\n    , y = (player === world.players.b ? u : ah-u);\n\n  var flags = BodyFlags.DYNAMIC | BodyFlags.BOUNCE | BodyFlags.STEER;\n  // if( world.multiplayer ){\n  //   flags = BodyFlags.DYNAMIC | BodyFlags.BOUNCE | BodyFlags.DIRECT;\n  // }\n\n  var paddle = world.createBody(shapes.rect(w,h),x,y,flags)\n  paddle.id = 'paddle' // for debugging mostly\n  paddle.damping = settings.data.paddleDamping;\n  paddle.mass = settings.data.paddleMass;\n  world.paddles.set(paddle.index,paddle);\n  actions.emit('added paddle',world,paddle);\n  return paddle.index;\n}\n\nexports.hitPuckPaddle = function(world,puck,paddle){\n\n  var player = paddle.index === world.players.a.paddle ? 'a' : 'b';\n\n  // only add if puck hit other paddle in between\n  if( world.lastHitPucks[puck.index] !== player ){\n    world.puckBounces[puck.index]++;\n  }\n\n  if( paddle.data.x ){\n    console.log('PUCK HIT PADDLE')\n    console.log('does data.x match the current x?',paddle.data.x,paddle.current[0])\n  }\n\n  // mark who hit it last\n  world.lastHitPucks[puck.index] = player;\n\n  // puck was already fireball\n  if( puck.data.fireball === 1){\n    // make paddle \"dizzy\"\n    actions.dizzyPaddle(world, paddle.index);\n    puck.data.fireball = 2; // turn off\n\n    //reset one frame later to allow visual effect\n    world.tick.nextFrame('resetPuckExtra',puck.index,'fireball')\n    world.tick.nextFrame('resetPaddleExtra',paddle.index,'fireball')\n  }\n\n  // figure out puck speed\n  var speed = actions.getPuckSpeed(world,puck)\n\n  // transfer the fireball effect\n  if( paddle.data.fireball ){\n    speed *= settings.data.fireballSpeedup; // speed up 20%\n    puck.data.fireball = 1; // turn on\n    paddle.data.fireball = 2; // turn off\n    //reset one frame later to allow visual effect\n    world.tick.nextFrame('resetPaddleExtra',paddle.index,'fireball')\n  }\n\n  // without paddle momentum\n  if( !settings.data.paddleMomentum ){\n    actions.puckSpeed(world,puck,speed)\n\n  // with paddle momentum\n  } else {\n    // data.vx is set when a HIT() has been\n    // received in multiplayer to prepare the predictive\n    // \"game\". should be reset after use\n    var vx = paddle.velocity[0];\n    if( paddle.data.vx ){\n      paddle.velocity[0] = paddle.data.vx;\n    }\n    actions.puckSpeedMomentum(world,puck,speed,paddle.velocity)\n\n    // remove/reset\n    delete paddle.data.vx;\n    paddle.velocity[0] = vx;\n  }\n\n  if( paddle.index === world.me.paddle ){\n    dmaf.tell('user_paddle_hit');\n    if( world.multiplayer && world.name == 'game' ){\n      inputs.record(inputs.types.HIT,paddle.current[0],paddle.velocity[0])\n    }\n  } else if( !world.multiplayer || world.name == 'sync' ){\n    actions.emit('opponentPaddleHit'); // used by AI\n    dmaf.tell('opponent_paddle_hit');\n  }\n\n  actions.emit('renderer','paddleHit',{player: player, velocity: puck.velocity})\n  actions.puckBounced(world,puck)\n}\n\n/**\n * Resizes the paddle to a set scale.\n *\n * Scale is an \"absolute\" scale. In other words resizing\n * to 1.25 twice will not make a difference.\n *\n * @param  {World} world\n * @param  {Body} paddle\n * @param  {Number} scale  ex. .5 = 50%, 1.5 = 150%, 1 = 100%\n */\nexports.resizePaddle = function(world,paddleIndex,scale){\n  // keep what was sent in (store as resized below)\n  var size = scale;\n\n  // get paddle\n  var paddle = world.paddles.get(paddleIndex);\n\n  // it was previously resized. scale it back first\n  // so there'll only be 3 sizes.\n  //\n  // original size: 50\n  // scale 1: 1.5\n  // = 50 * 1.5 = 75\n  // scale 2: .5\n  // = 75 * .5 = 37.5 = FAIL!\n  // = 75 * 1 / 1.5 * .5 = 25 = WIN!\n  if( paddle.data.resized ){\n    size = 1/paddle.data.resized * scale;\n  }\n\n  // scale using a transformation matrix\n  var c = paddle.current;\n  var w = paddle.aabb[1] - paddle.aabb[3];\n  var m = mat.make()\n  mat.translate(-c[0],0,m)\n  mat.scale(size,1,m)\n  mat.translate(c[0],0,m)\n  poly.transform(paddle.shape,m)\n  poly.aabb(paddle.shape,paddle.aabb)\n  paddle.radius = poly.radius(paddle.shape,c)\n  mat.free(m);\n\n  if( scale !== 1 ){\n    paddle.data.resized = scale;\n  } else {\n    delete paddle.data.resized;\n  }\n}\n\nexports.movePaddle = function(world,paddleIndex,dx){\n  // sometimes the paddles doesn't exist because the\n  // input is received after the reset/game over\n  if( !world.paddles.has(paddleIndex) )\n    return;\n\n  var paddle = world.paddles.get(paddleIndex);\n\n  // p.current[0] += dx;\n\n  // Trying to use acceleration instead. The idea\n  // is that updating at a lower degree may give\n  // a smoother effect after a replay. Because the\n  // acceleration will be added a bunch of times\n  // while the position will be updated afterwards.\n  paddle.acceleration[0] += dx/settings.data.timestep;\n}\n\nexports.paddleShoot = function(world,paddleIndex){\n  debug('%s paddle shoot', world.name, paddleIndex)\n  var paddle = world.paddles.get(paddleIndex);\n  dmaf.tell('laser_fire');\n  actions.createBullet(world,paddle);\n}\n\nexports.dizzyPaddle = function(world,paddleIndex){\n  debug('%s dizzy paddle', world.name, paddleIndex)\n  var paddle = world.paddles.get(paddleIndex);\n  paddle.data.dizzyTimes = 0;\n  world.tick.clearInterval(paddle.data.dizzyInterval)\n  paddle.data.dizzyInterval = world.tick.setInterval('dizzyToggleDirection',100,paddleIndex)\n  dmaf.tell('paddle_dizzy');\n}\n\nexports.dizzyToggleDirection = function(world,paddleIndex){\n  var paddle = world.paddles.get(paddleIndex);\n\n  paddle.data.dizzyDirection = paddle.data.dizzyDirection || 1;\n  paddle.data.dizzyDirection *= -1;\n  actions.movePaddle(world,paddle.index,paddle.data.dizzyDirection*12);\n\n  if( ++paddle.data.dizzyTimes > 15 ){\n    world.tick.clearInterval(paddle.data.dizzyInterval)\n  }\n}\n\nexports.resetPaddleExtra = function(world,paddleIndex,extraType) {\n  debug('%s reset paddle extra', world.name, paddleIndex, extraType)\n  var paddle = world.paddles.get(paddleIndex);\n  if( paddle && paddle.data.hasOwnProperty(extraType)) {\n    paddle.data[extraType] = 0;\n  }\n}\n//@ sourceURL=slam/lib/actions/paddle.js"
));
require.register("slam/lib/actions/puck.js", Function("exports, require, module",
"var debug = require('debug')('actions:puck')\n  , actions = require('../actions')\n  , settings = require('../settings')\n  , BodyFlags = require('../sim/body-flags')\n  , shapes = require('../sim/shapes')\n  , icons = require('../extra-icons')\n  , colliding = require('../support/aabb').colliding\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec\n  , dmaf = require('../dmaf.min');\n\n\nexports.createPuckCenter = function(world){\n  // add to center of arena\n  var x = settings.data.arenaWidth/2\n    , y = settings.data.arenaHeight/2\n    , mass = 5\n    , p = actions.createPuck(world,x,y,mass);\n\n  // always start with 0 \"bounces\"\n  var speed = actions.getPuckSpeed(world,p)\n  speed *= settings.data.unitSpeed;\n\n  // start it off with a push\n  actions.puckSpeedXY(world, p, 0, speed)\n}\n\nexports.createPuck = function(world, x, y, mass, flags){\n  debug('%s create %s,%s %s',world.name, x, y, mass, flags)\n  var w = settings.data.unitSize\n    , h = w // square\n    , p = world.createBody(shapes.rect(w,h), x, y, flags || (BodyFlags.DYNAMIC | BodyFlags.BOUNCE))\n  p.id = 'puck' // for debugging mostly\n\n  // set a puck bounce counter\n  // TODO move to p.data.bounces?\n  world.puckBounces[p.index] = 0;\n  world.pucks.set(p.index,p);\n  actions.emit('added','puck',world,p);\n  return p;\n}\n\nexports.puckSpeed = function(world, p, s){\n  debug('%s speed (current direction) [%s]',world.name ,p.index, s)\n\n  // it's probably a special case like:\n  // \"hit the end and the paddle in the same frame\"\n  // where one action will remove it and the other\n  // set the speed. but warn just in case.\n  if( !world.pucks.has(p.index) ){\n    return console.warn('cannot set puck speed, does not exist yet');\n  }\n\n  // s = multiplier of unit speed (ex. speed*speedup^bounces)\n\n  // only a speed (in the current direction)\n  var v = vec.sub(p.current,p.previous)\n  vec.norm(v,v)\n  vec.smul(v,s*settings.data.unitSpeed,v)\n  vec.sub(p.current,v,p.previous)\n  vec.free(v)\n}\n\nexports.getPuckSpeed = function(world,puck){\n  // add some extra power to each hit\n  // unit * (speed+speedup*bounces)\n  // 20 * (1+0) > 20 * (1+.2) > 20 * (1+.4)\n  // ex. 20 > 20 * 1.2 > 20 * 1.4 > ... > 20 * 4\n  var level = world.level.puck.speed\n    , speedup = world.level.puck.speedup\n    , maxspeed = world.level.puck.maxspeed\n    , bounces = world.puckBounces[puck.index];\n\n  return Math.min(level + speedup*bounces, maxspeed);\n}\n\nexports.puckSpeedMomentum = function(world, p, s, m){\n  debug('%s speed (w. momentum) [%s]',world.name ,p.index, s, m)\n\n  // see puckSpeed()\n  if( !world.pucks.has(p.index) ){\n    return console.warn('cannot set puck speed, does not exist yet');\n  }\n\n  // add extra speed and damp until the speed is\n  // back to normal\n  if( settings.data.speedupMomentum && Math.abs(m[0]) > 1 ){\n    // moment as scalar\n    var ms = Math.min(vec.len(m), settings.data.unitSpeed);\n\n    p.dampUntil = s*settings.data.unitSpeed;\n    p.damping = 0.97;\n\n    s += ms/8;\n  }\n\n  // only a speed (in the current direction)\n  var v = vec.sub(p.current,p.previous)\n\n  // momentum changes direction\n  if( settings.data.directionMomentum ){\n    vec.add(v,m,v)\n  }\n\n  vec.norm(v,v)\n  vec.smul(v,s*settings.data.unitSpeed,v)\n  vec.sub(p.current,v,p.previous)\n  vec.copy(v,p.velocity)\n  vec.free(v)\n}\n\nexports.puckSpeedXY = function(world, p, x, y){\n  debug('%s speed [%s]',world.name , p.index, x, y)\n\n  // see puckSpeed()\n  if( !world.pucks.has(p.index) ){\n    return console.warn('cannot set puck speed, does not exist yet');\n  }\n\n  // set a speed and direction\n  var v = vec.make(x,y)\n  vec.sub(p.current,v,p.previous)\n  vec.copy(v,p.velocity)\n  vec.free(v)\n}\n\nexports.puckCheckMinSpeed = function(world, p){\n  debug('check speed',p.index)\n\n  // skip if it has been removed\n  // (like when this is called from Bound.puck)\n  if( p.removed ){\n    return;\n  }\n\n\n  // make sure it has a minimum y-velocity so the\n  // game doesn't get stuck.\n  var minY = settings.data.minYSpeed;\n  if( Math.abs(p.velocity[1]) < minY ){\n    // correct the sign\n    minY = p.velocity[1] > 0 ? minY : -minY;\n\n    // apply speed\n    actions.puckSpeedXY(world,p,p.velocity[0],minY);\n  }\n\n  // also make sure it has a minimum velocity (unitSpeed)\n  // in any direction so force fields et al won't ruin the\n  // fun.\n  // using a calculated velocity since p.velocity may be outdated\n  var speed = vec.dist(p.current,p.previous) / settings.data.unitSpeed;\n  var minSpeed = 1;\n  if( speed < minSpeed ){\n    debug('puck was below min speed %s now at a comfortable %s',speed,minSpeed)\n    actions.puckSpeed(world,p,minSpeed);\n  }\n}\n\nexports.puckCheckMaxSpeed = function(world, p){\n  debug('check speed',p.index)\n\n  // skip if it has been removed\n  // (like when this is called from Bound.puck)\n  if( p.removed ){\n    return;\n  }\n\n  var speed = vec.dist(p.current,p.previous) / settings.data.unitSpeed;\n  var maxSpeed = world.level.puck.maxspeed + world.level.puck.maxspeed*0.5*(p.data.fireball==1);\n  if( speed > maxSpeed && !p.dampUntil ){\n    debug('puck was above max speed %s now at a comfortable %s',speed,maxSpeed)\n    actions.puckSpeed(world,p,maxSpeed);\n\n    // if extreme debug!\n    if( speed > maxSpeed * 10 ){\n      throw new Error('puck is extremely fast. must be a bug. investigate!');\n    }\n  }\n}\n\nexports.puckCheckSpeedAll = function(world, p){\n  for(var i=0; i < world.pucks.length; i++){\n    actions.puckCheckMinSpeed(world, world.pucks.values[i]);\n    actions.puckCheckMaxSpeed(world, world.pucks.values[i]);\n  }\n}\n\nexports.destroyPuck = function(world, puck){\n  debug('%s destroy',world.name ,puck.index);\n  delete world.lastHitPucks[puck.index];\n  delete world.puckBounces[puck.index];\n  world.pucks.del(puck.index)\n  world.releaseBody(puck)\n  actions.emit('removed','puck',world,puck);\n}\n\nexports.puckBounced = function(world,puck) {\n  actions.emit('renderer','puckBounce',{puck: puck});\n\n  //console.log('%s puck bounced angle: %s speed: %s',world.name,(Math.atan2(puck.velocity[1],puck.velocity[0])*180/Math.PI).toFixed(4),vec.len(puck.velocity))\n\n  // after the hit, and if it's still alive, we\n  // make sure it has a minimum y-velocity so the\n  // game doesn't get stuck.\n  actions.puckCheckMinSpeed(world,puck)\n}\n\nexports.puckToggleHit = function(world,puckIndex,hit){\n  var puck = world.pucks.get(puckIndex);\n  puck.data.hitShield = hit;\n}\n\nexports.puckToggleGhostball = function(world,puckIndex,extraIndex){\n  var puck = world.pucks.get(puckIndex);\n  if( puck.data.ghostball ){\n    puck.data.ghostball = 2;\n    dmaf.tell('ghostball_over');\n    icons.remove(world,extraIndex);\n    delete puck.data.ghostballTimeout;\n    world.tick.nextFrame('resetPuckExtra',puck.index,'ghostball')\n    puck.data.ghostIcon = extraIndex;\n  } else {\n    puck.data.ghostball = 1;\n    icons.activate(world,extraIndex);\n    delete puck.data.ghostIcon;\n  }\n}\n\nexports.puckToggleGhostFlag = function(world,puckIndex,active){\n  var puck = world.pucks.get(puckIndex);\n  if( active ){\n    debug('puck GHOST ADD %s %s %s',world.name,world.frame,puck.index)\n    BodyFlags.add(puck,BodyFlags.GHOST);\n  } else {\n    // if it's colliding when GHOST wears off\n    // wait a try again next frame\n    if( colliding(world,puck) ){\n      debug('puck was colliding when GHOST wore off. trying again next frame.')\n      return world.tick.nextFrame('puckToggleGhostFlag',puckIndex);\n    }\n    BodyFlags.del(puck,BodyFlags.GHOST)\n    debug('puck GHOST DEL %s %s %s',world.name,world.frame,puck.index)\n  }\n}\n\nexports.puckTimebombExplode = function(world,puckIndex,extraIndex,radius){\n  var puck = world.pucks.get(puckIndex);\n\n  // visual and audial boom!\n  puck.data.timebomb = 2;\n  dmaf.tell('timebomb_over');\n  world.tick.nextFrame('resetPuckExtra',puck.index,'timebomb')\n  icons.remove(world,extraIndex);\n  delete puck.data.bombTimeout;\n\n  // query which shields are within radius\n  // and destroy them!\n  var radSq = radius*radius\n    , destroyed = [];\n  for(var i=0; i<world.shields.length;i++){\n    var shield = world.shields.values[i];\n    var distSq = vec.distSq(puck.current,shield.current)\n    if( distSq < radSq ){\n      // no good to destroy within loop because\n      // stashes are unordered\n      shield.data.blownAway = 1;\n      destroyed.push(shield);\n    }\n  }\n  while( destroyed.length ){\n    actions.destroyShield(world,destroyed.pop());\n  }\n}\n\nexports.resetPuckExtra = function(world,puckIndex,extraType) {\n  var puck = world.pucks.get(puckIndex);\n  if( puck && puck.data.hasOwnProperty(extraType)) {\n    puck.data[extraType] = 0;\n  }\n}\n//@ sourceURL=slam/lib/actions/puck.js"
));
require.register("slam/lib/actions/game.js", Function("exports, require, module",
"var debug = require('debug')('actions:game')\n  , actions = require('../actions')\n  , see = require('../support/see')\n  , icons = require('../extra-icons')\n  , see = require('../support/see');\n\nexports.gameToggleDeathball = function(world, active){\n  if( active ){\n    dmaf.tell( \"deathball_activate\");\n    icons.activate(world, 'deathball')\n  } else {\n    dmaf.tell( \"deathball_over\");\n    icons.remove(world, 'deathball')\n  }\n  actions.emit('renderer','toggleDeathball',{active:active})\n}\n\nexports.gameDeathballOver = function(world,puckIndex){\n  var playerID = world.lastHitPucks[puckIndex];\n  dmaf.tell( \"deathball_over\");\n  icons.remove(world, 'deathball')\n  actions.playerHit(world,player,puck)\n}\n\nexports.gameToggleFog = function(world, active){\n  actions.emit('renderer','toggleFog',{active:active})\n\n  if( active ){\n    icons.activate(world, 'fog')\n  } else {\n    dmaf.tell('fog_over');\n    icons.remove(world, 'fog')\n    delete world.timeouts.fog;\n  }\n}\n\nexports.roundOver = function(world, hitPlayerIndex, hitPuckPosition){\n  debug('%s round over',world.name)\n\n  var player = hitPlayerIndex === 0\n              ? world.players.a\n              : world.players.b;\n\n  if( !world.multiplayer || (world.name == 'sync' || player === world.me ) ){\n\n    // mark who was last hit\n    player.hit = hitPuckPosition || .5;\n    // console.log('\\n\\n\\nHIT!!! %s\\n\\n\\n',world.name,hitPlayerIndex,hitPuckPosition)\n\n    // show a distortion effect\n    // TODO somehow get a hold of the position of the killing puck\n    if( world.opponent.hit != -1 ){\n      debug('hit opponent?')\n      actions.emit('renderer','hitOpponent',{point: player.hit})\n      dmaf.tell('opponent_score_hit')\n\n    } else if( world.me.hit != -1 ){\n      debug('hit me?')\n      actions.emit('renderer','hitMe')\n      dmaf.tell('user_score_hit')\n    }\n\n    see('/game/next')\n  }\n}\n//@ sourceURL=slam/lib/actions/game.js"
));
require.register("slam/lib/actions/extra.js", Function("exports, require, module",
"var debug = require('debug')('actions:extra')\n  , settings = require('../settings')\n  , BodyFlags = require('../sim/body-flags')\n  , World = require('../world')\n  , shapes = require('../sim/shapes')\n  , icons = require('../extra-icons')\n  , colliding = require('../support/aabb').colliding\n  , actions = require('./')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec\n  , dmaf = require('../dmaf.min');\n\n/**\n *\n * IDs and descriptions of extras:\n *\n *   'paddleresize' (level 1)\n *       big=125%, small=75% (random)\n *\n *   'extralife' (level 2)\n *       one shield gets regenerated\n *\n *   'fog' (level 3)\n *       covers the opponents side of the field\n *       for X seconds\n *\n *   'multiball' (level 4)\n *       split ball up into X balls for Y seconds\n *       (or until it hits a shield/player)\n *       maybe start w. GHOST-flag for 5 frames to\n *       avoid instant collision?\n *\n *   'fireball' (level 5)\n *       removes items (other pucks and not\n *       picked up extras) in the way. makes\n *       hit paddle dizzy ()\n *\n *   'ghostball' (level 6)\n *       ball becomes barely visible for X\n *       seconds (or until it hits a\n *       shield/player), only when it hits something\n *\n *   'bulletproof' (level 7)\n *       a shield partition becomes unbreakable\n *       for X seconds\n *\n *   'mirroredcontrols' (level 8)\n *       controls get inverted\n *\n *   'laser' (level 9)\n *       auto shoots a laser that if hit player\n *       paddle shrinks it\n *\n *   'timebomb' (level 10)\n *       ball explodes after X seconds which removes\n *       items and shrinks paddles within Y radius.\n *       puck then restarts from middle.\n *\n *   'random' (level 11)\n *       any of the available extras\n *\n *   'deathball'\n *       bad assery\n *\n **/\n\n/**\n * Creates one of the availabe extras at one of the\n * designated positions.\n *\n * @param  {World} world\n * @param  {Object} level\n * @return the created extra\n */\nexports.createRandomExtra = function(world){\n  debug('%s create random',world.name);\n  var src = settings.data.overrideSpawnExtras\n          ? settings.getSpawnlist()\n          : world.level.extras;\n\n  // filter out extras which should not be available\n  // in this round.\n  var round = world.players.a.score + world.players.b.score + 1;\n  var arr = src.filter(function(e){\n    return !e.round || e.round <= round;\n  })\n\n  // no extras found to match this round\n  if( !arr.length ){\n    return;\n  }\n\n // if( world.extras.values.length >= world.level.simultaneousExtras)\n //   return;\n\n  // find an extra based on probability\n  var extra = prob(world,arr);\n  var positions = shuffle(world,world.level.positions);\n  var pos = extra.position || positions.pop();\n  var body = actions.createExtra(world,extra,pos.x,pos.y);\n\n  // this should be ok w. max 3 extras and a few pucks?\n  var n;\n  var x = pos.x, y = pos.y; // avoid updating the positions objects\n  while(colliding(world,body) && (n = positions.pop())){\n    poly.translate(body.shape, n.x-x, n.y-y);\n    poly.aabb(body.shape, body.aabb) // update aabb\n    body.current[0] = body.previous[0] = x = n.x;\n    body.current[1] = body.previous[1] = y = n.y;\n  }\n\n  if( colliding(world,body) ){\n    console.warn('still colliding after all positions, is there enough positions in the level?!')\n    console.log('body',body)\n    console.log('extra',extra)\n  }\n  actions.emit('added','extra',world,body);\n  return body;\n}\n\n/**\n * Creates an extra body \"pick-up\" in the arena that\n * can be hit by the puck.\n *\n * When hit `hitExtra` will be called.\n *\n * @param  {World} world\n * @param  {Object} data  The extra level data (ex. {id:'fog',duration:200})\n * @param  {Number} x\n * @param  {Number} y\n * @return {Body} the created extra pick-up.\n */\nexports.createExtra = function(world, data, x, y){\n  debug('%s create',world.name ,data.id);\n\n  if( !validExtra(data) ){\n    throw new Error('invalid extra: '+data.id)\n    return;\n  }\n\n  var shape = shapes.rect(settings.data.unitSize,settings.data.unitSize);\n  var extra = world.createBody(shape, x, y, BodyFlags.STATIC | BodyFlags.DESTROY | BodyFlags.GHOST)\n  extra.id = 'extra';\n  extra.data = data;\n  world.extras.set(extra.index,extra)\n  dmaf.tell( data.id + '_spawn');\n  icons.create(world, extra)\n\n  if( data.id == 'deathball') {\n    actions.gameToggleDeathball(world,true)\n    world.tick.clearTimeout(world.timeouts.deathballTimeout);\n    world.timeouts.deathballTimeout = world.tick.setTimeout('gameToggleDeathball',(data.duration || 5)*1000,false);\n  }\n\n  world.tick.setTimeout('resetExtraGhost',settings.data.extraGhostDuration,extra.index)\n\n  return extra;\n}\n\nexports.resetExtraGhost = function(world, extraIndex){\n  debug('reset ghost',extraIndex)\n  var extra = world.extras.get(extraIndex);\n  BodyFlags.del(extra,BodyFlags.GHOST);\n}\n\n/**\n * Called when an extra pick-up has been hit by\n * the puck.\n *\n * @param  {World} world\n * @param  {Body} puck\n * @param  {Body} extra\n */\nexports.hitPuckExtra = function(world, puck, extra){\n  debug('%s hit %s puck: %s',world.name ,extra.index,puck.index)\n\n  // skip if no player can be affected\n  if( !world.lastHitPucks[puck.index] ){\n    return;\n  }\n\n  // renderer effects\n  actions.emit('renderer','activateExtra',{puck:puck, extra: extra})\n\n  // remove extra (unlike obstacles, extras are removed)\n  actions.destroyExtra(world,extra)\n\n  var id = extra.data.id\n    , data = extra.data;\n\n  // random extra\n  if( id == 'random' ){\n    // \"random\" has no actual effect, remove it from available\n    var available = world.level.extras.filter(function(e){return e.id !== 'random'})\n    data = rand(world,available);\n    if( !data ){\n      console.warn('no extra found to use as random')\n      return\n    }\n    id = data.id;\n  }\n\n  dmaf.tell( id + '_activate');\n\n  var playerID = world.lastHitPucks[puck.index]\n    , player = world.players[playerID]\n    , paddle = world.paddles.get(player.paddle)\n\n  switch(id){\n\n    case 'extralife':\n      icons.remove(world,extra)\n      actions.regenerateShield(world,player)\n      break;\n\n    case 'ghostball':\n      var ghostDuration = (data.duration || 7)*1000;\n\n      // remove any old extra icons\n      if( puck.data.ghostIcon ){\n        icons.remove(world,puck.data.ghostIcon);\n        delete puck.data.resizeIcon;\n      }\n\n      actions.puckToggleGhostball(world,puck.index,extra.index)\n      world.tick.clearTimeout(puck.data.ghostballTimeout);\n      puck.data.ghostballTimeout = world.tick.setTimeout('puckToggleGhostball', ghostDuration, puck.index,extra.index)\n      break;\n\n    case 'fireball':\n      icons.remove(world,extra)\n\n      // mark the paddle as fireball\n      // to be transferred when a puck hits it\n      paddle.data.fireball = 1;\n      break;\n\n    case 'mirroredcontrols':\n      // mirror the controls\n      actions.emit('renderer','mirrorEffect',{active: true})\n      icons.activate(world,'mirroredcontrols')\n      break;\n\n    case 'bulletproof':\n      var bulletproofDuration = (data.duration || 7) * 1000;\n\n      // remove any old extra icons\n      if( world.timeouts.bulletproof ){\n        icons.remove(world,extra);\n        delete world.timeouts.bulletproof;\n      }\n\n      actions.playerToggleBulletproof(world,playerID,true);\n      world.tick.clearTimeout(world.timeouts.bulletproof);\n      world.timeouts.bulletproof = world.tick.setTimeout('playerToggleBulletproof', bulletproofDuration, playerID, false)\n      break;\n\n    case 'paddleresize':\n      var resizeDuration = (data.duration || 10) * 1000;\n\n      // remove any old extra icons\n      if( paddle.data.resizeIcon ){\n        icons.remove(world,paddle.data.resizeIcon);\n        delete paddle.data.resizeIcon;\n      }\n\n      actions.playerTogglePaddleResize(world,playerID,extra.index,true)\n      world.tick.clearTimeout(paddle.data.resizeTimeout);\n      paddle.data.resizeTimeout = world.tick.setTimeout('playerTogglePaddleResize',resizeDuration, playerID, extra.index, false);\n      break;\n\n    case 'deathball':\n      world.tick.nextFrame('gameDeathballOver',puck.index);\n      break;\n\n    case 'timebomb':\n      var radius = data.radius || settings.data.arenaHeight / 2;\n      if( !puck.data.timebomb ){\n        icons.activate(world,extra)\n      } else {\n        icons.remove(world,extra)\n      }\n      puck.data.timebomb = 1;\n      world.tick.clearTimeout(puck.data.bombTimeout);\n      puck.data.bombTimeout = world.tick.setTimeout('puckTimebombExplode', 4000, puck.index, extra.index, radius)\n      break;\n\n    case 'laser':\n      var laserDuration = (data.duration || 5)*1000;\n\n      // remove any old extra icons\n      if( world.timeouts.laserTimeout ){\n        icons.remove(world,extra);\n        dmaf.tell('laser_over');\n      }\n\n      // only one laser at the time\n      // if( world.timeouts.laserTimeout ) {\n      var a = world.paddles.get(world.players.a.paddle);\n      var b = world.paddles.get(world.players.b.paddle);\n      if( a.data.laser == 1 ){ a.data.laser = 2; }\n      if( b.data.laser == 1 ){ b.data.laser = 2; }\n      // }\n\n      actions.playerToggleLaser(world,playerID,true)\n      world.tick.clearTimeout(world.timeouts.laserTimeout)\n      world.timeouts.laserTimeout = world.tick.setTimeout('playerToggleLaser',laserDuration,playerID,false);\n      break;\n\n    case 'fog':\n      var fogDuration = (data.duration || 5)*1000;\n      if( world.timeouts.fog ){\n        icons.remove(world, extra);\n        delete world.timeouts.fog;\n      }\n      actions.gameToggleFog(world,true)\n      world.tick.clearTimeout(world.timeouts.fog);\n      world.timeouts.fog = world.tick.setTimeout('gameToggleFog',fogDuration,false)\n      break;\n\n    case 'multiball':\n      // create a new puck\n      var x = data.x || settings.data.arenaWidth / 2\n        , y = data.y || settings.data.arenaHeight / 2\n        , n = actions.createPuck(world,x,y,puck.mass);\n\n      // copy the last hit\n      world.lastHitPucks[n.index] = world.lastHitPucks[puck.index];\n\n      // make the new puck a ghost for a few frames\n      // to avoid collisions\n      actions.puckToggleGhostFlag(world,n.index,true)\n      world.tick.clearTimeout(puck.data.ghostTimeout);\n      puck.data.ghostTimeout = world.tick.setTimeout('puckToggleGhostFlag',200,n.index,false)\n\n      // push the new puck in one direction and the old one\n      // in the opposite.\n      var speed = puck.velocity[1] < 0\n                ?  settings.data.unitSpeed\n                : -settings.data.unitSpeed;\n      actions.puckSpeedXY(world, n, 0, speed)\n\n      icons.activate(world,extra)\n      break;\n  }\n}\n\nexports.destroyExtra = function(world, extra){\n  debug('%s destroy',world.name ,extra.index);\n  world.extras.del(extra.index)\n  world.releaseBody(extra)\n  actions.emit('removed','extra',world,extra);\n  dmaf.tell( extra.data.id + '_remove');\n}\n\nexports.destroyFirstExtra = function(world){\n  // find out which is the first extra\n  // (i guess the one with the lowest index?)\n  var extra\n    , index = Infinity;\n  for(var i=0; i < world.extras.length; i++){\n    var e = world.extras.values[i];\n    if( !e.removed && e.index < index ){\n      index = e.index;\n      extra = e;\n    }\n  }\n  debug('%s destroy first',world.name ,index);\n  if( extra ){\n    icons.remove(world,index)\n    actions.destroyExtra(world, extra)\n    world.destroyBody(extra)\n  } else {\n    console.error('no extra found?!');\n  }\n}\n\nfunction validExtra(data){\n  // TODO validate the options\n  switch(data.id){\n    case 'fog':\n    case 'fireball':\n    case 'ghostball':\n    case 'extralife':\n    case 'multiball':\n    case 'bulletproof':\n    case 'mirroredcontrols':\n    case 'deathball':\n    case 'paddleresize':\n    case 'timebomb':\n    case 'laser':\n    case 'random':\n      return true;\n  }\n  return false;\n}\n\nfunction prob(world,available){\n  var d = settings.data.defaultProbability\n    , t = available.reduce(function(t,e){return t+(e.probability || d)},0)\n    , x = world.random() * t\n    , p = 0;\n  for(var i=0;i<available.length; i++){\n    var e = available[i]\n      , n = p + (e.probability || d);\n    if( x >= p && x < n ){\n      return e;\n    }\n    p = n;\n  }\n  throw new Error('no extra found. whut?')\n  return null;\n}\n\nfunction rand(world,arr){\n  return arr[Math.round(world.random()*arr.length-0.5)]\n}\n\nfunction shuffle(world,arr){\n  var array = arr.concat();\n  var tmp, current, top = array.length;\n\n  if(top){\n    while(--top) {\n      current = Math.floor(world.random() * (top + 1));\n      tmp = array[current];\n      array[current] = array[top];\n      array[top] = tmp;\n    }\n  }\n\n  return array;\n}//@ sourceURL=slam/lib/actions/extra.js"
));
require.register("slam/lib/actions/obstacle.js", Function("exports, require, module",
"var debug = require('debug')('actions:obstacle')\n  , settings = require('../settings')\n  , BodyFlags = require('../sim/body-flags')\n  , shapes = require('../sim/shapes')\n  , colliding = require('../support/aabb').colliding\n  , actions = require('./')\n  , geom = require('geom')\n  , poly = geom.poly\n  , vec = geom.vec\n  , dmaf = require('../dmaf.min');\n\nexports.createNextObstacle = function(world){\n  debug('%s create next',world.name);\n\n  // first test that the shape (aabb) of the body\n  // will not collide\n  var obstacle = world.level.obstacles[world.obstacles.length];\n\n  if( !obstacle ){\n    return null;\n  }\n\n  var shape = getObstacleShape(obstacle);\n  poly.translate(shape,obstacle.x,obstacle.y,shape);\n  var fake = { aabb: poly.aabb(shape), id: 'obstacle' };\n  if( colliding(world,fake) ){\n    return debug('colliding obstacle. trying again next frame.',fake)\n  }\n\n  var flags = BodyFlags.STATIC | BodyFlags.BOUNCE;\n  if( obstacle.destroyable ){\n    flags |= BodyFlags.DESTROY;\n  }\n\n  // now we can create the obstacle\n  return actions.createObstacle(world,obstacle.id,obstacle.x,obstacle.y,flags,shape);\n}\n\nexports.createObstacle = function(world,id,x,y,flags,shape){\n  debug('%s create',world.name ,id,x,y);\n\n  var body\n    , shape = shape || getObstacleShape(id)\n    , flags = flags || BodyFlags.STATIC | BodyFlags.BOUNCE;\n\n  if( shape ){\n    body = world.createBody(shape,x,y,flags)\n    body.id = 'obstacle';\n    body.data.id = id;\n    world.obstacles.set(body.index,body)\n    actions.emit('added','obstacle',world,body);\n  }\n  return body;\n}\n\nexports.destroyObstacle = function(world,obstacle){\n  debug('%s destroy',world.name ,obstacle.index);\n\n  world.obstacles.del(obstacle.index)\n  world.releaseBody(obstacle)\n  actions.emit('removed','obstacle',world,obstacle);\n\n}\n\nexports.hitPuckObstacle = function(world,puck,obstacle){\n\n  if( obstacle.data.regenerate ) {\n    actions.emit('hide','obstacle',world,obstacle);\n    actions.hideObstacle(world,obstacle)\n  }\n  else {\n    if(BodyFlags.has(obstacle,BodyFlags.DESTROY)){\n      actions.destroyObstacle(world,obstacle)\n    }\n  }\n\n  dmaf.tell('obstacle_hit');\n\n  actions.puckBounced(world,puck)\n}\n\nfunction getObstacleShape(obstacle){\n  var size = obstacle.size;\n  switch(obstacle.id || obstacle){\n    case 'triangle-left':\n      return shapes.triangle(settings.data.unitSize*(size && size[0]||3),settings.data.unitSize*(size && size[1]||4),true)\n    case 'triangle-right':\n      return shapes.triangle(settings.data.unitSize*(size && size[0]||3),settings.data.unitSize*(size && size[1]||4),false)\n    case 'triangle-top':\n      return shapes.triangle(settings.data.unitSize*(size && size[0]||3),settings.data.unitSize*(size && size[1]||4),false,true)\n    case 'triangle-bottom':\n      return shapes.triangle(settings.data.unitSize*(size && size[0]||3),settings.data.unitSize*(size && size[1]||4),true,true)\n    case 'diamond':\n      return shapes.diamond(settings.data.unitSize*(size||4))\n    case 'hexagon':\n      return shapes.hex(settings.data.unitSize*(size||3))\n    case 'octagon':\n      return shapes.oct(settings.data.unitSize*(size||8))\n    case 'block-breakout':\n      return shapes.rect(settings.data.unitSize,settings.data.unitSize);\n    case 'block-rect':\n      return shapes.rect(settings.data.unitSize*(size && size[0]||1),settings.data.unitSize*(size && size[1]||1));\n    default:\n      throw new Error('unsupported obstacle: '+obstacle.id)\n  }\n}\n//@ sourceURL=slam/lib/actions/obstacle.js"
));
require.register("slam/lib/actions/force.js", Function("exports, require, module",
"var debug = require('debug')('actions:force')\n  , settings = require('../settings')\n  , actions = require('./')\n  , dmaf = require('../dmaf.min')\n  , Force = require('../sim/force');\n\nexports.createNextForce = function(world){\n  debug('%s create next', world.name);\n\n  var force = world.level.forces[world.forces.length];\n  if( !force ){\n    return null;\n  }\n\n  // now we can create the force\n  return actions.createForce(world,force.type,force.x,force.y,force.mass || 10);\n}\n\nexports.createForce = function(world,type, x, y, mass){\n  debug('%s create', world.name, type, x, y, mass)\n\n  if( !mass )\n    throw new Error('cannot create a force without a mass')\n\n  switch(type){\n    case 'repell':\n    case 'attract':\n      var force = new Force(type, x, y, mass, 1)\n      force.index = world.index++;\n      if( settings.data.forcesInterval > 0 ){\n        force.interval = world.tick.setInterval('toggleForce',settings.data.forcesInterval,force.index);\n      } else {\n        force.active = true;\n      }\n      world.forces.set(force.index,force);\n      actions.emit('added','force',world,force);\n      break;\n    default:\n      throw new Error('invalid force kind');\n  }\n}\n\n\nexports.toggleForce = function(world,forceIndex){\n  var force = world.forces.get(forceIndex);\n  force.active = !force.active;\n  dmaf.tell('force_' + (force.active ? 'show' : 'hide') );\n\n  // run checkPuckSpeed on all pucks to keep\n  // them in check\n  if( !force.active ){\n    actions.puckCheckSpeedAll(world);\n  }\n}\n\nexports.destroyForce = function(world,force){\n  debug('%s destroy',force)\n  world.forces.del(force.index);\n  world.tick.clearInterval(force.interval);\n  actions.emit('removed','force',world,force);\n}//@ sourceURL=slam/lib/actions/force.js"
));
require.register("slam/lib/actions/debug.js", Function("exports, require, module",
"var debug = require('debug')('actions:debug')\n  , diff = require('../support/diff')\n  , inspect = require('../support/inspect')\n\nexports.debugDiff = function(world, remoteState){\n  var remoteState = remoteState && remoteState.replace(/\\\\n/g,'\\n')\n  var localState;\n\n  // temporary remove some uninteresting references\n  var ignore = [\n    'me',\n    'opponent',\n    'host',\n    'players.a.paddle',\n    'players.b.paddle',\n\n    // these will all be in bodies too\n    'pucks',\n    'paddles',\n    'extras',\n    'obstacles',\n    'forces',\n    'bullets',\n\n    // these are only in the renderer\n    'added',\n    'removed'\n  ]\n  exclude(world,ignore,function(world){\n    localState = inspect(world,{depth:Infinity});\n  })\n\n  // received a state from other player\n  if( remoteState ){\n    console.log('got a remote state')\n    console.log(diff.createPatch('diff',remoteState,localState,'remote','local ' + world.frame))\n\n  // sending state reliably to other player\n  } else {\n    console.log('sending debug diff! %d ',world.frame)\n  }\n  return localState;\n}\n\n\n\n\n// temporary excludes properties in `obj` defined in `excluded`\n// calls fn with the obj and then adds the properties back after\n// the callback.\nfunction exclude(obj,excluded,fn){\n  var map = {}\n  excluded.forEach(function(prop){\n    var props = prop.split('.');\n    var tmp = obj;\n    for (var i = 0; i < props.length; ++i) {\n      var name = props[i];\n      if( i == props.length-1 ){\n        map[prop] = tmp[name]\n        delete tmp[name]\n      } else {\n        tmp = tmp[name];\n      }\n    }\n  })\n  fn(obj)\n  Object.keys(map).forEach(function(prop){\n    var props = prop.split('.');\n    var tmp = obj;\n    for (var i = 0; i < props.length; ++i) {\n      var name = props[i];\n      if( i == props.length-1 ){\n        tmp[name] = map[prop];\n      } else {\n        tmp = tmp[name];\n      }\n    }\n  })\n}\n//@ sourceURL=slam/lib/actions/debug.js"
));
require.register("slam/lib/actions/player.js", Function("exports, require, module",
"var debug = require('debug')('actions:player')\n  , settings = require('../settings')\n  , inputs = require('../inputs')\n  , actions = require('../actions')\n  , icons = require('../extra-icons')\n  , dmaf = require('../dmaf.min');\n\nexports.playerToggleBulletproof = function(world,playerID,active){\n  var player = world.players[playerID]\n    , paddle = world.paddles.get(player.paddle);\n\n  // find available shields\n  for(var i=0; i<world.shields.length; i++){\n    var shield = world.shields.values[i];\n\n    // make sure shield belongs to player\n    if( shield.data.player !== playerID ){\n      shield.data.bulletproof = 0; // or make sure they're off\n      continue;\n    }\n\n    // shield must be \"up\"\n    if( player.shields[shield.data.index] === 0 ){\n      continue;\n    }\n\n    // toggle bulletproof on\n    if( active && !shield.data.bulletproof ){\n      shield.data.bulletproof = 1;\n    }\n\n    // toggle bulletproof off\n    if( !active && shield.data.bulletproof ){\n      shield.data.bulletproof = 0;\n    }\n  }\n\n  if( active ){\n    icons.activate(world,'bulletproof');\n  } else {\n    icons.remove(world,'bulletproof');\n    delete world.timeouts.bulletproof;\n  }\n}\n\nexports.playerTogglePaddleResize = function(world,playerID,extraIndex,active){\n  var player = world.players[playerID]\n    , paddle = world.paddles.get(player.paddle);\n\n  if( active ){\n    actions.resizePaddle(world,player.paddle,1.75);\n    icons.activate(world,extraIndex)\n    paddle.data.resizeIcon = extraIndex;\n\n  } else {\n    actions.resizePaddle(world,player.paddle,1.0);\n    icons.remove(world,extraIndex);\n    delete paddle.data.resizeIcon;\n    delete paddle.data.resizeTimeout;\n  }\n\n  actions.emit('renderer','paddleResize',{\n    playerID: playerID,\n    width: paddle.aabb[1] - paddle.aabb[3]\n  })\n}\n\nexports.playerToggleLaser = function(world,playerID,active){\n  var player = world.players[playerID]\n    , paddle = world.paddles.get(player.paddle)\n    , interval = 1000; // TODO use the extra.data.interval\n\n    console.log('playrToggleLaser', playerID, active)\n\n  if( active ){\n    // mark it as a laser paddle\n    paddle.data.laser = 1;\n    icons.activate(world,'laser')\n\n    // shoot bullets at an interval\n    world.tick.clearInterval(world.timeouts.laserInterval)\n    world.timeouts.laserInterval = world.tick.setInterval('paddleShoot', interval, player.paddle)\n\n  } else {\n    world.tick.clearInterval(world.timeouts.laserInterval)\n    dmaf.tell('laser_over');\n    icons.remove(world,'laser');\n    delete world.timeouts.laserTimeout;\n    paddle.data.laser = 2;\n    world.tick.nextFrame('resetPaddleExtra',player.paddle,'laser')\n  }\n}\n\nexports.playerHit = function(world,player,puck){\n  debug('%s hit',world.name ,player,puck.index)\n\n  // only send HIT if it was me who was hit in multiplayer\n  // otherwise send it everytime. (AI sucks at networking)\n  if( !world.multiplayer || (world.name == 'game' && player == world.me) ){\n    var index = player === world.players.a ? 0 : 1;\n    var x = puck.current[0]/settings.data.arenaWidth;\n    inputs.record(inputs.types.DIED,index,x)\n  }\n\n}//@ sourceURL=slam/lib/actions/player.js"
));
require.register("slam/lib/actions/shields.js", Function("exports, require, module",
"var debug = require('debug')('actions:shields')\n  , settings = require('../settings')\n  , shapes = require('../sim/shapes')\n  , BodyFlags = require('../sim/body-flags')\n  , actions = require('../actions')\n  , inputs = require('../inputs')\n  , dmaf = require('../dmaf.min');\n\nexports.createShields = function(world,player){\n  var shields = world.level && world.level.player\n              ? world.level.player.shields\n              : settings.data.defaultShields;\n\n  player.shields = makeArray(shields,1); // set to more than 1 for a stronger shield\n  for(var i=0,l=player.shields.length; i<l; i++){\n    actions.createShield(world,player,i,l);\n  }\n}\n\nexports.createShield = function(world,player,i,length){\n  debug('%s create',world.name ,player,i,length)\n\n  // creates a shield 1 unit deep and x units wide\n  var ah = settings.data.arenaHeight\n    , w = settings.data.arenaColumns/length * settings.data.unitSize-5\n    , h = settings.data.unitSize/8\n    , x = w * i + w/2 + 5*i\n    , y = (player === world.players.b ? h : ah-h)\n    , s = world.createBody(shapes.rect(w,h),x,y,BodyFlags.STATIC | BodyFlags.BOUNCE | BodyFlags.DESTROY)\n  s.id = 'shield' // used in collisions.js\n  s.data.player = player === world.players.a ? 'a' : 'b'; // (used by hitExtra)\n  s.data.index = i // index in player.shields (used by hitExtra)\n  world.shields.set(s.index,s)\n  actions.emit('added','shield',world,s)\n}\n\n\n// pick one shield of player w. 0 and reset it to 1 as\n// well as call createShield() again.\nexports.regenerateShield = function(world,player){\n  debug('%s regenerate',world.name ,player)\n  for(var i=0; i<player.shields.length; i++){\n    if( player.shields[i] === 0 ){\n      player.shields[i] = 1;\n      actions.createShield(world,player,i,player.shields.length);\n      break;\n    }\n  }\n}\n\nexports.hitPuckShield = function(world,puck,shield){\n  debug('%s hit', world.name, puck.index, shield.index)\n\n  var player = shield.data.player == 'a'\n    ? world.players.a\n    : world.players.b;\n\n  // skip if puck already hit a shield this frame\n  // this is to avoid two shields to get hit at\n  // once\n  if( puck.data.hitShield ){\n    debug('skipping hit shield because puck already hit a shield this frame')\n    return;\n  }\n\n  // flag the puck as \"hit shield\" for one frame\n  actions.puckToggleHit(world,puck.index,true)\n  world.tick.nextFrame('puckToggleHit',puck.index,false)\n\n  // make the puck a ghost for a few frames\n  // to avoid collisions\n  actions.puckToggleGhostFlag(world,puck.index,true)\n  world.tick.clearTimeout(puck.data.ghostTimeout);\n  puck.data.ghostTimeout = world.tick.setTimeout('puckToggleGhostFlag',400,puck.index,false)\n\n  // puck was fireball\n  if( puck.data.fireball ){\n    // set to 2 will trigger out-animation in renderer\n    puck.data.fireball = 2; // turn off\n\n    // reset the fireball flag next frame\n    world.tick.nextFrame('resetPuckExtra',puck.index,'fireball')\n    dmaf.tell(\"fireball_over\");\n  }\n\n  // send it as a MISS in multiplayer\n  if( world.multiplayer && world.name == 'game' ){\n    if( player !== world.opponent ){\n      var paddle = world.paddles.get(player.paddle);\n      inputs.record(inputs.types.MISS,paddle.current[0])\n    }\n  }\n\n  // shields also count as the 'last hit puck'\n  world.lastHitPucks[puck.index] = shield.data.player;\n\n  // make some noise!\n  if( player == world.opponent ){\n    dmaf.tell('opponent_shield_hit')\n  } else {\n    dmaf.tell('user_shield_hit')\n  }\n\n  // lower hit shield by 1 unless bullet proof\n  if( !shield.data.bulletproof ){\n    var v = Math.max(0, --player.shields[shield.data.index]);\n    // and if shield is fully down destroy it\n    if( v == 0 ){\n      exports.destroyShield(world,shield)\n    }\n  }\n\n  actions.puckBounced(world,puck)\n}\n\nexports.destroyShield = function(world,shield){\n  debug('%s destroy',world.name ,shield)\n\n  world.shields.del(shield.index)\n  world.releaseBody(shield)\n  actions.emit('removed','shield',world,shield)\n}\n\n\nfunction makeArray(len,v){\n  var a = [];\n  for(var i=0; i<len; i++)\n    a[i] = v;\n  return a;\n}//@ sourceURL=slam/lib/actions/shields.js"
));
require.register("slam/lib/renderer.js", Function("exports, require, module",
"/**\n * This is a Renderer front which will be a assigned a\n * renderer implementation like 2D, 3D or CSS.\n */\n\nvar debug = require('debug')('renderer');\n\nmodule.exports = Renderer;\n\nfunction Renderer(){\n  this.impl = null;\n}\n\nRenderer.prototype = {\n\n  set: function(r){\n    this.impl = r;\n  },\n\n  triggerEvent: function(id,opts){\n    debug('triggerEvent',id,opts)\n    if( !this.impl ) return;\n    this.impl.triggerEvent(id,opts)\n  },\n  changeView: function(state, callback){\n    debug('changeView',state)\n    if( !this.impl ) return;\n    this.impl.changeView(state,callback)\n  },\n  activePlayer: function(id,init,multiplayer){\n    debug('activePlayer',id,init,multiplayer)\n    if( !this.impl ) return;\n    this.impl.activePlayer(id,init,multiplayer)\n  },\n  reset: function(){\n    debug('reset')\n    if( !this.impl ) return;\n    this.impl.reset()\n  },\n  render: function(world,alpha){\n    if( !this.impl ) return;\n    this.impl.render(world,alpha)\n  }\n}//@ sourceURL=slam/lib/renderer.js"
));
require.register("slam/lib/renderer-2d.js", Function("exports, require, module",
"var draw = require('./support/draw')\n  , settings = require('./settings')\n  , poly = require('geom').poly;\n\nmodule.exports = Renderer;\n\nvar PADDLE_COLORS = ['#f00','#00f'];\n\nfunction Renderer(canvas){\n  this.canvas = canvas;\n  this.context = canvas.getContext('2d');\n  this.inverted = false;\n  this.stats = {}\n  this.bounds = [0,settings.data.arenaWidth,settings.data.arenaHeight,0];\n  this.draw = draw(this.context)\n  this.resize = true;\n}\n\nRenderer.prototype = {\n\n  constructor: Renderer,\n\n  reset: function(){},\n\n  triggerEvent: function(){},\n\n  changeView: function(){},\n\n  activePlayer: function(id){\n    this.inverted = id;\n    this.resize = true;\n  },\n\n  drawPaddle: function(ctx, paddle, style){\n    this.draw.poly(paddle.shape).stroke(style,3.5)\n    this.draw.line([paddle.previous,paddle.current]).stroke(style)\n    this.stats.paddles++;\n  },\n\n  drawBounds: function(ctx){\n    this.draw.rect(this.bounds).stroke('green')\n    this.stats.bounds++;\n  },\n\n  // Draw a gradient based on the type and mass of the force\n  drawForce: function(ctx, force){\n    if( !force.active ) return;\n    var x = force.position[0]\n      , y = force.position[1]\n      , r = force.radius;\n\n    // Create radial gradient\n    var grad = ctx.createRadialGradient(x,y,0,x,y,r);\n    switch(force.type){\n      case 'repell':\n        grad.addColorStop(0, 'rgba(255,0,0,1)');\n        grad.addColorStop(1, 'rgba(255,0,0,0)');\n        break;\n      case 'attract':\n        grad.addColorStop(0, 'rgba(0,255,0,1)');\n        grad.addColorStop(1, 'rgba(0,255,0,0)');\n        break;\n    }\n    ctx.fillStyle = grad;\n    ctx.fillRect(x-r,y-r,force.mass,force.mass)\n    this.stats.forces++;\n  },\n\n  drawBullet: function(ctx, bullet){\n    if( !bullet ) return;\n    this.draw.poly(bullet.shape).stroke('white')\n    this.stats.bullets++;\n  },\n\n  drawObstacle: function(ctx, obstacle){\n    ctx.fillStyle = 'pink'\n    this.draw.poly(obstacle.shape).stroke('pink')\n    this.stats.obstacles++;\n  },\n\n  drawShield: function(ctx, shield){\n    this.draw.poly(shield.shape).stroke('gray')\n    this.stats.shields++;\n  },\n\n  drawExtra: function(ctx, extra){\n    this.draw.poly(extra.shape).stroke('blue')\n    this.stats.extras++;\n  },\n\n  drawPuck: function(ctx, puck, index){\n    if( puck.removed ) return;\n    var color = index > 0 ? 'white' : 'yellow'\n    this.draw.poly(puck.shape).stroke(color)\n    this.draw.line([puck.previous,puck.current]).stroke(color)\n\n    // draw an offset \"shadow\"\n    if( puck.offset[0] || puck.offset[1] ){\n      poly.translate(puck.shape,puck.offset[0],puck.offset[1])\n      this.draw.poly(puck.shape).stroke('aqua')\n      poly.translate(puck.shape,-puck.offset[0],-puck.offset[1])\n    }\n\n    this.stats.pucks++;\n  },\n\n  drawInfo: function(ctx, world){\n    ctx.font = '1.5em courier'\n    ctx.fillStyle = 'black'\n    var t = ctx.measureText('0/0').width\n      , w = this.w\n      , h = this.h;\n    ctx.fillText('0/0',0,20)\n    ctx.fillText('1/0',w-t,20)\n    ctx.fillText('0/1',0,h)\n    ctx.fillText('1/1',w-t,h)\n\n    // draw a line every x steps\n    for( var x=0; x <= 1; x += .1){\n      // top\n      ctx.moveTo(x*w,0)\n      ctx.lineTo(x*w,5)\n      // bottom\n      ctx.moveTo(x*w,h)\n      ctx.lineTo(x*w,h-10)\n    }\n    ctx.stroke()\n\n    // draw the player names\n    ctx.font = '5em courier'\n    var t = ctx.measureText(world.players.b.name).width;\n    ctx.save()\n    ctx.translate(w/2,0)\n    ctx.rotate(Math.PI)\n    ctx.fillText(world.players.b.name,-t/2,0);\n    ctx.restore()\n\n    var t = ctx.measureText(world.players.a.name).width;\n    ctx.fillText(world.players.a.name,w/2-t/2,h);\n\n    // draw the player scores\n    ctx.font = '10em courier'\n    var t = ctx.measureText(world.players.b.score).width;\n    ctx.save()\n    ctx.translate(w/2,100)\n    ctx.rotate(Math.PI)\n    ctx.fillText(world.players.b.score,-t/2,0);\n    ctx.restore()\n\n    var t = ctx.measureText(world.players.a.score).width;\n    ctx.fillText(world.players.a.score,w/2-t/2,h-100);\n  },\n\n  drawStats: function(ctx){\n    var x = 0\n      , y = this.h\n      , h = 50;\n    ctx.fillStyle = 'white'\n    ctx.font = '4em courier'\n    for(var k in this.stats)\n      ctx.fillText(k+': '+this.stats[k],x,y-=h);\n  },\n\n  render: function(world, alpha){\n    this.stats.paddles = 0\n    this.stats.bounds = 0\n    this.stats.forces = 0\n    this.stats.pucks = 0\n    this.stats.extras = 0\n    this.stats.links = 0\n    this.stats.bullets = 0\n    this.stats.obstacles = 0\n    this.stats.shields = 0\n\n\n    // bounds = [t,r,b,l]\n    var w = this.w = settings.data.arenaWidth\n      , h = this.h = settings.data.arenaHeight\n      , margin = 50 // room for drawing corner positions\n      , scale = .25\n      , ctx = this.context;\n\n    // clears canvas and makes sure it stays with the bounds (w. margin)\n    if( this.resize ){\n      this.canvas.width = (w+margin)*scale;\n      this.canvas.height = (h+margin)*scale;\n\n      // guest is flipped\n      if( this.inverted ){\n        ctx.translate(this.canvas.width/2,this.canvas.height/2)\n        ctx.rotate(Math.PI)\n        ctx.translate(-this.canvas.width/2,-this.canvas.height/2)\n      }\n\n      // scale it down because 800x1600 is huge...\n      ctx.scale(scale,scale)\n\n      // move everything in according to margin\n      ctx.translate(margin/2,margin/2)\n\n      this.resize = false;\n    } else {\n      ctx.fillStyle = 'rgba(0,0,0,.3)'\n      ctx.fillRect(0,0,this.canvas.width/scale,this.canvas.height/scale)\n    }\n\n    // draw some text at the corners\n    this.drawInfo(ctx, world)\n\n    this.drawBounds(ctx);\n\n    // draw the video in the background\n    if( this.localVideo )\n      ctx.drawImage(this.localVideo,0,0);\n\n    for(var i=0, l=world.paddles.values.length; i < l; i++ )\n      this.drawPaddle(ctx,world.paddles.values[i],PADDLE_COLORS[i]);\n\n    for(var i=0, l=world.forces.values.length; i < l; i++)\n      this.drawForce(ctx,world.forces.values[i]);\n\n    for(var i=0, l=world.bullets.values.length; i < l; i++)\n      this.drawBullet(ctx,world.bullets.values[i]);\n\n    for(var i=0, l=world.obstacles.values.length; i < l; i++)\n      this.drawObstacle(ctx,world.obstacles.values[i]);\n\n    for(var i=0, l=world.extras.values.length; i < l; i++)\n      this.drawExtra(ctx,world.extras.values[i]);\n\n    for(var i=0, l=world.pucks.values.length; i < l; i++)\n      this.drawPuck(ctx,world.pucks.values[i],i);\n\n    for(var i=0, l=world.shields.values.length; i < l; i++)\n      this.drawShield(ctx,world.shields.values[i]);\n\n    this.drawStats(ctx)\n  }\n}\n\n//@ sourceURL=slam/lib/renderer-2d.js"
));
require.register("slam/lib/levels/index.js", Function("exports, require, module",
"exports.single = require('./single')\nexports.multi = require('./multi')\nexports.mobile = require('./mobile')//@ sourceURL=slam/lib/levels/index.js"
));
require.register("slam/lib/levels/sets/index.js", Function("exports, require, module",
"exports.empty = require('./empty')\nexports.barrier = require('./barrier')\nexports.pipe = require('./pipe')\nexports.columns = require('./columns')\nexports.hexagon = require('./hexagon')\nexports.octagon = require('./octagon')\nexports.triangles = require('./triangles')\nexports.trianglesattract = require('./triangles-attract')\nexports.trianglesmini = require('./triangles-mini')\nexports.diamond = require('./diamond')\nexports.breakout = require('./breakout')\nexports.diagonalblocks = require('./diagonal-blocks')\nexports.diagonalattract = require('./diagonal-attract')\nexports.centerattract = require('./center-attract')\nexports.deathballblocks = require('./deathball-blocks')\nexports.tridiamonds = require('./tridiamonds')\nexports.trianglesbarrier = require('./triangles-barrier')\nexports.arrows = require('./arrows')\nexports.diagonalrocks = require('./diagonal-rocks')\nexports.diamondsnake = require('./diamond-snake')\n\n// random (= [all sets...])\nexports.random = Object.keys(exports);//@ sourceURL=slam/lib/levels/sets/index.js"
));
require.register("slam/lib/levels/sets/empty.js", Function("exports, require, module",
"module.exports = {\n  obstacles: [],\n  forces: [],\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/empty.js"
));
require.register("slam/lib/levels/sets/barrier.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n\n   {id: 'block-rect', destroyable:true,  size: [2,1], x: hw, y: us*10 },\n   {id: 'block-rect', destroyable:true,  size: [2,1], x: hw, y: us*11 },\n   {id: 'block-rect', destroyable:false, size: [2,1], x: hw, y: us*12 },\n   {id: 'block-rect', destroyable:true,  size: [2,1], x: hw, y: us*13 },\n   {id: 'block-rect', destroyable:true,  size: [2,1], x: hw, y: us*14 },\n   {id: 'block-rect', destroyable:false, size: [2,1], x: hw, y: us*15 },\n   {id: 'block-rect', destroyable:true,  size: [2,1], x: hw, y: us*16 },\n   {id: 'block-rect', destroyable:true,  size: [2,1], x: hw, y: us*17 },\n\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: hw-us*3, y: us*10},\n    {x: hw-us*3, y: us*13},\n    {x: hw-us*3, y: us*16},\n    {x: hw+us*3, y: us*10},\n    {x: hw+us*3, y: us*13},\n    {x: hw+us*3, y: us*16}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/barrier.js"
));
require.register("slam/lib/levels/sets/pipe.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n\n   {id: 'block-rect', destroyable:false, size: [2,8], x: hw-us*3, y: us*16 },\n   {id: 'block-rect', destroyable:false, size: [2,8], x: hw+us*3, y: us*10 },\n\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: hw-us*3, y: us*10},\n    {x: hw-us*3, y: us*22},\n    {x: hw+us*3, y: us*4},\n    {x: hw+us*3, y: us*16},\n  ]\n}//@ sourceURL=slam/lib/levels/sets/pipe.js"
));
require.register("slam/lib/levels/sets/columns.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n\n    {id: 'block-rect', destroyable:false, size: [1,3], x: hw, y: hh},\n    {id: 'block-rect', destroyable:false, size: [1,3], x: hw-us*3, y: hh},\n    {id: 'block-rect', destroyable:false, size: [1,3], x: hw-us*6, y: hh},\n    {id: 'block-rect', destroyable:false, size: [1,3], x: hw+us*3, y: hh},\n    {id: 'block-rect', destroyable:false, size: [1,3], x: hw+us*6, y: hh}\n\n  ],\n\n  forces: [],\n  positions: [\n    {x: hw-us*1.5, y: hh},\n    {x: hw-us*4.5, y: hh},\n    {x: hw-us*7.5, y: hh},\n    {x: hw+us*1.5, y: hh},\n    {x: hw+us*4.5, y: hh},\n    {x: hw+us*7.5, y: hh}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/columns.js"
));
require.register("slam/lib/levels/sets/breakout.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*1.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*3.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*5.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*7.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*9.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*11.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*13.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*15.5, y: ah*.5 },\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*17.5, y: ah*.5 },\n\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*0.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*2.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*4.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*6.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*8.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*10.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*12.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*14.5, y: ah*.5 + us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*16.5, y: ah*.5 + us*3},\n\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*0.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*2.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*4.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*6.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*8.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*10.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*12.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*14.5, y: ah*.5 - us*3},\n   {id: 'block-rect', destroyable:true, size: [1,1], x: us*16.5, y: ah*.5 - us*3},\n\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/breakout.js"
));
require.register("slam/lib/levels/sets/triangles.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'triangle-left', x: 100, y: hh},\n    {id: 'triangle-right', x: aw-100, y: hh}\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/triangles.js"
));
require.register("slam/lib/levels/sets/triangles-attract.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'triangle-left', x: 100, y: hh},\n    {id: 'triangle-right', x: aw-100, y: hh}\n  ],\n\n  forces: [\n    { type: 'attract', x: aw*.5, y: ah*.5, mass: 900 }\n  ],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/triangles-attract.js"
));
require.register("slam/lib/levels/sets/triangles-mini.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , us = settings.data.unitSize\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'triangle-left', x: 40, y: hh, size:[1,2]},\n    {id: 'triangle-right', x: aw-40, y: hh, size:[1,2]}\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/triangles-mini.js"
));
require.register("slam/lib/levels/sets/triangles-barrier.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , us = settings.data.unitSize\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'triangle-left', x: 40, y: hh, size:[1,2]},\n    {id: 'triangle-right', x: aw-40, y: hh, size:[1,2]},\n    {id: 'diamond', x: hw-(5*us), y: hh+(5*us), size: 1},\n    {id: 'diamond', x: hw+(5*us), y: hh-(5*us), size: 1},\n    {id: 'diamond', x: hw, y: hh, size: 1}\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/triangles-barrier.js"
));
require.register("slam/lib/levels/sets/diamond.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'diamond', x: hw, y: hh, size: 2}\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/diamond.js"
));
require.register("slam/lib/levels/sets/hexagon.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'hexagon', x: hw, y: hh}\n  ],\n  forces: [],\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    \n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/hexagon.js"
));
require.register("slam/lib/levels/sets/octagon.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'octagon', x: hw, y: hh}\n  ],\n  forces: [],\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/octagon.js"
));
require.register("slam/lib/levels/sets/arrows.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , us = settings.data.unitSize\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'block-rect', destroyable:true, size: [1,3], x: us*.5, y: hh+us*2 },\n    {id: 'block-rect', destroyable:true, size: [1,3], x: us*1.5, y: hh+us*2 },\n\n    {id: 'block-rect', destroyable:true, size: [1,3], x: aw-us*.5, y: hh-us*2 },\n    {id: 'block-rect', destroyable:true, size: [1,3], x: aw-us*1.5, y: hh-us*2 },\n\n    {id: 'triangle-left', x: us*3-30, y: hh+us*2, size:[2,2]},\n    {id: 'triangle-right', x: aw-us*3+30, y: hh-us*2, size:[2,2]}\n\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/arrows.js"
));
require.register("slam/lib/levels/sets/center-attract.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [],\n  forces: [\n    {type: 'attract', x: hw + us*0.5, y: hh, mass: 800}\n  ],\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/center-attract.js"
));
require.register("slam/lib/levels/sets/diagonal-attract.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [],\n\n  forces: [\n    { type: 'attract', x: aw*.75, y: ah*.25, mass: 600, power: .5 },\n    { type: 'attract', x: aw*.50 + us*.5, y: ah*.5, mass: 800, power: .4 },\n    { type: 'attract', x: aw*.25, y: ah*.75, mass: 600, power: .5 }\n  ],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/diagonal-attract.js"
));
require.register("slam/lib/levels/sets/diagonal-blocks.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n   {id: 'block-rect', destroyable: true, size: [2,2], x: us*4, y: hh + us*7},\n   {id: 'block-rect', destroyable: true, size: [2,2], x: hw, y: hh},\n   {id: 'block-rect', destroyable: true, size: [2,2], x: aw - us*4, y: hh - us*7}\n  ],\n  forces: [],\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/diagonal-blocks.js"
));
require.register("slam/lib/levels/sets/deathball-blocks.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n\n  //left\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*3 - us*.5, y: hh + us*3},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*3 - us*.5, y: hh + us*2},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*3 - us*.5, y: hh + us*1},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*3 - us*.5, y: hh},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*3 - us*.5, y: hh - us*1},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*3 - us*.5, y: hh - us*2},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*3 - us*.5, y: hh - us*3},\n\n  //right\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*3 + us*.5, y: hh + us*3},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*3 + us*.5, y: hh + us*2},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*3 + us*.5, y: hh + us*1},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*3 + us*.5, y: hh},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*3 + us*.5, y: hh - us*1},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*3 + us*.5, y: hh - us*2},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*3 + us*.5, y: hh - us*3},\n\n   //far\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*2 - us*.5, y: hh - us*3},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*1 - us*.5, y: hh - us*3},\n\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*1+us*.5, y: hh - us*3},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*2+us*.5, y: hh - us*3},\n\n   //close\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*2 - us*.5, y: hh + us*3},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw-us*1 - us*.5, y: hh + us*3},\n\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*1+us*.5, y: hh + us*3},\n   {id: 'block-rect', destroyable: true, size: [1,1], x: hw+us*2+us*.5, y: hh + us*3},\n\n  ],\n  forces: [],\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    // {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/deathball-blocks.js"
));
require.register("slam/lib/levels/sets/tridiamonds.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'diamond', x: hw, y: hh, size: 2},\n    \n    // {id: 'triangle-left', x: 40, y: hh, size:[1,2]},\n    // {id: 'triangle-right', x: aw-40, y: hh, size:[1,2]}\n\n    {id: 'diamond', x: us*3, y: hh+(us*6), size: 1},\n    {id: 'diamond', x: aw-us*3, y: hh-(us*6), size: 1}\n\n    // {id: 'triangle-left', x: 40+us*2, y: hh+(us*6), size:[1,2]},\n    // {id: 'triangle-right', x: aw-(us*2), y: hh-(us*12), size:[1,2]}\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/tridiamonds.js"
));
require.register("slam/lib/levels/sets/diagonal-rocks.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , us = settings.data.unitSize\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'triangle-left', x: 40, y: hh, size:[1,2]},\n    {id: 'triangle-right', x: aw-40, y: hh, size:[1,2]},\n    {id: 'diamond', x: hw, y: hh, size: 2}\n  ],\n\n  forces: [],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 850, y: 1700},\n    {x: 850, y: 700},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/sets/diagonal-rocks.js"
));
require.register("slam/lib/levels/sets/diamond-snake.js", Function("exports, require, module",
"var settings = require('../../settings')\n  , aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2\n  , us = settings.data.unitSize;\n\nmodule.exports = {\n  obstacles: [\n    {id: 'diamond', x: hw, y: hh + (us * 5), size: 2},\n    {id: 'diamond', x: hw, y: hh - (us * 5), size: 2},\n    {id: 'triangle-left', x: hw + us - 45, y: hh + us*1.5, size:[1.5,1.5]},\n    {id: 'triangle-right', x: hw - us + 45, y: hh - us*1.5 , size:[1.5,1.5]},\n\n    {id: 'triangle-left', x: 40, y: hh+us*1.5, size:[1,2]},\n    {id: 'triangle-right', x: aw-40, y: hh-us*1.5, size:[1,2]}\n  ],\n\n  positions: [\n    {x: hw-us*3, y: us*10},\n    {x: hw-us*3, y: us*22},\n    {x: hw+us*3, y: us*4},\n    {x: hw+us*3, y: us*16}\n  ],\n\n  forces: []\n\n}//@ sourceURL=slam/lib/levels/sets/diamond-snake.js"
));
require.register("slam/lib/levels/single/index.js", Function("exports, require, module",
"module.exports = [\n  require('./level1'),\n  require('./level2'),\n  require('./level3'),\n  require('./level4'),\n  require('./level5'),\n  require('./level6'),\n  require('./level7'),\n  require('./level8'),\n  require('./level9'),\n  require('./level10'),\n  require('./level11'),\n  require('./level12'),\n]//@ sourceURL=slam/lib/levels/single/index.js"
));
require.register("slam/lib/levels/single/level1.js", Function("exports, require, module",
"module.exports = {\n  maxExtras:3,\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.4,\n    confusion:1\n  },\n\n  puck: {\n    speed: 1.3,\n    speedup: .1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 1\n  },\n\n  set: 'empty',\n\n  extras: [\n    {id: 'extralife', round:2, probability: 10},\n    {id: 'ghostball', round:4, probability: 6},\n    {id: 'paddleresize'}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level1.js"
));
require.register("slam/lib/levels/single/level2.js", Function("exports, require, module",
"module.exports = {\n\n  minSpawnTime:2,\n  maxSpawnTime:6,\n  maxExtras:3,\n\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.6,\n    confusion:0.8\n  },\n\n  puck: {\n    speed: 1.3,\n    speedup: .1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 2\n  },\n\n  set: 'empty',\n\n  extras: [\n    {id: 'extralife', probability: 80, simultaneous:3},\n    {id: 'multiball', probability: 20},\n    {id: 'fireball', round:2, probability: 40},\n    {id: 'fog', round: 3, probability: 40},\n    {id: 'ghostball', round: 4, probability: 60}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level2.js"
));
require.register("slam/lib/levels/single/level3.js", Function("exports, require, module",
"module.exports = {\n  minSpawnTime:3,\n  maxSpawnTime:6,\n  maxExtras:4,\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.5,\n    confusion:0.7\n  },\n\n  puck: {\n    speed: 1.3,\n    speedup: 0.1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 3\n  },\n\n  set: 'triangles',\n\n  extras: [\n    {id: 'extralife',probability: 6},\n    {id: 'timebomb',probability: 6, round:2},\n    {id: 'laser',probability: 12, round:3},\n    {id: 'ghostball',probability: 6, round:2},\n    {id: 'fog',probability: 1},\n  ],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level3.js"
));
require.register("slam/lib/levels/single/level4.js", Function("exports, require, module",
"module.exports = {\n  maxExtras:4,\n  \n  ai: {\n    maxSpeed: 10,\n    reaction: 0.3,\n    viewRange: 0.5,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 4\n  },\n\n  set: 'centerattract',\n\n  extras: [\n    {id: 'extralife', probability: 20},\n    {id: 'laser', probability: 15},\n    {id: 'bulletproof', duration: 10, probability: 10},\n    {id: 'ghostball',round:4, probability: 10},\n    {id: 'timebomb', round:2, probability: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level4.js"
));
require.register("slam/lib/levels/single/level5.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.34,\n    viewRange: 0.5,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.6,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 5\n  },\n\n  set: 'diagonalattract',\n\n  extras: [\n    {id: 'extralife',probability: 5},\n    {id: 'fog', duration: 5},\n    {id: 'fireball',probability: 10},\n    {id: 'ghostball',probability: 5},\n    {id: 'paddleresize', round:2, probability: 10},\n    {id: 'laser', round:3, probability: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level5.js"
));
require.register("slam/lib/levels/single/level6.js", Function("exports, require, module",
"module.exports = {\n  minSpawnTime:3,\n  maxSpawnTime:6,\n  maxExtras:3,\n\n  ai: {\n    maxSpeed: 15,\n    reaction: 0.25,\n    viewRange: 0.3,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 6\n  },\n\n  set: 'hexagon',\n\n  extras: [\n    {id: 'fireball',probability: 5},\n    {id: 'extralife',probability: 10},\n    {id: 'fog', duration: 6,probability: 5},\n    {id: 'bulletproof',probability: 5},\n    \n  ]\n}//@ sourceURL=slam/lib/levels/single/level6.js"
));
require.register("slam/lib/levels/single/level7.js", Function("exports, require, module",
"module.exports = {\n  minSpawnTime:3,\n  maxSpawnTime:5,\n  ai: {\n    maxSpeed: 19,\n    reaction:0.3,\n    viewRange:0.3,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.7,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 7\n  },\n\n  set: 'diagonalblocks',\n\n  extras: [\n    {id: 'extralife',probability: 10},\n    {id: 'laser',probability: 20},\n    {id: 'paddleresize',probability: 20},\n    {id: 'fog', duration: 5,probability: 5},\n    {id: 'fireball',probability: 10},\n    {id: 'ghostball',probability: 5},\n    {id: 'bulletproof', duration: 10,probability: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level7.js"
));
require.register("slam/lib/levels/single/level8.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 19,\n    reaction:0.3,\n    viewRange:0.3,\n    confusion:0.45\n  },\n\n  puck: {\n    speed: 1.8,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 8\n  },\n\n  set: 'diamond',\n\n  extras: [\n    {id: 'extralife'},\n    {id: 'fog', duration: 10},\n    {id: 'fireball'},\n    {id: 'ghostball'},\n    {id: 'bulletproof', duration: 10}, // duration in seconds (buggy)\n    {id: 'mirroredcontrols', duration: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level8.js"
));
require.register("slam/lib/levels/single/level9.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 13,\n    reaction: 0.3,\n    viewRange: 0.6,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.6,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 9\n  },\n\n  set: 'breakout',\n\n  extras: [\n    {id: 'extralife'},\n    {id: 'fog', duration: 10},\n    {id: 'multiball'},\n    {id: 'fireball'},\n    {id: 'ghostball'},\n    {id: 'bulletproof', duration: 5}, // duration in seconds\n    {id: 'mirroredcontrols', duration: 10} // duration in seconds\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level9.js"
));
require.register("slam/lib/levels/single/level10.js", Function("exports, require, module",
"var settings = require('../../settings');\n\nvar aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  maxExtras: 4,\n  ai: {\n    maxSpeed: 17,\n    reaction: 0.3,\n    viewRange: 0.5,\n    confusion: 0.5\n  },\n\n  puck: {\n    speed: 1.6,\n    speedup: 0.1,\n    maxspeed: 2.6\n  },\n\n  player: {\n    shields: 10\n  },\n\n  set: 'deathballblocks',\n\n  extras: [\n    {id: 'deathball',round:3, probability: 5, duration:6, position:{x: hw, y:hh}},\n    {id: 'extralife',probability: 2},\n    {id: 'timebomb',probability: 2},\n    {id: 'fireball',probability: 2},\n    {id: 'ghostball',round:2,probability: 2},\n    {id: 'bulletproof', duration: 10, round:2, probability: 2} // duration in seconds (buggy)\n  ]\n}//@ sourceURL=slam/lib/levels/single/level10.js"
));
require.register("slam/lib/levels/single/level11.js", Function("exports, require, module",
"\nmodule.exports = {\n  ai: {\n    maxSpeed: 15,\n    reaction: 0.2,\n    viewRange: 0.5,\n    confusion: 0.5\n  },\n\n  puck: {\n    speed: 1.7,\n    speedup: 0.2,\n    maxspeed: 2.3\n  },\n\n  player: {\n    shields: 11\n  },\n\n  set: 'diamondsnake',\n\n  extras: [\n    {id: 'extralife'},\n    {id: 'laser'},\n    {id: 'fog'},\n    {id: 'paddleresize'},\n    {id: 'mirroredcontrols'},\n    {id: 'ghostball',round:2},\n    {id: 'bulletproof', round:2},\n    {id: 'timebomb', round:3},\n    {id: 'laser', round:3}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level11.js"
));
require.register("slam/lib/levels/single/level12.js", Function("exports, require, module",
"\nmodule.exports = {\n  ai: {\n    maxSpeed: 15,\n    reaction: 0.2,\n    viewRange: 0.5,\n    confusion: 0.5\n  },\n\n  puck: {\n    speed: 1.7,\n    speedup: 0.2,\n    maxspeed: 2.3\n  },\n\n  player: {\n    shields: 12\n  },\n\n  set: 'random',\n\n  extras: [\n    {id: 'extralife'},\n    {id: 'laser'},\n    {id: 'fog'},\n    {id: 'paddleresize'},\n    {id: 'mirroredcontrols'},\n    {id: 'ghostball',round:2},\n    {id: 'bulletproof', round:2},\n    {id: 'timebomb', round:3},\n    {id: 'laser', round:3}\n  ]\n}\n//@ sourceURL=slam/lib/levels/single/level12.js"
));
require.register("slam/lib/levels/multi/index.js", Function("exports, require, module",
"module.exports = [\n  require('./level1'),\n  require('./level2'),\n  require('./level3'),\n  require('./level4'),\n  require('./level5'),\n  require('./level6'),\n  require('./level7'),\n  require('./level8'),\n  require('./level9'),\n  require('./level10'),\n  require('./level11')\n]//@ sourceURL=slam/lib/levels/multi/index.js"
));
require.register("slam/lib/levels/multi/level1.js", Function("exports, require, module",
"module.exports = {\n  maxExtras: 2,\n  minSpawnTime: 4,\n  maxSpawnTime: 7,\n\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.4,\n    confusion:1\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: 0.1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 1\n  },\n\n  set: 'diagonalrocks',\n\n  extras: [\n    {id: 'extralife', probability: 10},\n    {id: 'timebomb', probability: 7},\n    {id: 'ghostball', probability: 7},\n    {id: 'paddleresize', round:2, probability: 10 },\n    {id: 'bulletproof', duration: 6},\n    {id: 'laser', round:2,probability: 10 },\n    {id: 'fog', round: 3, probability: 7},\n    {id: 'timebomb', round:3}\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level1.js"
));
require.register("slam/lib/levels/multi/level2.js", Function("exports, require, module",
"module.exports = {\n  maxExtras: 2,\n  minSpawnTime: 3,\n  maxSpawnTime: 6,\n\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.3,\n    viewRange: 0.5,\n    confusion: 0.5\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 2\n  },\n\n  set: 'arrows',\n\n  extras: [\n    {id: 'extralife', probability: 5},\n    {id: 'laser', probability: 7},\n    {id: 'ghostball', probability: 3},\n    {id: 'bulletproof', duration: 5},\n    {id: 'timebomb', probability: 8},\n    {id: 'paddleresize', probability: 7 },\n    {id: 'mirroredcontrols', round: 5, duration: 15} // duration in seconds\n  ]\n}//@ sourceURL=slam/lib/levels/multi/level2.js"
));
require.register("slam/lib/levels/multi/level3.js", Function("exports, require, module",
"module.exports = {\n  minSpawnTime: 3,\n  maxSpawnTime: 6,\n  maxExtras: 3,\n\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.5,\n    confusion: 0.7\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: 0.1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 3\n  },\n\n  set: 'trianglesbarrier',\n\n  extras: [\n    {id: 'extralife', probability: 6},\n    {id: 'timebomb', probability: 6},\n    {id: 'ghostball', probability: 3},\n    {id: 'fog', probability: 3},\n    {id: 'paddleresize', probability: 10 },\n    {id: 'mirroredcontrols', round: 5, duration: 15}, // duration in seconds\n    {id: 'bulletproof', duration: 10, probability: 5}\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level3.js"
));
require.register("slam/lib/levels/multi/level4.js", Function("exports, require, module",
"\nmodule.exports = {\n  minSpawnTime: 3,\n  maxSpawnTime: 6,\n  maxExtras:4,\n\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.6,\n    confusion: 0.8\n  },\n\n  puck: {\n    speed: 1.6,\n    speedup: .1,\n    maxspeed: 2.2\n  },\n\n  player: {\n    shields: 4\n  },\n\n  // set: 'pipe',\n  set: 'tridiamonds',\n\n  extras: [\n    // {id: 'extralife', probability: 10},\n    {id: 'ghostball', probability: 7},\n    {id: 'paddleresize', round:2, probability: 10 },\n    {id: 'fog', probability: 7},\n    {id: 'mirroredcontrols', round: 4, duration: 15}, // duration in seconds\n    {id: 'bulletproof', duration: 10, probability: 5},\n    {id: 'timebomb', round: 2, probability: 6}\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level4.js"
));
require.register("slam/lib/levels/multi/level5.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 13,\n    reaction: 0.34,\n    viewRange: 0.5,\n    confusion:0.4\n  },\n\n  puck: {\n    speed: 1.6,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 5\n  },\n\n  set: 'octagon',\n\n  extras: [\n    {id: 'extralife',probability: 5},\n    {id: 'fog', duration: 5},\n    // {id: 'fireball',probability: 10},\n    {id: 'ghostball',probability: 5},\n    {id: 'paddleresize', round:2, probability: 10},\n//    {id: 'laser', round:3, probability: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level5.js"
));
require.register("slam/lib/levels/multi/level6.js", Function("exports, require, module",
"module.exports = {\n  maxExtras: 4,\n  minSpawnTime: 4,\n  maxSpawnTime: 7,\n\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.4,\n    confusion:1\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: 0.1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 6\n  },\n\n  set: 'diamondsnake',\n\n  extras: [\n    {id: 'extralife', probability: 10},\n    {id: 'timebomb', probability: 7},\n    {id: 'ghostball', probability: 7},\n    {id: 'paddleresize', round:2, probability: 10 },\n    {id: 'bulletproof', duration: 6},\n    {id: 'laser', round:2,probability: 10 },\n    {id: 'fog', round: 3, probability: 7},\n    {id: 'timebomb', round:3}\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level6.js"
));
require.register("slam/lib/levels/multi/level7.js", Function("exports, require, module",
"module.exports = {\n  minSpawnTime:3,\n  maxSpawnTime:5,\n  ai: {\n    maxSpeed: 19,\n    reaction:0.3,\n    viewRange:0.3,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.7,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 7\n  },\n\n  set: 'diagonalblocks',\n\n  extras: [\n    {id: 'extralife',probability: 10},\n//    {id: 'laser',probability: 20},\n    {id: 'paddleresize',probability: 20},\n    {id: 'fog', duration: 5,probability: 5},\n    // {id: 'fireball',probability: 10},\n    {id: 'ghostball',probability: 5},\n    {id: 'bulletproof', duration: 10,probability: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level7.js"
));
require.register("slam/lib/levels/multi/level8.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 19,\n    reaction:0.3,\n    viewRange:0.2,\n    confusion:0.7\n  },\n\n  puck: {\n    speed: 1.4,\n    speedup: .1,\n    maxspeed: 1.9\n  },\n\n  player: {\n    shields: 8\n  },\n\n  set: 'diamond',\n\n  extras: [\n    {id: 'extralife'},\n    {id: 'fog', duration: 10},\n    {id: 'laser'},\n    {id: 'ghostball'},\n    {id: 'bulletproof', duration: 10}, // duration in seconds (buggy)\n    {id: 'mirroredcontrols', duration: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level8.js"
));
require.register("slam/lib/levels/multi/level9.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 15,\n    reaction: 0.3,\n    viewRange: 0.7,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.6,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 9\n  },\n\n  set: 'breakout',\n\n  extras: [\n    {id: 'extralife'},\n    {id: 'fog', duration: 10},\n    {id: 'multiball'},\n    // {id: 'fireball'},\n    {id: 'ghostball'},\n    {id: 'bulletproof', duration: 5}, // duration in seconds (buggy)\n    {id: 'mirroredcontrols', duration: 10} // duration in seconds\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level9.js"
));
require.register("slam/lib/levels/multi/level10.js", Function("exports, require, module",
"var settings = require('../../settings');\n\nvar aw = settings.data.arenaWidth\n  , ah = settings.data.arenaHeight\n  , hw = aw/2\n  , hh = ah/2;\n\nmodule.exports = {\n  maxExtras:4,\n  ai: {\n    maxSpeed: 18,\n    reaction: 0.3,\n    viewRange: 0.5,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.6,\n    speedup: .1,\n    maxspeed: 2.3\n  },\n\n  player: {\n    shields:10\n  },\n\n  set: 'deathballblocks',\n\n  extras: [\n    {id: 'deathball', probability: 15, duration:6, position: {x: hw, y: hh}},\n    {id: 'extralife',probability: 2},\n    {id: 'timebomb',probability: 2},\n    // {id: 'fireball',round:2,probability: 2},\n    {id: 'ghostball',round:2,probability: 2},\n    {id: 'bulletproof', duration: 10,round:2,probability: 2}, // duration in seconds (buggy)\n\n  ],\n\n  /*positions: [\n    {x: hw, y: hh}\n  ]*/\n}//@ sourceURL=slam/lib/levels/multi/level10.js"
));
require.register("slam/lib/levels/multi/level11.js", Function("exports, require, module",
"\nmodule.exports = {\n  ai: {\n    maxSpeed: 15,\n    reaction: 0.2,\n    viewRange: 0.5,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.4,\n    speedup: .1,\n    maxspeed: 2.0\n  },\n\n  player: {\n    shields:11\n  },\n\n  set: 'random',\n\n  extras: [\n    {id: 'extralife'},\n    {id: 'laser'},\n    {id: 'fog'},\n    {id: 'paddleresize'},\n    {id: 'mirroredcontrols'},\n    {id: 'ghostball',round:2},\n    {id: 'bulletproof', round:2},\n    {id: 'timebomb', round:3},\n  ]\n}\n//@ sourceURL=slam/lib/levels/multi/level11.js"
));
require.register("slam/lib/levels/mobile/index.js", Function("exports, require, module",
"// TODO write other levels instead of using singleplayers\nmodule.exports = [\n  require('./level1'),\n  require('./level2'),\n  require('./level3'),\n  require('./level4'),\n  require('./level5'),\n  require('./level6'),\n  require('./level7')\n]//@ sourceURL=slam/lib/levels/mobile/index.js"
));
require.register("slam/lib/levels/mobile/level1.js", Function("exports, require, module",
"module.exports = {\n  maxExtras:3,\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.4,\n    confusion:.8\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 1\n  },\n\n  set: 'empty',\n\n  extras: [\n    {id: 'extralife', round:1, probability: 5},\n    {id: 'multiball', round:1, probability: 7},\n    {id: 'ghostball', round:1, probability: 7},\n  ]\n}//@ sourceURL=slam/lib/levels/mobile/level1.js"
));
require.register("slam/lib/levels/mobile/level2.js", Function("exports, require, module",
"module.exports = {\n\n  minSpawnTime:2,\n  maxSpawnTime:6,\n  maxExtras:3,\n\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.2,\n    viewRange: 0.6,\n    confusion:0.8\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 2\n  },\n\n  set: 'empty',\n\n  extras: [\n    {id: 'extralife', probability: 4},\n    {id: 'multiball', probability: 4},\n    {id: 'laser', probability: 4},\n    {id: 'fog', round: 3, probability: 4},\n    {id: 'bulletproof', round: 3, probability: 4},\n    {id: 'timebomb', round: 2, probability: 4}\n  ]\n}\n//@ sourceURL=slam/lib/levels/mobile/level2.js"
));
require.register("slam/lib/levels/mobile/level3.js", Function("exports, require, module",
"\nmodule.exports = {\n  maxExtras: 4,\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.3,\n    viewRange: 0.5,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2.5\n  },\n\n  player: {\n    shields: 3\n  },\n\n  set: 'centerattract',\n\n  extras: [\n    {id: 'extralife', probability: 20},\n    {id: 'laser', probability: 15},\n    {id: 'bulletproof', duration: 10, probability: 10},\n    {id: 'ghostball',round:4, probability: 10},\n    {id: 'timebomb', round:2, probability: 10}\n  ]\n}\n//@ sourceURL=slam/lib/levels/mobile/level3.js"
));
require.register("slam/lib/levels/mobile/level4.js", Function("exports, require, module",
"module.exports = {\n  minSpawnTime:3,\n  maxSpawnTime:6,\n  maxExtras:4,\n  ai: {\n    maxSpeed: 10,\n    reaction: 0.4,\n    viewRange: 0.5,\n    confusion:0.7\n  },\n\n  puck: {\n    speed: 1.3,\n    speedup: 0.1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 3\n  },\n\n  set: 'trianglesattract',\n\n  extras: [\n    {id: 'extralife',probability: 6},\n    {id: 'laser',probability: 8},\n    {id: 'paddleresize',probability: 12, round:3},\n    {id: 'ghostball',probability: 6, round:2},\n    {id: 'fog',probability: 1}\n  ],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/mobile/level4.js"
));
require.register("slam/lib/levels/mobile/level5.js", Function("exports, require, module",
"module.exports = {\n  maxExtras:4,\n  ai: {\n    maxSpeed: 17,\n    reaction: 0.3,\n    viewRange: 0.5,\n    confusion:0.4\n  },\n\n  puck: {\n    speed: 2,\n    speedup: .13,\n    maxspeed: 2.7\n  },\n\n  player: {\n    shields: 6\n  },\n\n  set: 'empty',\n\n  extras: [\n    {id: 'extralife', probability: 4},\n    {id: 'fog', duration: 3},\n    {id: 'ghostball', probability: 2},\n    {id: 'multiball', probability: 3},\n    {id: 'laser', probability: 6},\n    {id: 'fireball', probability: 5},\n    {id: 'timebomb', probability: 5},\n    {id: 'bulletproof', probability: 3}\n\n  ],\n  positions: [\n    {x: 850, y: 2000},\n    {x: 850, y: 200},\n\n    {x: 1200, y: 1227},\n    {x: 200, y: 1227}\n  ]\n}\n//@ sourceURL=slam/lib/levels/mobile/level5.js"
));
require.register("slam/lib/levels/mobile/level6.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 15,\n    reaction: 0.25,\n    viewRange: 0.3,\n    confusion: 0.5\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 6\n  },\n\n  set: 'octagon',\n\n  extras: [\n    {id: 'extralife', probability: 3},\n    {id: 'fog', duration: 10, probability: 2},\n    {id: 'bulletproof', probability:3},\n    {id: 'ghostball', probability: 4}\n  ],\n\n  positions: [\n    {x: 200, y: 200},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/mobile/level6.js"
));
require.register("slam/lib/levels/mobile/level7.js", Function("exports, require, module",
"module.exports = {\n  ai: {\n    maxSpeed: 15,\n    reaction: 0.25,\n    viewRange: 0.3,\n    confusion:0.5\n  },\n\n  puck: {\n    speed: 1.5,\n    speedup: .1,\n    maxspeed: 2\n  },\n\n  player: {\n    shields: 6\n  },\n\n  set: ['octagon','empty','centerattract','triangles'],\n\n  extras: [\n    {id: 'extralife', probability: 5},\n    {id: 'fog', duration: 10, probability: 2},\n    {id: 'bulletproof', probability:5},\n    {id: 'ghostball', probability: 4},\n    {id: 'multiball', probability: 4},\n    {id: 'laser', probability: 4},\n    {id: 'fireball', probability: 4},\n    {id: 'timebomb', probability: 4},\n\n  ],\n  positions: [\n    {x: 200, y: 200},\n    {x: 200, y: 2000},\n    {x: 1400, y: 200},\n    {x: 1400, y: 2000}\n  ]\n}//@ sourceURL=slam/lib/levels/mobile/level7.js"
));
require.alias("component-emitter/index.js", "slam/deps/emitter/index.js");
require.alias("component-indexof/index.js", "component-emitter/deps/indexof/index.js");

require.alias("component-mousetrap/index.js", "slam/deps/mousetrap/index.js");

require.alias("component-cookie/index.js", "slam/deps/cookie/index.js");

require.alias("component-jquery/index.js", "slam/deps/jquery/index.js");

require.alias("component-preloader/index.js", "slam/deps/preloader/index.js");
require.alias("visionmedia-batch/index.js", "component-preloader/deps/batch/index.js");
require.alias("component-emitter/index.js", "visionmedia-batch/deps/emitter/index.js");
require.alias("component-indexof/index.js", "component-emitter/deps/indexof/index.js");

require.alias("component-inherit/index.js", "component-preloader/deps/inherit/index.js");

require.alias("publicclass-request-animation-frame/index.js", "slam/deps/request-animation-frame/index.js");

require.alias("publicclass-now/index.js", "slam/deps/now/index.js");

require.alias("publicclass-geom/index.js", "slam/deps/geom/index.js");
require.alias("publicclass-geom-vec/index.js", "publicclass-geom/deps/geom-vec/index.js");

require.alias("publicclass-geom-mat/index.js", "publicclass-geom/deps/geom-mat/index.js");

require.alias("publicclass-geom-poly/index.js", "publicclass-geom/deps/geom-poly/index.js");
require.alias("publicclass-geom-vec/index.js", "publicclass-geom-poly/deps/geom-vec/index.js");

require.alias("publicclass-copy/index.js", "slam/deps/copy/index.js");
require.alias("component-type/index.js", "publicclass-copy/deps/type/index.js");

require.alias("publicclass-stash/index.js", "slam/deps/stash/index.js");

require.alias("publicclass-netchan/index.js", "slam/deps/netchan/index.js");

require.alias("publicclass-latency/index.js", "slam/deps/latency/index.js");
require.alias("component-standard-deviation/index.js", "publicclass-latency/deps/standard-deviation/index.js");
require.alias("component-variance/index.js", "component-standard-deviation/deps/variance/index.js");
require.alias("component-to-function/index.js", "component-variance/deps/to-function/index.js");

require.alias("component-mean/index.js", "component-variance/deps/mean/index.js");
require.alias("component-to-function/index.js", "component-mean/deps/to-function/index.js");

require.alias("publicclass-median/index.js", "publicclass-latency/deps/median/index.js");

require.alias("publicclass-base64-arraybuffer/index.js", "slam/deps/base64-arraybuffer/index.js");

require.alias("visionmedia-debug/index.js", "slam/deps/debug/index.js");
require.alias("visionmedia-debug/debug.js", "slam/deps/debug/debug.js");

require.alias("ecarter-css-emitter/index.js", "slam/deps/css-emitter/index.js");
require.alias("component-emitter/index.js", "ecarter-css-emitter/deps/emitter/index.js");
require.alias("component-indexof/index.js", "component-emitter/deps/indexof/index.js");

require.alias("component-event/index.js", "ecarter-css-emitter/deps/event/index.js");

